{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE DeriveAnyClass #-}

-- | X86 (and X87) instructions
--
-- TODO: 
--    - add flag for control-flow instructions (branches, return, call, etc.)
--    - x87 instructions: FPU status flags (C0,C1,C2,C3) are not indicated yet
--    - add potential exceptions
--    - add required privilege 
--    - add pseudo-code for each instruction
--    - instruction sets
--       - 3DNow!
--       - XOP encoded instructions
--       - AVX512
--    - granularity field in vectorial instructions (packed
--    byte/word/dword/etc.)
--
-- FIXME: X87 instructions don't encode precisely the stack popping (e.g., it is
-- not enough to say that ST(1) is accessed in Read/Write mode, we need to
-- encode that ST(n+1) becomes ST(n) for all n)
--
-- FIXME: MemAlign property needs to be checked (added only since vhaddpd)
--
module ViperVM.Arch.X86_64.Assembler.Insns
   ( X86Insn(..)
   , X86Arch(..)
   , X86Extension(..)
   , Properties(..)
   , FlagOp(..)
   , Encoding(..)
   , VexLW (..)
   , EncodingProperties(..)
   , OperandSpec(..)
   , OperandEnc(..)
   , OpcodeMap(..)
   , LegacyMap(..)
   , AccessMode(..)
   , EncodingVariant(..)
   , HLEAction (..)
   , ValidMode (..)
   , instructions
   -- * Helper methods
   , encValidModRMMode
   , encMayHaveMemoryOperand
   , encHasHLE
   , hasImmediate
   , isImmediate
   , isLegacyEncoding
   , isVexEncoding
   , encOpcode
   , encOpcodeExt
   , encOpcodeFullExt
   , encOpcodeMap
   , encOperands
   , encMandatoryPrefix
   , encProperties
   , encParams
   , encNoForce8Bit
   , encSignExtendImmBit
   , encReversableBit
   , encFPUSizableBit
   , encFPUDestBit
   , encFPUPopBit
   , encLockable
   , encRepeatable
   , encBranchHintable
   , encRequireModRM
   , amd3DNowEncoding
   )
where

import Data.Word
import Data.List ((\\))
import Data.Maybe

import ViperVM.Format.Binary.BitSet (CBitSet(..))
import ViperVM.Arch.X86_64.MicroArch
import ViperVM.Arch.X86_64.Assembler.Operand
import ViperVM.Arch.X86_64.Assembler.Opcode
import ViperVM.Arch.X86_64.Assembler.Mode
import ViperVM.Arch.X86_64.Assembler.Registers
import ViperVM.Arch.X86_64.Assembler.Size

-- | X86 instruction
data X86Insn = X86Insn
   { insnDesc        :: String
   , insnMnemonic    :: String
   , insnProperties  :: [Properties]
   , insnFlags       :: [FlagOp Flag]
   , insnEncodings   :: [Encoding]
   } deriving (Show)

-- | Flag state modification
data FlagOp a
   = St        [a]  -- ^ Set flag to 1
   | Unset     [a]  -- ^ Set flag to 0
   | Modified  [a]  -- ^ Set flag depending on the result
   | Undefined [a]  -- ^ Flag is undefined after the operation
   | Read      [a]  -- ^ Flag read by the instruction
   deriving (Show,Eq)

-- | Instruction encoding
data Encoding
   = LegacyEncoding
      { legacyMandatoryPrefix :: Maybe Word8          -- ^ Mandatory prefix
      , legacyOpcodeMap       :: LegacyMap            -- ^ Map
      , legacyOpcode          :: Word8                -- ^ Opcode
      , legacyOpcodeExt       :: Maybe Word8          -- ^ Opcode extension in ModRM.reg
      , legacyOpcodeFullExt   :: Maybe Word8          -- ^ Opcode extension in full ModRM byte
      , legacyReversable      :: Maybe Int            -- ^ Args are reversed if the given bit is
                                                      --   set in the opcode.
      , legacyNoForce8bit     :: Maybe Int            -- ^ Operand size is 8 if the given bit is
                                                      --   unset in the opcode. Otherwise, the
                                                      --   size is defined by operand-size
                                                      --   prefix and REX.W bit
      , legacySignExtendable  :: Maybe Int            -- ^ Used in conjunction with a set
                                                      --   Sizable bit.  Imm8 operand is used
                                                      --   and sign-extended if the given bit is
                                                      --   set
      , legacyFPUDest         :: Maybe Int            -- ^ Opcode bit: register destination (0 if ST0, 1 if ST(i))
                                                      --   only if both operands are registers!
      , legacyFPUPop          :: Maybe Int            -- ^ Opcode bit: pop the FPU register,
                                                      --   only if destination is (ST(i))
      , legacyFPUSizable      :: Maybe Int            -- ^ Opcode bit: change the FPU size (only if memory operand)
      , legacyProperties      :: [EncodingProperties] -- ^ Encoding properties
      , legacyParams          :: [OperandSpec]        -- ^ Operand encoding
      }
   | VexEncoding
      { vexMandatoryPrefix :: Maybe Word8          -- ^ Mandatory prefix
      , vexOpcodeMap       :: OpcodeMap            -- ^ Map
      , vexOpcode          :: Word8                -- ^ Opcode
      , vexOpcodeExt       :: Maybe Word8          -- ^ Opcode extension in ModRM.reg
      , vexReversable      :: Maybe Int            -- ^ Args are reversed if the given bit is
                                                   --   set in the opcode.
      , vexLW              :: VexLW
      , vexProperties      :: [EncodingProperties] -- ^ Encoding properties
      , vexParams          :: [OperandSpec]        -- ^ Operand encoding
      }
   deriving (Show)

-- | VEX.(L/W) spec
data VexLW
   = W0     -- ^ Vex.W = 0
   | W1     -- ^ Vex.W = 1
   | WIG    -- ^ Vex.W ignored
   | L0_WIG -- ^ Vex.L = 0, ignore Vex.W
   | L1_WIG -- ^ Vex.L = 1, ignore Vex.W
   | L0_W0  -- ^ Vex.L = 0, Vex.W = 0 
   | L0_W1  -- ^ Vex.L = 0, Vex.W = 1
   | L1_W0  -- ^ Vex.L = 1, Vex.W = 0 
   | L1_W1  -- ^ Vex.L = 1, Vex.W = 1
   | LIG_W0 -- ^ Ignore Vex.L, Vex.W = 0 
   | LIG_W1 -- ^ Ignore Vex.L, Vex.W = 1
   | L0     -- ^ Vex.L = 0
   | LIG    -- ^ Vex.L ignored
   | LWIG   -- ^ Ignore Vex.W and Vex.L
   deriving (Show)

-- | Instruction properties
data Properties
   = FailOnZero Int           -- ^ Fail if the n-th parameter (indexed from 0) is 0
   | MemAlign Int             -- ^ Memory alignment constraint in bytes
   | MemAlignDefault          -- ^ Memory alignment constraint
   deriving (Show,Eq)

-- | Encoding properties
data EncodingProperties
   = LongModeSupport          -- ^ Supported in 64 bit mode
   | LegacyModeSupport        -- ^ Supported in legacy/compatibility mode
   | Lockable                 -- ^ Support LOCK prefix (only if a memory operand
                              --   is used)
   | BranchHintable           -- ^ Support branch-hint prefixes
   | ImplicitLock             -- ^ Implicitly locked (lock prefix still supported)
   | Repeatable               -- ^ Allow repeat prefix
   | Commutable               -- ^ Operands can be commuted
   | DefaultOperandSize64     -- ^ Default operand size is 64-bits for this
                              --   instruction in LongMode
   | NoOperandSize64          -- ^ 64-bit operand size not supported

   | DefaultAddressSize64     -- ^ Default address size is 64-bits for this
                              --   instruction in LongMode
   | Extension X86Extension   -- ^ Required CPU extension
   | Arch X86Arch             -- ^ Instruction added starting at the given arch
   | RequireRexW              -- ^ Require REX.W
   | DefaultSegment Register  -- ^ Default register
   | HLE HLEAction            -- ^ Hardware-lock elision (HLE)
   deriving (Show,Eq)

data HLEAction
   = XAcquire
   | XRelease
   | XBoth
   deriving (Show,Eq)

-- | Instruction variant encoding
data EncodingVariant
   = Locked                     -- ^ Locked memory access
   | Reversed                   -- ^ Parameters are reversed (useful when some instructions have two valid encodings, e.g. CMP reg8, reg8)
   | ExplicitParam              -- ^ A variant exists with an implicit parameter, but the explicit variant is used
   | RepeatZero                 -- ^ REP(Z) prefix
   | RepeatNonZero              -- ^ REPNZ prefix
   | LockEllisionAcquire        -- ^ XACQUIRE prefix
   | LockEllisionRelease        -- ^ XRELEASE prefix
   | BranchHintTaken            -- ^ Branch hint (branch taken)
   | BranchHintNotTaken         -- ^ Branch hint (not taken)
   | SuperfluousSegmentOverride -- ^ Segment override equal to default segment
   deriving (Show,Eq,Enum,CBitSet)


-------------------------------------------------------------------
-- Helper methods
-------------------------------------------------------------------

-- | Instruction
insn :: X86Insn
insn = X86Insn
   { insnDesc        = ""
   , insnMnemonic    = ""
   , insnProperties  = []
   , insnFlags       = []
   , insnEncodings   = []
   }

-- | Flags
allFlags :: [Flag]
allFlags = [CF,PF,AF,ZF,SF,TF,OF]

-- | Legacy encoding
leg :: Encoding
leg = LegacyEncoding
   { legacyMandatoryPrefix = Nothing
   , legacyOpcodeMap       = MapPrimary
   , legacyOpcode          = 0
   , legacyOpcodeExt       = Nothing
   , legacyOpcodeFullExt   = Nothing
   , legacyReversable      = Nothing
   , legacyNoForce8bit     = Nothing
   , legacySignExtendable  = Nothing
   , legacyFPUDest         = Nothing
   , legacyFPUPop          = Nothing
   , legacyFPUSizable      = Nothing
   , legacyProperties      = []
   , legacyParams          = []
   }

-- | Vex encoding
vex :: Encoding
vex = VexEncoding
   { vexMandatoryPrefix = Nothing
   , vexOpcodeMap       = MapVex 0
   , vexOpcode          = 0
   , vexOpcodeExt       = Nothing
   , vexReversable      = Nothing
   , vexLW              = LWIG
   , vexProperties      = []
   , vexParams          = []
   }

-- | Operand
op :: AccessMode -> OperandType -> OperandEnc -> OperandSpec
op = OperandSpec


-- | Immediate helpers. Immediate operands are always read-only and encoded in
-- the same way.
imm :: ImmType -> OperandSpec
imm s = op RO (T_Imm s) Imm

-- | 8-bit immediate operand
imm8 :: OperandSpec
imm8 = imm ImmSize8

-- | 16-bit immediate operand
imm16 :: OperandSpec
imm16 = imm ImmSize16

-- | operand-sized immediate operand
immOp :: OperandSpec
immOp = imm ImmSizeOp

-- | operand-sized immediate operand, sign-extended 32-bit for 64-bit
immSE :: OperandSpec
immSE = imm ImmSizeSE

-- | 256-bit memory
mem256 :: AccessMode -> OperandSpec
mem256 m = op m (T_Mem Mem256) RM

-- | 128-bit memory
mem128 :: AccessMode -> OperandSpec
mem128 m = op m (T_Mem Mem128) RM

-- | 64-bit memory
mem64 :: AccessMode -> OperandSpec
mem64 m = op m (T_Mem Mem64) RM

-- | 64-bit vector or memory
mvec64 :: AccessMode -> OperandSpec
mvec64 m = op m (TME (T_Reg RegVec64) (T_Mem Mem64)) RM

-- | 256-bit vector or memory
mvec256 :: AccessMode -> OperandSpec
mvec256 m = op m (TME (T_Reg RegVec256) (T_Mem Mem256)) RM

-- | 128-bit vector or memory
mvec128 :: AccessMode -> OperandSpec
mvec128 m = op m (TME (T_Reg RegVec128) (T_Mem Mem128)) RM

-- | 128-bit or 256-bit vector or memory
mvec128o256 :: AccessMode -> OperandSpec
mvec128o256 m = op m (TME
      (TLE (T_Reg RegVec128) (T_Reg RegVec256))
      (TLE (T_Mem Mem128)    (T_Mem Mem256)))
   RM

-- | low 64-bit of 128-bit vector or 64-bit memory
mvec128low64 :: AccessMode -> OperandSpec
mvec128low64 m = op m (TME (T_SubReg SubLow64 RegVec128) (T_Mem Mem64)) RM

-- | low 32-bit of 128-bit vector or 32-bit memory
mvec128low32 :: AccessMode -> OperandSpec
mvec128low32 m = op m (TME (T_SubReg SubLow32 RegVec128) (T_Mem Mem32)) RM

-- | low 16-bit of 128-bit vector or 16-bit memory
mvec128low16 :: AccessMode -> OperandSpec
mvec128low16 m = op m (TME (T_SubReg SubLow16 RegVec128) (T_Mem Mem16)) RM

-- | low 8-bit of 128-bit vector or 8-bit memory
mvec128low8 :: AccessMode -> OperandSpec
mvec128low8 m = op m (TME (T_SubReg SubLow8 RegVec128) (T_Mem Mem8)) RM

-- | 64-bit even positioned values in vector register or memory
--    * low 64-bit of 128-bit vector
--    * [63,0] and [191,128] of 256-bit vector
mvecEven64 :: AccessMode -> OperandSpec
mvecEven64 m = op m (TME
   (TLE (T_SubReg SubLow64 RegVec128) (T_SubReg SubEven64 RegVec256))
   (TLE (T_Mem Mem64) (T_Mem Mem256))
   ) RM

-- | low bytes of a vector or memory
mveclow :: AccessMode -> OperandSpec
mveclow m = op m (TME 
   (TLE (T_SubReg SubLow64 RegVec128) (T_Reg RegVec128))
   (TLE (T_Mem Mem64) (T_Mem Mem128))) RM

-- | 128-bit or 256-bit memory depending on Vex.L
m128o256 :: AccessMode -> OperandSpec
m128o256 m = op m (TLE (T_Mem Mem128) (T_Mem Mem256)) RM

-- | 256-bit vector
vec256 :: AccessMode -> OperandEnc -> OperandSpec
vec256 m e = op m (T_Reg RegVec256) e

-- | 128-bit vector
vec128 :: AccessMode -> OperandEnc -> OperandSpec
vec128 m e = op m (T_Reg RegVec128) e

-- | 64-bit vector
vec64 :: AccessMode -> OperandEnc -> OperandSpec
vec64 m e = op m (T_Reg RegVec64) e

-- | Low 64-bit of 128-bit vector
vec128low64 :: AccessMode -> OperandEnc -> OperandSpec
vec128low64 m e = op m (T_SubReg SubLow64 RegVec128) e

-- | High 64-bit of 128-bit vector
vec128high64 :: AccessMode -> OperandEnc -> OperandSpec
vec128high64 m e = op m (T_SubReg SubHigh64 RegVec128) e

-- | Low 32-bit of 128-bit vector
vec128low32 :: AccessMode -> OperandEnc -> OperandSpec
vec128low32 m e = op m (T_SubReg SubLow32 RegVec128) e

-- | 128-bit or 256-bit vector depending on Vex.L
vec128o256 :: AccessMode -> OperandEnc -> OperandSpec
vec128o256 m e = op m (TLE (T_Reg RegVec128) (T_Reg RegVec256)) e

-- | 32-bit or 64-bit general purpose register (depending on Rex.W)
reg32o64 :: AccessMode -> OperandEnc -> OperandSpec
reg32o64 m e = op m (TWE (T_Reg Reg32) (T_Reg Reg64)) e

-- | 32-bit or 64-bit general purpose register (depending on Rex.W) or memory
rm32o64 :: AccessMode -> OperandSpec
rm32o64 m = op m (TME
   (TWE (T_Reg Reg32) (T_Reg Reg64))
   (TWE (T_Mem Mem32) (T_Mem Mem64)))
   RM

-- | 16-bit general purpose register
reg16 :: AccessMode -> OperandEnc -> OperandSpec
reg16 m e = op m (T_Reg Reg16) e

-- | 8-bit memory
mem8 :: AccessMode -> OperandSpec
mem8 m = op m (T_Mem Mem8) RM

-- | 16-bit memory
mem16 :: AccessMode -> OperandSpec
mem16 m = op m (T_Mem Mem16) RM

-- | 8-bit general purpose register or memory
rm8 :: AccessMode -> OperandSpec
rm8 m = op m (TME (T_Reg Reg8) (T_Mem Mem8)) RM

-- | 16-bit general purpose register or memory
rm16 :: AccessMode -> OperandSpec
rm16 m = op m (TME (T_Reg Reg16) (T_Mem Mem16)) RM

-- | 32-bit memory
mem32 :: AccessMode -> OperandSpec
mem32 m = op m (T_Mem Mem32) RM

-- | 512-bit memory
mem512 :: AccessMode -> OperandSpec
mem512 m = op m (T_Mem Mem512) RM

-- | 32-bit general purpose register or memory
rm32 :: AccessMode -> OperandSpec
rm32 m = op m (TME (T_Reg Reg32) (T_Mem Mem32)) RM

-- | 64-bit general purpose register or memory
rm64 :: AccessMode -> OperandSpec
rm64 m = op m (TME (T_Reg Reg64) (T_Mem Mem64)) RM

-- | 128-bit or 256-bit memory (depending on Rex.W)
mem128o256 :: AccessMode -> OperandSpec
mem128o256 m = op m (TWE (T_Mem Mem128) (T_Mem Mem256)) RM

-- | 64-bit or 128-bit memory (depending on Rex.W)
mem64o128 :: AccessMode -> OperandSpec
mem64o128 m = op m (TWE (T_Mem Mem64) (T_Mem Mem128)) RM

-- | 32-bit or 64-bit memory (depending on Rex.W)
mem32o64 :: AccessMode -> OperandSpec
mem32o64 m = op m (TWE (T_Mem Mem32) (T_Mem Mem64)) RM

-- | General purpose register with the operand-size
gpr :: AccessMode -> OperandEnc -> OperandSpec
gpr m e = op m (T_Reg RegOpSize) e

-- | General purpose register with the operand-size or memory
mgpr :: AccessMode -> OperandSpec
mgpr m = op m (TME (T_Reg RegOpSize) (T_Mem MemOpSize)) RM

-- | Memory with the operand-size
mem :: AccessMode -> OperandSpec
mem m = op m (T_Mem MemOpSize) RM

-- | Any memory address (the pointed type doesn't matter)
mvoid :: OperandSpec
mvoid = op NA (T_Mem MemVoid) RM

-- | Fixed register
reg :: Register -> AccessMode -> OperandEnc -> OperandSpec
reg r m e = op m (T_Reg (RegFixed r)) e

-- | EAX or RAX
rAX :: AccessMode -> OperandSpec
rAX m = op m (TWE (T_Reg (RegFixed R_EAX)) (T_Reg (RegFixed R_RAX))) Implicit

-- | ECX or RCX
rCX :: AccessMode -> OperandSpec
rCX m = op m (TWE (T_Reg (RegFixed R_ECX)) (T_Reg (RegFixed R_RCX))) Implicit

-- | EDX or RDX
rDX :: AccessMode -> OperandSpec
rDX m = op m (TWE (T_Reg (RegFixed R_EDX)) (T_Reg (RegFixed R_RDX))) Implicit

-- | EDX:EAX or RDX:RAX pair
rDXrAX :: AccessMode -> OperandSpec
rDXrAX m = op m (TWE
   (T_Pair (T_Reg (RegFixed R_EDX)) (T_Reg (RegFixed R_EAX)))
   (T_Pair (T_Reg (RegFixed R_RDX)) (T_Reg (RegFixed R_RAX))))
   Implicit

-- | EDX:EAX
eDXeAX :: AccessMode -> OperandSpec
eDXeAX m = op m (T_Pair (T_Reg (RegFixed R_EDX)) (T_Reg (RegFixed R_EAX))) Implicit

-- | XMM0
xmm0 :: AccessMode -> OperandSpec
xmm0 m = op m (T_Reg (RegFixed (R_XMM 0))) Implicit

-- | ECX:EBX or RCX:RBX pair
rCXrBX :: AccessMode -> OperandSpec
rCXrBX m = op m (TWE
   (T_Pair (T_Reg (RegFixed R_ECX)) (T_Reg (RegFixed R_EBX)))
   (T_Pair (T_Reg (RegFixed R_RCX)) (T_Reg (RegFixed R_RBX))))
   Implicit

-- | 8-bit relative offset
rel8 :: OperandSpec
rel8 = op RO (T_Rel Rel8) Imm

-- | 16-bit or 32-bit relative offset (16-bit invalid in 64-bit mode)
rel16o32 :: OperandSpec
rel16o32 = op RO (T_Rel Rel16o32) Imm

-- | Immediate pointer: 16:16 or 16:32
ptr16x :: OperandSpec
ptr16x = op RO (T_Pair (T_Imm ImmSize16) (T_Imm ImmSizeOp)) Imm

-- | Immediate couple for ENTER: 16:8
stackFrame :: OperandSpec
stackFrame = op RO (T_Pair (T_Imm ImmSize16) (T_Imm ImmSize8)) Imm

-- | Implicit immediate constant
constImm :: Int -> OperandSpec
constImm x = op RO (T_Imm (ImmConst x)) Implicit

-- | Address of a pointer
m16x :: OperandSpec
m16x = op RO (T_Mem MemPtr) RM

-- | x87 register (there are all in RM)
st :: AccessMode -> OperandSpec
st m = op m (T_Reg RegST) RM

-- | real memory or x87 register
mst :: AccessMode -> OperandSpec
mst m = op m (TME (T_Reg RegST) (T_Mem MemFP)) RM

-- | x87 int memory
mint :: AccessMode -> OperandSpec
mint m = op m (T_Mem MemInt) RM

-- | x87 int64 memory
mint64 :: AccessMode -> OperandSpec
mint64 m = op m (T_Mem MemInt64) RM

-- | x87 m80real memory
mfp80 :: AccessMode -> OperandSpec
mfp80 m = op m (T_Mem MemFP80) RM

-- | x87 m80dec memory
mdec80 :: AccessMode -> OperandSpec
mdec80 m = op m (T_Mem MemDec80) RM

-- | x87 14/28 env memory
menv :: AccessMode -> OperandSpec
menv m = op m (T_Mem MemEnv) RM

-- | x87 14/28 state memory
mFPUstate :: AccessMode -> OperandSpec
mFPUstate m = op m (T_Mem MemFPUState) RM

-- | Processor extended state
mstate :: AccessMode -> OperandSpec
mstate m = op m (T_Mem MemState) RM

-- | descriptor table memory
mdt :: AccessMode -> OperandSpec
mdt m = op m (T_Mem MemDescTable) RM

-- | Counter register
regCounter :: AccessMode -> OperandSpec
regCounter m = op m (T_Reg RegCounter) Implicit

-- | Accumulator register
regAccu :: AccessMode -> OperandSpec
regAccu m = op m (T_Reg RegAccu) Implicit

-- | Stack pointer register
regStackPtr :: AccessMode -> OperandEnc -> OperandSpec
regStackPtr m e = op m (T_Reg RegStackPtr) e

-- | Base pointer register
regBasePtr :: AccessMode -> OperandEnc -> OperandSpec
regBasePtr m e = op m (T_Reg RegBasePtr) e

-- | Register family
regFam :: RegFamilies -> AccessMode -> OperandEnc -> OperandSpec
regFam x m e = op m (T_Reg (RegFam x)) e

-- | Memory at DS:rSI
mDSrSI :: AccessMode -> OperandSpec
mDSrSI m = op m (T_Mem MemDSrSI) Implicit

-- | Memory at ES:rDI
mESrDI :: AccessMode -> OperandSpec
mESrDI m = op m (T_Mem MemESrDI) Implicit

-- | Memory at DS:rDI (DS is overridable)
mDSrDI :: AccessMode -> OperandSpec
mDSrDI m = op m (T_Mem MemDSrDI) Implicit

-- | VSIB: 32-bit memory. 32-bit indices in 128-bit vector
m32vsib32x :: AccessMode -> OperandSpec
m32vsib32x m = op m (T_Mem (MemVSIB32 (VSIBType Size32 VSIB128))) RM

-- | VSIB: 32-bit memory. 32-bit indices in 128-bit or 256-bit vector
m32vsib32xy :: AccessMode -> OperandSpec
m32vsib32xy m = op m (TLE
   (T_Mem (MemVSIB32 (VSIBType Size32 VSIB128)))
   (T_Mem (MemVSIB32 (VSIBType Size32 VSIB256))))
   RM

-- | VSIB: 32-bit memory. 64-bit indices in 128-bit or 256-bit vector
m32vsib64xy :: AccessMode -> OperandSpec
m32vsib64xy m = op m (TLE
   (T_Mem (MemVSIB32 (VSIBType Size64 VSIB128)))
   (T_Mem (MemVSIB32 (VSIBType Size64 VSIB256))))
   RM

-- | VSIB: 64-bit memory. 32-bit indices in 128-bit vector
m64vsib32x :: AccessMode -> OperandSpec
m64vsib32x m = op m (T_Mem (MemVSIB64 (VSIBType Size32 VSIB128))) RM

-- | VSIB: 64-bit memory. 64-bit indices in 128-bit or 256-bit vector
m64vsib64xy :: AccessMode -> OperandSpec
m64vsib64xy m = op m (TLE
   (T_Mem (MemVSIB64 (VSIBType Size64 VSIB128)))
   (T_Mem (MemVSIB64 (VSIBType Size64 VSIB256))))
   RM

-- We use a dummy encoding for 3DNow: because all the instructions use the same
amd3DNowEncoding :: Encoding
amd3DNowEncoding = leg
   { legacyOpcodeMap = Map3DNow
   , legacyParams    = [ vec64 RW Reg
                       , mvec64 RO
                       ]
   }

isImmediate :: OperandEnc -> Bool
isImmediate = \case
   Imm    -> True
   Imm8h  -> True
   Imm8l  -> True
   _      -> False

hasImmediate :: Encoding -> Bool
hasImmediate e = any (isImmediate . opEnc) (encOperands e)

isLegacyEncoding :: Encoding -> Bool
isLegacyEncoding LegacyEncoding {} = True
isLegacyEncoding _                 = False

isVexEncoding :: Encoding -> Bool
isVexEncoding VexEncoding {} = True
isVexEncoding _              = False

encOpcode :: Encoding -> Word8
encOpcode e@LegacyEncoding {} = legacyOpcode e
encOpcode e@VexEncoding    {} = vexOpcode e

encOpcodeExt :: Encoding -> Maybe Word8
encOpcodeExt e@LegacyEncoding {} = legacyOpcodeExt e
encOpcodeExt e@VexEncoding    {} = vexOpcodeExt e

encOpcodeFullExt :: Encoding -> Maybe Word8
encOpcodeFullExt e@LegacyEncoding {} = legacyOpcodeFullExt e
encOpcodeFullExt VexEncoding    {}   = Nothing

encOpcodeMap :: Encoding -> OpcodeMap
encOpcodeMap e@LegacyEncoding {} = MapLegacy (legacyOpcodeMap e)
encOpcodeMap e@VexEncoding    {} = vexOpcodeMap e

encOperands :: Encoding -> [OperandSpec]
encOperands e@LegacyEncoding {}  = legacyParams e
encOperands e@VexEncoding    {}  = vexParams e

encMandatoryPrefix :: Encoding -> Maybe Word8
encMandatoryPrefix e@LegacyEncoding {} = legacyMandatoryPrefix e
encMandatoryPrefix e@VexEncoding    {} = vexMandatoryPrefix e

encProperties :: Encoding -> [EncodingProperties]
encProperties e@LegacyEncoding {} = legacyProperties e
encProperties e@VexEncoding    {} = vexProperties e

encParams :: Encoding -> [OperandSpec]
encParams e@LegacyEncoding {} = legacyParams e
encParams e@VexEncoding    {} = vexParams e

encNoForce8Bit :: Encoding -> Maybe Int
encNoForce8Bit e@LegacyEncoding {} = legacyNoForce8bit e
encNoForce8Bit _                   = Nothing

encSignExtendImmBit :: Encoding -> Maybe Int
encSignExtendImmBit e@LegacyEncoding {} = legacySignExtendable e
encSignExtendImmBit _                   = Nothing

encReversableBit :: Encoding -> Maybe Int
encReversableBit e@LegacyEncoding {} = legacyReversable e
encReversableBit e@VexEncoding {}    = vexReversable e

encFPUSizableBit :: Encoding -> Maybe Int
encFPUSizableBit e@LegacyEncoding {} = legacyFPUSizable e
encFPUSizableBit _                   = Nothing

encFPUDestBit :: Encoding -> Maybe Int
encFPUDestBit e@LegacyEncoding {} = legacyFPUDest e
encFPUDestBit _                   = Nothing

encFPUPopBit :: Encoding -> Maybe Int
encFPUPopBit e@LegacyEncoding {} = legacyFPUPop e
encFPUPopBit _                   = Nothing

-- | Indicate if LOCK prefix is allowed
encLockable :: Encoding -> Bool
encLockable e = Lockable     `elem` encProperties e
             || ImplicitLock `elem` encProperties e

-- | Indicate if branch hint prefixes are allowed
encBranchHintable :: Encoding -> Bool
encBranchHintable e = BranchHintable `elem` encProperties e

-- | Indicate if REPEAT prefix is allowed
encRepeatable :: Encoding -> Bool
encRepeatable e = Repeatable `elem` encProperties e

encRequireModRM :: Encoding -> Bool
encRequireModRM e = hasOpExt || hasOps
   where
      -- use opcode extension in ModRM.reg 
      hasOpExt = isJust (encOpcodeExt e) || isJust (encOpcodeFullExt e)

      -- has operands in ModRM
      hasOps   = any matchEnc (encOperands e)
      matchEnc x = case opEnc x of
         RM         -> True
         Reg        -> True
         Imm        -> False
         Imm8h      -> False
         Imm8l      -> False
         Implicit   -> False
         Vvvv       -> False
         OpcodeLow3 -> False

data ValidMode
   = ModeOnlyReg
   | ModeOnlyMem
   | ModeBoth
   | ModeNone
   deriving (Show,Eq)

-- | ModRM.mod only supports the given value
encValidModRMMode :: Encoding -> ValidMode
encValidModRMMode e = case ots of
      []  -> ModeNone
      [x] -> toM x
      _   -> error ("encValidModRMMode: more than one ModRM.rm param: " ++ show ots)
   where
      toM = \case
         T_Mem _     -> ModeOnlyMem
         T_SubReg {} -> ModeOnlyReg
         T_Reg _     -> ModeOnlyReg
         TME _ _     -> ModeBoth
         TLE x y     -> if toM x == toM y
                           then toM x
                           else ModeBoth
         x           -> error ("encValidModRMMode: invalid param type: " ++ show x)
      ots = opType <$> filter ((== RM) . opEnc) (encOperands e)

-- | Indicate if a memory operand may be encoded
encMayHaveMemoryOperand :: Encoding -> Bool
encMayHaveMemoryOperand e = case encValidModRMMode e of
   ModeNone    -> False
   ModeOnlyReg -> False
   ModeOnlyMem -> True
   ModeBoth    -> True

-- | Test if an encoding support the given Hardware-Lock Ellision prefix
encHasHLE :: HLEAction -> Encoding -> Bool
encHasHLE a e = case filter isHLE (encProperties e) of
      []       -> False
      [HLE a'] -> a' == XBoth || a == a'
      xs       -> error ("Invalid HLE actions: "++show xs)
   where
      isHLE (HLE _) = True
      isHLE _       = False


-------------------------------------------------------------------
-- Instructions
-------------------------------------------------------------------

instructions :: [X86Insn]
instructions =
   [ i_aaa
   , i_aad 
   , i_aam 
   , i_aas 
   , i_adc 
   , i_adcx 
   , i_add 
   , i_addpd 
   , i_vaddpd 
   , i_addps 
   , i_vaddps 
   , i_addsd 
   , i_vaddsd 
   , i_addss 
   , i_vaddss 
   , i_addsubpd 
   , i_vaddsubpd 
   , i_addsubps 
   , i_vaddsubps 
   , i_adox 
   , i_aesdec 
   , i_vaesdec 
   , i_aesdeclast 
   , i_vaesdeclast 
   , i_aesenc 
   , i_vaesenc 
   , i_aesenclast 
   , i_vaesenclast 
   , i_aesimc 
   , i_vaesimc 
   , i_aeskeygenassist 
   , i_vaeskeygenassist 
   , i_and 
   , i_andn 
   , i_andpd 
   , i_vandpd 
   , i_andps 
   , i_vandps 
   , i_andnpd 
   , i_vandnpd 
   , i_andnps 
   , i_vandnps 
   , i_arpl 
   , i_blendpd 
   , i_vblendpd 
   , i_bextr 
   , i_blendps 
   , i_vblendps 
   , i_blendvpd 
   , i_vblendvpd 
   , i_blendvps 
   , i_vblendvps 
   , i_blsi 
   , i_blsmsk 
   , i_blsr 
   , i_bound 
   , i_bsf 
   , i_bsr 
   , i_bswap 
   , i_bt 
   , i_btc 
   , i_btr 
   , i_bts 
   , i_bzhi 
   , i_call 
   , i_extend_signed 
   , i_clac
   , i_clc
   , i_cld
   , i_clflush
   , i_cli
   , i_clts
   , i_cmc
   , i_cmovo
   , i_cmovno
   , i_cmovc
   , i_cmovnc
   , i_cmovz
   , i_cmovnz
   , i_cmovbe
   , i_cmova
   , i_cmovs
   , i_cmovns
   , i_cmovp
   , i_cmovnp
   , i_cmovl
   , i_cmovge
   , i_cmovle
   , i_cmovg
   , i_cmp 
   , i_cmppd 
   , i_vcmppd 
   , i_cmpps 
   , i_vcmpps 
   , i_cmps 
   , i_cmpsd 
   , i_vcmpsd 
   , i_cmpss 
   , i_vcmpss 
   , i_cmpxchg 
   , i_cmpxch8b 
   , i_comisd 
   , i_comiss 
   , i_cpuid 
   , i_crc32 
   , i_cvtdq2pd 
   , i_vcvtdq2pd 
   , i_cvtdq2ps 
   , i_vcvtdq2ps 
   , i_cvtpd2dq 
   , i_vcvtpd2dq 
   , i_cvtpd2di 
   , i_cvtpd2ps 
   , i_vcvtpd2ps 
   , i_cvtpi2pd 
   , i_cvtpi2ps 
   , i_cvtps2dq 
   , i_vcvtps2dq 
   , i_cvtps2pd 
   , i_vcvtps2pd 
   , i_cvtps2pi 
   , i_cvtsd2si 
   , i_vcvtsd2si 
   , i_cvtsd2ss 
   , i_vcvtsd2ss 
   , i_cvtsi2sd 
   , i_vcvtsi2sd 
   , i_cvtsi2ss 
   , i_vcvtsi2ss 
   , i_cvtss2sd 
   , i_vcvtss2sd 
   , i_cvtss2si 
   , i_vcvtss2si 
   , i_cvttpd2dq 
   , i_vcvttpd2dq 
   , i_cvttpd2pi 
   , i_cvttps2dq 
   , i_vcvttps2dq 
   , i_cvttps2pi 
   , i_cvttsd2si 
   , i_vcvttsd2si 
   , i_cvttss2si 
   , i_vcvttss2si 
   , i_cwd 
   , i_daa 
   , i_das 
   , i_dec 
   , i_div 
   , i_divpd 
   , i_vdivpd 
   , i_divps 
   , i_vdivps 
   , i_divsd 
   , i_vdivsd 
   , i_divss 
   , i_vdivss 
   , i_dppd 
   , i_vdppd 
   , i_dpps 
   , i_vdpps 
   , i_emms 
   , i_enter 
   , i_extractps 
   , i_vextractps 
   , i_f2xm1
   , i_fabs
   , i_fadd
   , i_fiadd
   , i_fbld
   , i_fbstp
   , i_fchs
   , i_fnclex
   , i_fcmovb
   , i_fcmove
   , i_fcmovbe
   , i_fcmovu
   , i_fcmovnb
   , i_fcmovne
   , i_fcmovnbe
   , i_fcmovnu
   , i_fcom
   , i_fcomp
   , i_fcompp
   , i_fcomi
   , i_fucomi
   , i_fcos
   , i_fdecstp
   , i_fdiv
   , i_fidiv
   , i_fdivr
   , i_fidivr
   , i_ffree
   , i_ficom
   , i_ficomp
   , i_fild
   , i_fincstp
   , i_finit
   , i_fist
   , i_fistp
   , i_fisttp
   , i_fld
   , i_fld1
   , i_fldl2t
   , i_fldl2e
   , i_fldpi
   , i_fldlg2
   , i_fldln2
   , i_fldz
   , i_fldcw
   , i_fldenv
   , i_fmul
   , i_fimul
   , i_fnop
   , i_fpatan
   , i_fprem
   , i_fprem1
   , i_fptan
   , i_frndint
   , i_frstor
   , i_fnsave
   , i_fscale
   , i_fsin
   , i_fsincos
   , i_fsqrt
   , i_fst
   , i_fstp
   , i_fnstcw
   , i_fnstenv
   , i_fnstsw
   , i_fsub
   , i_fisub
   , i_fsubr
   , i_fisubr
   , i_ftst
   , i_fucom
   , i_fucomp
   , i_fucompp
   , i_fxam
   , i_fxch
   , i_fxrstor
   , i_fxrstor64
   , i_fxsave
   , i_fxsave64
   , i_fxtract
   , i_fyl2x
   , i_fyl2xp1
   , i_haddpd
   , i_vhaddpd
   , i_haddps
   , i_vhaddps
   , i_hlt
   , i_hsubpd
   , i_vhsubpd
   , i_hsubps
   , i_vhsubps
   , i_idiv
   , i_imul
   , i_in
   , i_inc
   , i_ins
   , i_insertps
   , i_vinsertps
   , i_int
   , i_into
   , i_invd
   , i_invlpg
   , i_invpcid
   , i_iret
   , i_ja
   , i_jae
   , i_jb
   , i_jbe
   , i_jcxz
   , i_je
   , i_jg
   , i_jge
   , i_jl
   , i_jle
   , i_jne
   , i_jno
   , i_jnp
   , i_jns
   , i_jo
   , i_jp
   , i_js
   , i_jmp
   , i_lahf
   , i_lar
   , i_lddqu
   , i_vlddqu
   , i_ldmxcsr
   , i_ldfarptr
   , i_lea
   , i_leave
   , i_lfence
   , i_lgdt
   , i_lidt
   , i_lldt
   , i_lmsw
   , i_lods
   , i_loop
   , i_loope
   , i_loopne
   , i_lsl
   , i_ltr
   , i_maskmovdqu
   , i_vmaskmovdqu
   , i_maskmovq
   , i_maxpd
   , i_vmaxpd
   , i_maxps
   , i_vmaxps
   , i_maxsd
   , i_vmaxsd
   , i_maxss
   , i_vmaxss
   , i_mfence
   , i_minpd
   , i_vminpd
   , i_minps
   , i_vminps
   , i_minsd
   , i_vminsd
   , i_minss
   , i_vminss
   , i_monitor
   , i_mov
   , i_movcr
   , i_movdr
   , i_movapd
   , i_vmovapd
   , i_movaps
   , i_vmovaps
   , i_movbe
   , i_movdq
   , i_movddup
   , i_movdqa
   , i_movdqu
   , i_movdq2q
   , i_movhlps
   , i_vmovhlps
   , i_movhpd
   , i_vmovhpd
   , i_movhps
   , i_vmovhps
   , i_movlhps
   , i_vmovlhps
   , i_movlpd
   , i_vmovlpd
   , i_movlps
   , i_vmovlps
   , i_movmskpd
   , i_vmovmskpd
   , i_movmskps
   , i_vmovmskps
   , i_movntdqa
   , i_movntdq
   , i_movnti
   , i_movntpd
   , i_movntps
   , i_movntq
   , i_movq
   , i_movq2dq
   , i_movs
   , i_movsd
   , i_vmovsd
   , i_movshdup
   , i_movsldup
   , i_movss
   , i_vmovss
   , i_movsx
   , i_movupd
   , i_vmovupd
   , i_movups
   , i_vmovups
   , i_movzx
   , i_mpsadbw
   , i_mul
   , i_mulpd
   , i_vmulpd
   , i_mulps
   , i_vmulps
   , i_mulsd
   , i_vmulsd
   , i_mulss
   , i_vmulss
   , i_mulx
   , i_mwait
   , i_neg
   , i_nop
   , i_not
   , i_or
   , i_orpd
   , i_vorpd
   , i_orps
   , i_vorps
   , i_out
   , i_outs
   , i_pabsb
   , i_pabsw
   , i_pabsd
   , i_packsswb
   , i_packssdw
   , i_packusdw
   , i_packuswb
   , i_paddb
   , i_paddw
   , i_paddd
   , i_paddq
   , i_paddsb
   , i_paddsw
   , i_paddusb
   , i_paddusw
   , i_palignr
   , i_pand
   , i_pandn
   , i_pause
   , i_pavgb
   , i_pavgw
   , i_pblendvb
   , i_pblendw
   , i_pclmulqdq
   , i_pcmpeqb
   , i_pcmpeqw
   , i_pcmpeqd
   , i_pcmpeqq
   , i_pcmpestri
   , i_pcmpestrm
   , i_pcmpgtb
   , i_pcmpgtw
   , i_pcmpgtd
   , i_pcmpgtq
   , i_pcmpistri
   , i_pcmpistrm
   , i_pdep
   , i_pext
   , i_pextrb
   , i_pextrd
   , i_pextrw
   , i_phaddw
   , i_phaddd
   , i_phaddsw
   , i_phminposuw
   , i_phsubw
   , i_phsubd
   , i_phsubsw
   , i_pinsrb
   , i_pinsrd
   , i_pinsrw
   , i_pmaddubsw
   , i_pmaddwd
   , i_pmaxsb
   , i_pmaxsd
   , i_pmaxsw
   , i_pmaxub
   , i_pmaxud
   , i_pmaxuw
   , i_pminsb
   , i_pminsd
   , i_pminsw
   , i_pminub
   , i_pminud
   , i_pminuw
   , i_pmovmskb
   , i_pmovsxbw
   , i_pmovsxbd
   , i_pmovsxbq
   , i_pmovsxwd
   , i_pmovsxwq
   , i_pmovsxdq
   , i_pmovzxbw
   , i_pmovzxbd
   , i_pmovzxbq
   , i_pmovzxwd
   , i_pmovzxwq
   , i_pmovzxdq
   , i_pmuldq
   , i_pmulhrsw
   , i_pmulhuw
   , i_pmulhw
   , i_pmulld
   , i_pmullw
   , i_pmuludq
   , i_pop
   , i_popa
   , i_popcnt
   , i_popf
   , i_por
   , i_prefetcht0
   , i_prefetcht1
   , i_prefetcht2
   , i_prefetchnta
   , i_prefetchw
   , i_prefetchwt1
   , i_psadbw
   , i_pshufb
   , i_pshufd
   , i_pshufhw
   , i_pshuflw
   , i_pshufw
   , i_psignb
   , i_psignw
   , i_psignd
   , i_pslldq
   , i_psllw
   , i_pslld
   , i_psllq
   , i_psraw
   , i_psrad
   , i_psrldq
   , i_psrlw
   , i_psrld
   , i_psrlq
   , i_psubb
   , i_psubw
   , i_psubd
   , i_psubq
   , i_psubsb
   , i_psubsw
   , i_psubusb
   , i_psubusw
   , i_ptest
   , i_punpckhbw
   , i_punpckhwd
   , i_punpckhdq
   , i_punpckhqdq
   , i_punpcklbw
   , i_punpcklwd
   , i_punpckldq
   , i_punpcklqdq
   , i_push
   , i_pusha
   , i_pushf
   , i_pxor
   , i_rcl
   , i_rcr
   , i_rol
   , i_ror
   , i_rcpps
   , i_rcpss
   , i_rdfsbase
   , i_rdgsbase
   , i_rdmsr
   , i_rdpkru
   , i_rdpmc
   , i_rdrand
   , i_rdseed
   , i_rdtsc
   , i_rdtscp
   , i_ret
   , i_retfar
   , i_rorx
   , i_roundpd
   , i_roundps
   , i_roundsd
   , i_roundss
   , i_rsm
   , i_rsqrtps
   , i_rsqrtss
   , i_sahf
   , i_shl
   , i_sar
   , i_shr
   , i_sarx
   , i_shlx
   , i_shrx
   , i_sbb
   , i_scas
   , i_seta
   , i_setae
   , i_setb
   , i_setbe
   , i_sete
   , i_setg
   , i_setge
   , i_setl
   , i_setle
   , i_setne
   , i_setno
   , i_setnp
   , i_setns
   , i_seto
   , i_setp
   , i_sets
   , i_sfence
   , i_sgdt
   , i_shld
   , i_shrd
   , i_shufpd
   , i_vshufpd
   , i_shufps
   , i_vshufps
   , i_sidt
   , i_sldt
   , i_smsw
   , i_sqrtpd
   , i_sqrtps
   , i_sqrtsd
   , i_sqrtss
   , i_stac
   , i_stc
   , i_std
   , i_sti
   , i_stmxcsr
   , i_stos
   , i_str
   , i_sub
   , i_subpd 
   , i_vsubpd 
   , i_subps 
   , i_vsubps 
   , i_subsd 
   , i_vsubsd 
   , i_subss 
   , i_vsubss 
   , i_swapgs
   , i_syscall
   , i_sysenter
   , i_sysexit
   , i_sysret
   , i_test
   , i_tzcnt
   , i_ucomisd 
   , i_ucomiss 
   , i_ud2
   , i_unpckhpd
   , i_unpckhps
   , i_unpcklpd
   , i_unpcklps
   , i_vbroadcastss
   , i_vbroadcastsd
   , i_vbroadcastf128
   , i_vcvtph2ps
   , i_vcvtps2ph
   , i_verr
   , i_verw
   , i_vextractf128
   , i_vextracti128
   , i_vfmadd132pd
   , i_vfmadd213pd
   , i_vfmadd231pd
   , i_vfmadd132ps
   , i_vfmadd213ps
   , i_vfmadd231ps
   , i_vfmadd132sd
   , i_vfmadd213sd
   , i_vfmadd231sd
   , i_vfmadd132ss
   , i_vfmadd213ss
   , i_vfmadd231ss
   , i_vfmaddsub132pd
   , i_vfmaddsub213pd
   , i_vfmaddsub231pd
   , i_vfmaddsub132ps
   , i_vfmaddsub213ps
   , i_vfmaddsub231ps
   , i_vfmsubadd132pd
   , i_vfmsubadd213pd
   , i_vfmsubadd231pd
   , i_vfmsubadd132ps
   , i_vfmsubadd213ps
   , i_vfmsubadd231ps
   , i_vfmsub132pd
   , i_vfmsub213pd
   , i_vfmsub231pd
   , i_vfmsub132ps
   , i_vfmsub213ps
   , i_vfmsub231ps
   , i_vfmsub132sd
   , i_vfmsub213sd
   , i_vfmsub231sd
   , i_vfmsub132ss
   , i_vfmsub213ss
   , i_vfmsub231ss
   , i_vfnmadd132pd
   , i_vfnmadd213pd
   , i_vfnmadd231pd
   , i_vfnmadd132ps
   , i_vfnmadd213ps
   , i_vfnmadd231ps
   , i_vfnmadd132sd
   , i_vfnmadd213sd
   , i_vfnmadd231sd
   , i_vfnmadd132ss
   , i_vfnmadd213ss
   , i_vfnmadd231ss
   , i_vfnmsub132pd
   , i_vfnmsub213pd
   , i_vfnmsub231pd
   , i_vfnmsub132ps
   , i_vfnmsub213ps
   , i_vfnmsub231ps
   , i_vfnmsub132sd
   , i_vfnmsub213sd
   , i_vfnmsub231sd
   , i_vfnmsub132ss
   , i_vfnmsub213ss
   , i_vfnmsub231ss
   , i_vgatherdpd
   , i_vgatherqpd
   , i_vgatherdps
   , i_vgatherqps
   , i_vpgatherdd
   , i_vpgatherqd
   , i_vpgatherdq
   , i_vpgatherqq
   , i_vinsertf128
   , i_vinserti128
   , i_vmaskmovps
   , i_vmaskmovpd
   , i_vblendd
   , i_vpbroadcastb
   , i_vpbroadcastw
   , i_vpbroadcastd
   , i_vpbroadcastq
   , i_vpbroadcasti128
   , i_vpermd
   , i_vpermpd
   , i_vpermps
   , i_vpermq
   , i_vperm2i128
   , i_vpermilpd
   , i_vpermilps
   , i_vperm2f128
   , i_vpmaskmovd
   , i_vpmaskmovq
   , i_vpsllvd
   , i_vpsllvq
   , i_vpsravd
   , i_vpsrlvd
   , i_vpsrlvq
   , i_vtestpd
   , i_vtestps
   , i_vzeroall
   , i_vzeroupper
   , i_fwait
   , i_wbinvd
   , i_wrfsbase
   , i_wrgsbase
   , i_wrmsr
   , i_wrpkru
   , i_xabort
   , i_xadd
   , i_xbegin
   , i_xchg
   , i_xend
   , i_xgetbv
   , i_xlat
   , i_xor
   , i_xorpd
   , i_vxorpd
   , i_xorps
   , i_vxorps
   , i_xrstor
   , i_xrstors
   , i_xsave
   , i_xsavec
   , i_xsaveopt
   , i_xsaves
   , i_xsetbv
   , i_xtest
   ]

i_aaa :: X86Insn
i_aaa = insn
   { insnDesc        = "ASCII adjust AL after addition"
   , insnMnemonic    = "AAA"
   , insnFlags       = [ Modified  [AF,CF]
                       , Undefined [OF,SF,ZF,PF]
                       ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x37
                           , legacyProperties      = [LegacyModeSupport]
                           , legacyParams          = [ reg R_AX RW Implicit ]
                           }
                        ]
   }

i_aad :: X86Insn
i_aad = insn
   { insnDesc        = "ASCII adjust AX before division"
   , insnMnemonic    = "AAD"
   , insnFlags       = [ Modified  [SF,ZF,PF]
                       , Undefined [OF,AF,CF]
                       ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xD5
                           , legacyProperties      = [LegacyModeSupport]
                           , legacyParams          = [ reg R_AX RW Implicit
                                                     , imm8
                                                     ]
                           }
                        ]
   }

i_aam :: X86Insn
i_aam = insn
   { insnDesc        = "ASCII adjust AX after multiply"
   , insnMnemonic    = "AAM"
   , insnProperties  = [FailOnZero 0]
   , insnFlags       = [ Modified  [SF,ZF,PF]
                       , Undefined [OF,AF,CF]
                       ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xD4
                           , legacyProperties      = [LegacyModeSupport]
                           , legacyParams          = [ reg R_AX RW Implicit
                                                     , imm8
                                                     ]
                           }
                        ]
   }


i_aas :: X86Insn
i_aas = insn
   { insnDesc        = "ASCII adjust AL after subtraction"
   , insnMnemonic    = "AAS"
   , insnFlags       = [ Modified  [AF,CF]
                       , Undefined [OF,SF,ZF,PF]
                       ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x3F
                           , legacyProperties      = [LegacyModeSupport]
                           , legacyParams          = [ reg R_AX RW Implicit ]
                           }
                       ]
   }

i_adc :: X86Insn
i_adc = insn
   { insnDesc        = "Add with carry"
   , insnMnemonic    = "ADC"
   , insnFlags       = [ Read     [CF]
                       , Modified [OF,SF,ZF,AF,CF,PF]
                       ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x14
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ regAccu RW
                                                     , immSE 
                                                     ]
                           }
                        , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x10
                           , legacyNoForce8bit     = Just 0
                           , legacyReversable      = Just 1
                           , legacyProperties      = [ Lockable
                                                     , LegacyModeSupport
                                                     , LongModeSupport
                                                     , HLE XBoth
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , gpr RO Reg
                                                     ]
                           }
                        , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x80
                           , legacyOpcodeExt       = Just 2
                           , legacyNoForce8bit     = Just 0
                           , legacySignExtendable  = Just 1
                           , legacyProperties      = [ Lockable
                                                     , LegacyModeSupport
                                                     , LongModeSupport
                                                     , HLE XBoth
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , immSE
                                                     ]
                           }
                        ]
   }

i_adcx :: X86Insn
i_adcx = insn
   { insnDesc        = "Unsigned integer addition with carry flags"
   , insnMnemonic    = "ADCX"
   , insnFlags       = [ Read     [CF]
                       , Modified [CF]
                       ]
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0xF6
                           , legacyProperties      = [Extension ADX]
                           , legacyParams          = [ reg32o64 RW Reg
                                                     , rm32o64 RO
                                                     ]
                           }
                        ]
   }

i_add :: X86Insn
i_add = insn
   { insnDesc        = "Add"
   , insnMnemonic    = "ADD"
   , insnFlags       = [Modified [OF,SF,ZF,AF,CF,PF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x04
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ regAccu RW
                                                     , immSE
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x00
                           , legacyNoForce8bit     = Just 0
                           , legacyReversable      = Just 1
                           , legacyProperties      = [ Lockable
                                                     , LegacyModeSupport
                                                     , LongModeSupport
                                                     , HLE XBoth
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , gpr RO Reg
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x80
                           , legacyOpcodeExt       = Just 0
                           , legacyNoForce8bit     = Just 0
                           , legacySignExtendable  = Just 1
                           , legacyProperties      = [ Lockable
                                                     , LegacyModeSupport
                                                     , LongModeSupport
                                                     , HLE XBoth
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , immSE
                                                     ]
                           }
                       ]
   }

i_addpd :: X86Insn
i_addpd = insn
   { insnDesc        = "Add packed double-precision floating-point values"
   , insnMnemonic    = "ADDPD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x58
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vaddpd :: X86Insn
i_vaddpd = insn
   { insnDesc        = "Add packed double-precision floating-point values"
   , insnMnemonic    = "VADDPD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x58
                           , vexLW                 = WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128o256 WO Reg
                                                     , vec128o256 RO Vvvv
                                                     , mvec128o256 RO
                                                     ]
                           }
                       ]
   }

i_addps :: X86Insn
i_addps = insn
   { insnDesc        = "Add packed single-precision floating-point values"
   , insnMnemonic    = "ADDPS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x58
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ vec128  RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vaddps :: X86Insn
i_vaddps = insn
   { insnDesc        = "Add packed single-precision floating-point values"
   , insnMnemonic    = "VADDPS"
   , insnEncodings   = [ vex
                           { vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x58
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }

i_addsd :: X86Insn
i_addsd = insn
   { insnDesc        = "Add scalar double-precision floating-point values"
   , insnMnemonic    = "ADDSD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF2
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x58
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128low64 RO
                                                     ]
                           }
                       ]
   }

i_vaddsd :: X86Insn
i_vaddsd = insn
   { insnDesc        = "Add scalar double-precision floating-point values"
   , insnMnemonic    = "VADDSD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0xF2
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x58
                           , vexLW              = LWIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128 WO Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low64 RO
                                                  ]
                           }
                       ]
   }

i_addss :: X86Insn
i_addss = insn
   { insnDesc        = "Add scalar single-precision floating-point values"
   , insnMnemonic    = "ADDSS"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF3
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x58
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128low32 RO
                                                     ]
                           }
                       ]
   }

i_vaddss :: X86Insn
i_vaddss = insn
   { insnDesc        = "Add scalar single-precision floating-point values"
   , insnMnemonic    = "VADDSS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0xF3
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x58
                           , vexLW              = LWIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128 WO Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low32 RO
                                                  ]
                           }
                       ]
   }

i_addsubpd :: X86Insn
i_addsubpd = insn
   { insnDesc        = "Packed double-FP add/subtract"
   , insnMnemonic    = "ADDSUBPD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xD0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE3
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vaddsubpd :: X86Insn
i_vaddsubpd = insn
   { insnDesc        = "Packed double-FP add/subtract"
   , insnMnemonic    = "VADDSUBPD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0xD0
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }

i_addsubps :: X86Insn
i_addsubps = insn
   { insnDesc        = "Packed single-FP add/subtract"
   , insnMnemonic    = "ADDSUBPS"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF2
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xD0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE3
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vaddsubps :: X86Insn
i_vaddsubps = insn
   { insnDesc        = "Packed single-FP add/subtract"
   , insnMnemonic    = "VADDSUBPS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix    = Just 0xF2
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xD0
                           , vexLW                 = WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128o256 WO Reg
                                                     , vec128o256 RO Vvvv
                                                     , mvec128o256 RO
                                                     ]
                           }
                       ]
   }

i_adox :: X86Insn
i_adox = insn
   { insnDesc        = "Unsigned integer addition of two operands with overflow flag"
   , insnMnemonic    = "ADOX"
   , insnFlags       = [ Read     [OF]
                       , Modified [OF]
                       ]
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF3
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0xF6
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension ADX
                                                     ]
                           , legacyParams          = [ reg32o64 RW Reg
                                                     , rm32o64 RO
                                                     ]
                           }
                       ]
   }

i_aesdec :: X86Insn
i_aesdec = insn
   { insnDesc        = "Perform one round of an AES decryption flow"
   , insnMnemonic    = "AESDEC"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0xDE
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AES
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vaesdec :: X86Insn
i_vaesdec = insn
   { insnDesc        = "Perform one round of an AES decryption flow"
   , insnMnemonic    = "VAESDEC"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xDE
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AES
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128 WO Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128 RO
                                                  ]
                           }
                       ]
   }

i_aesdeclast :: X86Insn
i_aesdeclast = insn
   { insnDesc        = "Perform last round of an AES decryption flow"
   , insnMnemonic    = "AESDECLAST"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0xDF
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AES
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vaesdeclast :: X86Insn
i_vaesdeclast = insn
   { insnDesc        = "Perform last round of an AES decryption flow"
   , insnMnemonic    = "VAESDECLAST"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xDF
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AES
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128 WO Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128 RO
                                                  ]
                           }
                       ]
   }

i_aesenc :: X86Insn
i_aesenc = insn
   { insnDesc        = "Perform one round of an AES encryption flow"
   , insnMnemonic    = "AESENC"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0xDC
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AES
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vaesenc :: X86Insn
i_vaesenc = insn
   { insnDesc        = "Perform one round of an AES encryption flow"
   , insnMnemonic    = "VAESENC"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xDC
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AES
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128 WO Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128 RO
                                                  ]
                           }
                       ]
   }

i_aesenclast :: X86Insn
i_aesenclast = insn
   { insnDesc        = "Perform last round of an AES encryption flow"
   , insnMnemonic    = "AESENCLAST"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0xDD
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AES
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vaesenclast :: X86Insn
i_vaesenclast = insn
   { insnDesc        = "Perform last round of an AES encryption flow"
   , insnMnemonic    = "VAESENCLAST"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xDD
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AES
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128 WO Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128 RO
                                                  ]
                           }
                       ]
   }

i_aesimc :: X86Insn
i_aesimc = insn
   { insnDesc        = "Perform the AES InvMixColumn transformation"
   , insnMnemonic    = "AESIMC"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0xDB
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AES
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vaesimc :: X86Insn
i_vaesimc = insn
   { insnDesc        = "Perform the AES InvMixColumn transformation"
   , insnMnemonic    = "VAESIMC"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xDB
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AES
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128 WO Reg
                                                  , mvec128 RO
                                                  ]
                           }
                       ]
   }

i_aeskeygenassist :: X86Insn
i_aeskeygenassist = insn
   { insnDesc        = "AES round key generation assist"
   , insnMnemonic    = "AESKEYGENASSIST"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F3A
                           , legacyOpcode          = 0xDF
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AES
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     , imm8
                                                     ]
                           }
                       ]
   }

i_vaeskeygenassist :: X86Insn
i_vaeskeygenassist = insn
   { insnDesc        = "AES round key generation assist"
   , insnMnemonic    = "VAESKEYGENASSIST"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x03
                           , vexOpcode          = 0xDF
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AES
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128 WO Reg
                                                  , mvec128 RO
                                                  , imm8
                                                  ]
                           }
                       ]
   }

i_and :: X86Insn
i_and = insn
   { insnDesc        = "Logical AND"
   , insnMnemonic    = "AND"
   , insnFlags       = [ Unset     [OF,CF]
                       , Modified  [SF,ZF,PF]
                       , Undefined [AF]
                       ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0x24
                           , legacyNoForce8bit  = Just 0
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ regAccu RW
                                                  , immSE
                                                  ]
                           }
                       , leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0x20
                           , legacyNoForce8bit  = Just 0
                           , legacyReversable   = Just 1
                           , legacyProperties   = [ Lockable
                                                  , LegacyModeSupport
                                                  , LongModeSupport
                                                  , HLE XBoth
                                                  ]
                           , legacyParams       = [ mgpr RW
                                                  , gpr RO Reg
                                                  ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x80
                           , legacyOpcodeExt       = Just 4
                           , legacyNoForce8bit     = Just 0
                           , legacySignExtendable  = Just 1
                           , legacyProperties      = [ Lockable
                                                     , LegacyModeSupport
                                                     , LongModeSupport
                                                     , HLE XBoth
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , immSE
                                                     ]
                           }
                       ]
   }

i_andn :: X86Insn
i_andn = insn
   { insnDesc        = "Logical AND NOT"
   , insnMnemonic    = "ANDN"
   , insnFlags       = [ Modified  [SF,ZF]
                       , Unset     [OF,CF]
                       , Undefined [AF,PF]
                       ]
   , insnEncodings   = [ vex
                           { vexOpcodeMap    = MapVex 0x02
                           , vexOpcode       = 0xF2
                           , vexLW           = L0
                           , vexProperties   = [ LegacyModeSupport
                                               , LongModeSupport
                                               , Extension BMI1
                                               ]
                           , vexParams       = [ reg32o64 WO Reg
                                               , reg32o64 RO Vvvv
                                               , rm32o64 RO
                                               ]
                           }
                       ]
   }

i_andpd :: X86Insn
i_andpd = insn
   { insnDesc        = "Bitwise logical AND of packed double-precision floating-point values"
   , insnMnemonic    = "ANDPD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x54
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vandpd :: X86Insn
i_vandpd = insn
   { insnDesc        = "Bitwise logical AND of packed double-precision floating-point values"
   , insnMnemonic    = "VANDPD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x54
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }

i_andps :: X86Insn
i_andps = insn
   { insnDesc        = "Bitwise logical AND of packed float-precision floating-point values"
   , insnMnemonic    = "ANDPS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0x54
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension SSE
                                                  ]
                           , legacyParams       = [ vec128 RW Reg
                                                  , mvec128 RO
                                                  ]
                           }
                       ]
   }

i_vandps :: X86Insn
i_vandps = insn
   { insnDesc        = "Bitwise logical AND of packed float-precision floating-point values"
   , insnMnemonic    = "VANDPS"
   , insnEncodings   = [ vex
                           { vexOpcodeMap    = MapVex 0x01
                           , vexOpcode       = 0x54
                           , vexLW           = WIG
                           , vexProperties   = [ LegacyModeSupport
                                               , LongModeSupport
                                               , Extension AVX
                                               ]
                           , vexParams       = [ vec128o256 WO Reg
                                               , vec128o256 RO Vvvv
                                               , mvec128o256 RO
                                               ]
                           }
                       ]
   }

i_andnpd :: X86Insn
i_andnpd = insn
   { insnDesc        = "Bitwise logical AND NOT of packed double-precision floating-point values"
   , insnMnemonic    = "ANDNPD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x55
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vandnpd :: X86Insn
i_vandnpd = insn
   { insnDesc        = "Bitwise logical AND NOT of packed double-precision floating-point values"
   , insnMnemonic    = "VANDNPD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x55
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }

i_andnps :: X86Insn
i_andnps = insn
   { insnDesc        = "Bitwise logical AND of packed float-precision floating-point values"
   , insnMnemonic    = "ANDNPS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0x55
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension SSE
                                                  ]
                           , legacyParams       = [ vec128 RW Reg
                                                  , mvec128 RO
                                                  ]
                           }
                       ]
   }

i_vandnps :: X86Insn
i_vandnps = insn
   { insnDesc        = "Bitwise logical AND of packed float-precision floating-point values"
   , insnMnemonic    = "VANDNPS"
   , insnEncodings   = [ vex
                           { vexOpcodeMap    = MapVex 0x01
                           , vexOpcode       = 0x55
                           , vexLW           = WIG
                           , vexProperties   = [ LegacyModeSupport
                                               , LongModeSupport
                                               , Extension AVX
                                               ]
                           , vexParams       = [ vec128o256 WO Reg
                                               , vec128o256 RO Vvvv
                                               , mvec128o256 RO
                                               ]
                           }
                       ]
   }

i_arpl :: X86Insn
i_arpl = insn
   { insnDesc        = "Adjust RPL field of segment selector"
   , insnMnemonic    = "ARPL"
   , insnFlags       = [Modified [ZF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0x63
                           , legacyProperties   = [LegacyModeSupport]
                           , legacyParams       = [ rm16 RW
                                                  , reg16 RO Reg
                                                  ]
                           }
                       ]
   }

i_blendpd :: X86Insn
i_blendpd = insn
   { insnDesc        = "Blend packed double-precision floating-point values"
   , insnMnemonic    = "BLENDPD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F3A
                           , legacyOpcode          = 0x0D
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     , imm8
                                                     ]
                           }
                       ]
   }

i_vblendpd :: X86Insn
i_vblendpd = insn
   { insnDesc        = "Blend packed double-precision floating-point values"
   , insnMnemonic    = "VBLENDPD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x03
                           , vexOpcode          = 0x0D
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  , imm8
                                                  ]
                           }
                       ]
   }

i_bextr :: X86Insn
i_bextr = insn
   { insnDesc        = "Bit field extract"
   , insnMnemonic    = "BEXTR"
   , insnFlags       = [ Modified [ZF]
                       , Undefined [AF,SF,PF]
                       , Unset (allFlags \\ [ZF,AF,SF,PF])
                       ]
   , insnEncodings   = [ vex
                           { vexOpcodeMap    = MapVex 0x02
                           , vexOpcode       = 0xF7
                           , vexLW           = L0
                           , vexProperties   = [ LegacyModeSupport
                                               , LongModeSupport
                                               , Extension BMI1
                                               ]
                           , vexParams       = [ reg32o64 WO Reg
                                               , rm32o64 RO
                                               , reg32o64 RO Vvvv
                                               ]
                           }
                       ]
   }

i_blendps :: X86Insn
i_blendps = insn
   { insnDesc        = "Blend packed single-precision floating-point values"
   , insnMnemonic    = "BLENDPS"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F3A
                           , legacyOpcode          = 0x0C
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     , imm8
                                                     ]
                           }
                       ]
   }

i_vblendps :: X86Insn
i_vblendps = insn
   { insnDesc        = "Blend packed single-precision floating-point values"
   , insnMnemonic    = "VBLENDPS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x03
                           , vexOpcode          = 0x0C
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  , imm8
                                                  ]
                           }
                       ]
   }

i_blendvpd :: X86Insn
i_blendvpd = insn
   { insnDesc        = "Variable blend packed double-precision floating-point values"
   , insnMnemonic    = "BLENDVPD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x15
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     , reg (R_XMM 0) RO Implicit
                                                     ]
                           }
                       ]
   }

i_vblendvpd :: X86Insn
i_vblendvpd = insn
   { insnDesc        = "Variable blend packed double-precision floating-point values"
   , insnMnemonic    = "VBLENDVPD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x03
                           , vexOpcode          = 0x4B
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  , vec128o256 RO Imm8h
                                                  ]
                           }
                       ]
   }

i_blendvps :: X86Insn
i_blendvps = insn
   { insnDesc        = "Variable blend packed single-precision floating-point values"
   , insnMnemonic    = "BLENDVPS"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x14
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     , reg (R_XMM 0) RO Implicit
                                                     ]
                           }
                       ]
   }

i_vblendvps :: X86Insn
i_vblendvps = insn
   { insnDesc        = "Variable blend packed single-precision floating-point values"
   , insnMnemonic    = "VBLENDVPS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x03
                           , vexOpcode          = 0x4A
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  , vec128o256 RO Imm8h
                                                  ]
                           }
                       ]
   }

i_blsi :: X86Insn
i_blsi = insn
   { insnDesc        = "Extract lowest set isolated bit"
   , insnMnemonic    = "BLSI"
   , insnFlags       = [ Modified  [ZF,SF,CF]
                       , Unset     [OF]
                       , Undefined [AF,PF]
                       ]
   , insnEncodings   = [ vex
                           { vexOpcodeMap    = MapVex 0x02
                           , vexOpcode       = 0xF3
                           , vexOpcodeExt    = Just 3
                           , vexLW           = L0
                           , vexProperties   = [ LegacyModeSupport
                                               , LongModeSupport
                                               , Extension BMI1
                                               ]
                           , vexParams       = [ reg32o64 WO Vvvv
                                               , rm32o64 RO
                                               ]
                           }
                       ]
   }

i_blsmsk :: X86Insn
i_blsmsk = insn
   { insnDesc        = "Get mask up to lowest set bit"
   , insnMnemonic    = "BLSMSK"
   , insnFlags       = [ Modified  [SF,CF]
                       , Unset     [ZF,OF]
                       , Undefined [AF,PF]
                       ]
   , insnEncodings   = [ vex
                           { vexOpcodeMap    = MapVex 0x02
                           , vexOpcode       = 0xF3
                           , vexOpcodeExt    = Just 2
                           , vexLW           = L0
                           , vexProperties   = [ LegacyModeSupport
                                               , LongModeSupport
                                               , Extension BMI1
                                               ]
                           , vexParams       = [ reg32o64 WO Vvvv
                                               , rm32o64 RO
                                               ]
                           }
                       ]
   }

i_blsr :: X86Insn
i_blsr = insn
   { insnDesc        = "Reset lowest set bit"
   , insnMnemonic    = "BLSR"
   , insnFlags       = [ Modified  [ZF,SF,CF]
                       , Unset     [OF]
                       , Undefined [AF,PF]
                       ]
   , insnEncodings   = [ vex
                           { vexOpcodeMap    = MapVex 0x02
                           , vexOpcode       = 0xF3
                           , vexOpcodeExt    = Just 1
                           , vexLW           = L0
                           , vexProperties   = [ LegacyModeSupport
                                               , LongModeSupport
                                               , Extension BMI1
                                               ]
                           , vexParams       = [ reg32o64 WO Vvvv
                                               , rm32o64 RO
                                               ]
                           }
                       ]
   }

i_bound :: X86Insn
i_bound = insn
   { insnDesc        = "Check array index against bounds"
   , insnMnemonic    = "BOUND"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0x62
                           , legacyProperties   = [LegacyModeSupport]
                           , legacyParams       = [ gpr RO Reg
                                                  , op    RO    (T_Mem MemPair16o32) RM
                                                  ]
                           }
                       ]
   }

i_bsf :: X86Insn
i_bsf = insn
   { insnDesc        = "Bit scan forward"
   , insnMnemonic    = "BSF"
   , insnFlags       = [ Modified  [ZF]
                       , Undefined [CF,OF,SF,AF,PF]
                       ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0xBC
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ gpr WO Reg
                                                  , mgpr RO
                                                  ]
                           }
                       ]
   }

i_bsr :: X86Insn
i_bsr = insn
   { insnDesc        = "Bit scan reverse"
   , insnMnemonic    = "BSR"
   , insnFlags       = [ Modified  [ZF]
                       , Undefined [CF,OF,SF,AF,PF]
                       ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0xBD
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ gpr WO Reg
                                                  , mgpr RO
                                                  ]
                           }
                       ]
   }

i_bswap :: X86Insn
i_bswap = insn
   { insnDesc        = "Byte swap"
   , insnMnemonic    = "BSWAP"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0xC8
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Arch Intel486
                                                  ]
                           , legacyParams       = [ reg32o64 RW OpcodeLow3 ]
                           }
                       ]
   }

i_bt :: X86Insn
i_bt = insn
   { insnDesc        = "Bit test"
   , insnMnemonic    = "BT"
   , insnFlags       = [ Modified  [CF]
                       , Undefined [OF,SF,AF,PF]
                       ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0xA3
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ mgpr RO
                                                  , gpr RO Reg
                                                  ]
                           }
                       , leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0xBA
                           , legacyOpcodeExt    = Just 4
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ mgpr RO
                                                  , imm8
                                                  ]
                           }
                       ]
   }

i_btc :: X86Insn
i_btc = insn
   { insnDesc        = "Bit test and complement"
   , insnMnemonic    = "BTC"
   , insnFlags       = [ Modified  [CF]
                       , Undefined [OF,SF,AF,PF]
                       ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0xBB
                           , legacyProperties   = [ Lockable
                                                  , LegacyModeSupport
                                                  , LongModeSupport
                                                  , HLE XBoth
                                                  ]
                           , legacyParams       = [ mgpr RW
                                                  , gpr RO Reg
                                                  ]
                           }
                       , leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0xBA
                           , legacyOpcodeExt    = Just 7
                           , legacyProperties   = [ Lockable
                                                  , LegacyModeSupport
                                                  , LongModeSupport
                                                  , HLE XBoth
                                                  ]
                           , legacyParams       = [ mgpr RW
                                                  , imm8
                                                  ]
                           }
                       ]
   }

i_btr :: X86Insn
i_btr = insn
   { insnDesc        = "Bit test and reset"
   , insnMnemonic    = "BTR"
   , insnFlags       = [ Modified  [CF]
                       , Undefined [OF,SF,AF,PF]
                       ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0xB3
                           , legacyProperties   = [ Lockable
                                                  , LegacyModeSupport
                                                  , LongModeSupport
                                                  , HLE XBoth
                                                  ]
                           , legacyParams       = [ mgpr RW
                                                  , gpr RO Reg
                                                  ]
                           }
                       , leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0xBA
                           , legacyOpcodeExt    = Just 6
                           , legacyProperties   = [ Lockable
                                                  , LegacyModeSupport
                                                  , LongModeSupport
                                                  , HLE XBoth
                                                  ]
                           , legacyParams       = [ mgpr RW
                                                  , imm8
                                                  ]
                           }
                       ]
   }

i_bts :: X86Insn
i_bts = insn
   { insnDesc        = "Bit test and set"
   , insnMnemonic    = "BTS"
   , insnFlags       = [ Modified  [CF]
                       , Undefined [OF,SF,AF,PF]
                       ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0xAB
                           , legacyProperties   = [ Lockable
                                                  , LegacyModeSupport
                                                  , LongModeSupport
                                                  , HLE XBoth
                                                  ]
                           , legacyParams       = [ mgpr RW
                                                  , gpr RO Reg
                                                  ]
                           }
                       , leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0xBA
                           , legacyOpcodeExt    = Just 5
                           , legacyProperties   = [ Lockable
                                                  , LegacyModeSupport
                                                  , LongModeSupport
                                                  , HLE XBoth
                                                  ]
                           , legacyParams       = [ mgpr RW
                                                  , imm8
                                                  ]
                           }
                       ]
   }

i_bzhi :: X86Insn
i_bzhi = insn
   { insnDesc           = "Zero high bits starting with specified bit position"
   , insnMnemonic       = "BZHI"
   , insnFlags          = [ Modified  [ZF,CF,SF]
                          , Unset     [OF]
                          , Undefined [AF,PF]
                          ]
   , insnEncodings      = [ vex
                              { vexOpcodeMap    = MapVex 0x02
                              , vexOpcode       = 0xF5
                              , vexLW           = L0
                              , vexProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension BMI2
                                                  ]
                              , vexParams       = [ reg32o64 WO Reg
                                                  , rm32o64 RO
                                                  , reg32o64 RO Vvvv
                                                  ]
                              }
                          ]
   }

i_call :: X86Insn
i_call = insn
   { insnDesc        = "Call procedure"
   , insnMnemonic    = "CALL"
   , insnFlags       = [Undefined allFlags]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0xE8
                           , legacyProperties   = [ DefaultOperandSize64
                                                  , LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ rel16o32 ]
                           }
                       , leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0xFF
                           , legacyOpcodeExt    = Just 2
                           , legacyProperties   = [LegacyModeSupport]
                           , legacyParams       = [ mgpr RO ]
                           }
                       , leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0xFF
                           , legacyOpcodeExt    = Just 2
                           , legacyProperties   = [ LongModeSupport
                                                  , DefaultOperandSize64
                                                  ]
                           , legacyParams       = [ rm64 RO ]
                           }
                       , leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0x9A
                           , legacyProperties   = [LegacyModeSupport]
                           , legacyParams       = [ ptr16x ]
                           }
                       , leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0xFF
                           , legacyOpcodeExt    = Just 3
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ m16x ]
                           }
                       ]
   }

i_extend_signed :: X86Insn
i_extend_signed = insn
   { insnDesc        = "Extend signed word"
   , insnMnemonic    = "CBW/CWDE/CDQE"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0x98
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ regAccu RW ]
                           }
                       ]
   }

i_clac :: X86Insn
i_clac = insn
   { insnDesc        = "Clear AC flag in EFLAGS register"
   , insnMnemonic    = "CLAC"
   , insnFlags       = [Unset [AC]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = Map0F
                           , legacyOpcode        = 0x01
                           , legacyOpcodeFullExt = Just 0xCA
                           , legacyProperties    = [ LegacyModeSupport
                                                   , LongModeSupport
                                                   , Extension SMAP
                                                   ]
                           }
                       ]
   }

i_clc :: X86Insn
i_clc = insn
   { insnDesc        = "Clear carry flag"
   , insnMnemonic    = "CLC"
   , insnFlags       = [Unset [CF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0xF8
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           }
                       ]
   }

i_cld :: X86Insn
i_cld = insn
   { insnDesc        = "Clear direction flag"
   , insnMnemonic    = "CLD"
   , insnFlags       = [Unset [DF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0xFC
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           }
                       ]
   }

i_clflush :: X86Insn
i_clflush = insn
   { insnDesc        = "Flush cache line"
   , insnMnemonic    = "CLFLUSH"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0xAE
                           , legacyOpcodeExt    = Just 7
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension CLFLUSH
                                                  ]
                           , legacyParams       = [ mvoid ]
                           }
                       ]
   }


i_cli :: X86Insn
i_cli = insn
   { insnDesc        = "Clear interrupt flag"
   , insnMnemonic    = "CLI"
   , insnFlags       = [Unset [IF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0xFA
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           }
                       ]
   }

i_clts :: X86Insn
i_clts = insn
   { insnDesc        = "Clear task-switched flag in CR0"
   , insnMnemonic    = "CLTS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0x06
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           }
                       ]
   }

i_cmc :: X86Insn
i_cmc = insn
   { insnDesc        = "Complement carry flag"
   , insnMnemonic    = "CMC"
   , insnFlags       = [Modified [CF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0xF5
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           }
                       ]
   }

i_cmovo :: X86Insn
i_cmovo = insn
   { insnDesc        = "Move if overflow (OF=1)"
   , insnMnemonic    = "CMOVO"
   , insnFlags       = [Read [OF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0x40
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ gpr RW Reg
                                                  , mgpr RO
                                                  ]
                           }
                       ]
   }

i_cmovno :: X86Insn
i_cmovno = insn
   { insnDesc        = "Move if not overflow (OF=0)"
   , insnMnemonic    = "CMOVNO"
   , insnFlags       = [Read [OF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0x41
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ gpr RW Reg
                                                  , mgpr RO
                                                  ]
                           }
                       ]
   }

i_cmovc :: X86Insn
i_cmovc = insn
   { insnDesc        = "Move if carry (CF=1)"
   , insnMnemonic    = "CMOVC"
   , insnFlags       = [Read [CF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0x42
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ gpr RW Reg
                                                  , mgpr RO
                                                  ]
                           }
                       ]
   }

i_cmovnc :: X86Insn
i_cmovnc = insn
   { insnDesc        = "Move if not carry (CF=0)"
   , insnMnemonic    = "CMOVNC"
   , insnFlags       = [Read [CF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0x43
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ gpr RW Reg
                                                  , mgpr RO
                                                  ]
                           }
                       ]
   }

i_cmovz :: X86Insn
i_cmovz = insn
   { insnDesc        = "Move if zero (ZF=1)"
   , insnMnemonic    = "CMOVZ"
   , insnFlags       = [Read [ZF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0x44
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ gpr RW Reg
                                                  , mgpr RO
                                                  ]
                           }
                       ]
   }

i_cmovnz :: X86Insn
i_cmovnz = insn
   { insnDesc        = "Move if not zero (ZF=0)"
   , insnMnemonic    = "CMOVNZ"
   , insnFlags       = [Read [ZF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0x45
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ gpr RW Reg
                                                  , mgpr RO
                                                  ]
                           }
                       ]
   }

i_cmovbe :: X86Insn
i_cmovbe = insn
   { insnDesc        = "Move if below or equal (CF=1, ZF=1)"
   , insnMnemonic    = "CMOVBE"
   , insnFlags       = [Read [ZF,CF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0x46
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ gpr RW Reg
                                                  , mgpr RO
                                                  ]
                           }
                       ]
   }

i_cmova :: X86Insn
i_cmova = insn
   { insnDesc        = "Move if above (CF=0, ZF=0)"
   , insnMnemonic    = "CMOVA"
   , insnFlags       = [Read [ZF,CF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0x47
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ gpr RW Reg
                                                  , mgpr RO
                                                  ]
                           }
                       ]
   }

i_cmovs :: X86Insn
i_cmovs = insn
   { insnDesc        = "Move if sign (SF=1)"
   , insnMnemonic    = "CMOVS"
   , insnFlags       = [Read [SF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0x48
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ gpr RW Reg
                                                  , mgpr RO
                                                  ]
                           }
                       ]
   }

i_cmovns :: X86Insn
i_cmovns = insn
   { insnDesc        = "Move if not sign (SF=0)"
   , insnMnemonic    = "CMOVNS"
   , insnFlags       = [Read [SF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0x49
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ gpr RW Reg
                                                  , mgpr RO
                                                  ]
                           }
                       ]
   }

i_cmovp :: X86Insn
i_cmovp = insn
   { insnDesc        = "Move if parity even (PF=1)"
   , insnMnemonic    = "CMOVP"
   , insnFlags       = [Read [PF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0x4a
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ gpr RW Reg
                                                  , mgpr RO
                                                  ]
                           }
                       ]
   }

i_cmovnp :: X86Insn
i_cmovnp = insn
   { insnDesc        = "Move if parity odd (PF=0)"
   , insnMnemonic    = "CMOVNP"
   , insnFlags       = [Read [PF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0x4b
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ gpr RW Reg
                                                  , mgpr RO
                                                  ]
                           }
                       ]
   }

i_cmovl :: X86Insn
i_cmovl = insn
   { insnDesc        = "Move if less (SF /= OF)"
   , insnMnemonic    = "CMOVL"
   , insnFlags       = [Read [SF,OF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0x4c
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ gpr RW Reg
                                                  , mgpr RO
                                                  ]
                           }
                       ]
   }

i_cmovge :: X86Insn
i_cmovge = insn
   { insnDesc        = "Move if greater or equal (SF = OF)"
   , insnMnemonic    = "CMOVGE"
   , insnFlags       = [Read [SF,OF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0x4d
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ gpr RW Reg
                                                  , mgpr RO
                                                  ]
                           }
                       ]
   }

i_cmovle :: X86Insn
i_cmovle = insn
   { insnDesc        = "Move if less or equal (ZF = 1 or SF <> OF)"
   , insnMnemonic    = "CMOVLE"
   , insnFlags       = [Read [ZF,SF,OF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0x4e
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ gpr RW Reg
                                                  , mgpr RO
                                                  ]
                           }
                       ]
   }

i_cmovg :: X86Insn
i_cmovg = insn
   { insnDesc        = "Move if greater (ZF = 0 or SF = OF)"
   , insnMnemonic    = "CMOVG"
   , insnFlags       = [Read [ZF,SF,OF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0x4f
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ gpr RW Reg
                                                  , mgpr RO
                                                  ]
                           }
                       ]
   }


i_cmp :: X86Insn
i_cmp = insn
   { insnDesc        = "Compare"
   , insnMnemonic    = "CMP"
   , insnFlags       = [Modified [OF,SF,ZF,AF,CF,PF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0x3C
                           , legacyNoForce8bit  = Just 0
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ regAccu RO
                                                  , immSE
                                                  ]
                           }
                       , leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0x38
                           , legacyNoForce8bit  = Just 0
                           , legacyReversable   = Just 1
                           , legacyProperties   = [ Lockable
                                                  , LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ mgpr RO
                                                  , gpr RO Reg
                                                  ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x80
                           , legacyOpcodeExt       = Just 7
                           , legacyNoForce8bit     = Just 0
                           , legacySignExtendable  = Just 1
                           , legacyProperties      = [ Lockable
                                                     , LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mgpr RO
                                                     , immSE
                                                     ]
                           }
                       ]
   }

i_cmppd :: X86Insn
i_cmppd = insn
   { insnDesc        = "Compare packed double-precision floating-point values"
   , insnMnemonic    = "CMPPD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix    = Just 0x66
                           , legacyOpcodeMap          = Map0F
                           , legacyOpcode             = 0xC2
                           , legacyProperties         = [ LegacyModeSupport
                                                        , LongModeSupport
                                                        , Extension SSE2
                                                        ]
                           , legacyParams             = [ vec128 RW Reg
                                                        , mvec128 RO
                                                        , imm8
                                                        ]
                           }
                       ]
   }

i_vcmppd :: X86Insn
i_vcmppd = insn
   { insnDesc        = "Compare packed double-precision floating-point values"
   , insnMnemonic    = "VCMPPD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xC2
                           , vexLW                 = WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128o256 WO Reg
                                                     , vec128o256 RO Vvvv
                                                     , mvec128o256 RO
                                                     , imm8
                                                     ]
                           }
                       ]
   }

i_cmpps :: X86Insn
i_cmpps = insn
   { insnDesc        = "Compare packed single-precision floating-point values"
   , insnMnemonic    = "CMPPS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0xC2
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension SSE
                                                  ]
                           , legacyParams       = [ vec128 RW Reg
                                                  , mvec128 RO
                                                  , imm8
                                                  ]
                           }
                       ]
   }

i_vcmpps :: X86Insn
i_vcmpps = insn
   { insnDesc        = "Compare packed single-precision floating-point values"
   , insnMnemonic    = "VCMPPS"
   , insnEncodings   = [ vex
                           { vexOpcodeMap    = MapVex 0x01
                           , vexOpcode       = 0xC2
                           , vexLW           = WIG
                           , vexProperties   = [ LegacyModeSupport
                                               , LongModeSupport
                                               , Extension AVX
                                               ]
                           , vexParams       = [ vec128o256 WO Reg
                                               , vec128o256 RO Vvvv
                                               , mvec128o256 RO
                                               , imm8
                                               ]
                           }
                       ]
   }

i_cmps :: X86Insn
i_cmps = insn
   { insnDesc        = "Compare string operands"
   , insnMnemonic    = "CMPS"
   , insnFlags       = [Modified [CF,OF,SF,ZF,AF,PF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0xA6
                           , legacyNoForce8bit  = Just 0
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Repeatable
                                                  ]
                           , legacyParams       = [ mDSrSI RO
                                                  , mESrDI RO
                                                  ]
                           }
                       ]
   }

i_cmpsd :: X86Insn
i_cmpsd = insn
   { insnDesc        = "Compare scalar double-precision floating-point values"
   , insnMnemonic    = "CMPSD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix    = Just 0xF2
                           , legacyOpcodeMap          = Map0F
                           , legacyOpcode             = 0xC2
                           , legacyProperties         = [ LegacyModeSupport
                                                        , LongModeSupport
                                                        , Extension SSE2
                                                        ]
                           , legacyParams             = [ vec128 RW Reg
                                                        , mvec128 RO
                                                        , imm8
                                                        ]
                           }
                       ]
   }

i_vcmpsd :: X86Insn
i_vcmpsd = insn
   { insnDesc        = "Compare scalar double-precision floating-point values"
   , insnMnemonic    = "VCMPSD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix    = Just 0xF2
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xC2
                           , vexLW                 = LWIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     , imm8
                                                     ]
                           }
                       ]
   }

i_cmpss :: X86Insn
i_cmpss = insn
   { insnDesc        = "Compare scalar single-precision floating-point values"
   , insnMnemonic    = "CMPSS"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix    = Just 0xF3
                           , legacyOpcodeMap          = Map0F
                           , legacyOpcode             = 0xC2
                           , legacyProperties         = [ LegacyModeSupport
                                                        , LongModeSupport
                                                        , Extension SSE
                                                        ]
                           , legacyParams             = [ vec128 RW Reg
                                                        , mvec128 RO
                                                        , imm8
                                                        ]
                           }
                       ]
   }

i_vcmpss :: X86Insn
i_vcmpss = insn
   { insnDesc        = "Compare scalar single-precision floating-point values"
   , insnMnemonic    = "VCMPSS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix    = Just 0xF3
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xC2
                           , vexLW                 = LWIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     , imm8
                                                     ]
                           }
                       ]
   }

i_cmpxchg :: X86Insn
i_cmpxchg = insn
   { insnDesc        = "Compare and exchange"
   , insnMnemonic    = "CMPXCHG"
   , insnFlags       = [Modified [ZF,CF,PF,AF,SF,OF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0xB0
                           , legacyNoForce8bit  = Just 0
                           , legacyProperties   = [ Lockable
                                                  , LegacyModeSupport
                                                  , LongModeSupport
                                                  , Arch Intel486
                                                  , HLE XBoth
                                                  ]
                           , legacyParams       = [ mgpr RW
                                                  , regAccu RO
                                                  , gpr RO Reg
                                                  ]
                           }
                       ]
   }

i_cmpxch8b :: X86Insn
i_cmpxch8b = insn
   { insnDesc        = "Compare and exchange bytes"
   , insnMnemonic    = "CMPXCHG8B/CMPXCHG16B"
   , insnFlags       = [Modified [ZF,CF,PF,AF,SF,OF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0xC7
                           , legacyProperties   = [ Lockable
                                                  , LegacyModeSupport
                                                  , LongModeSupport
                                                  , Arch IntelPentium
                                                  , Extension CX8
                                                  , HLE XBoth
                                                  ]
                           , legacyParams       = [ rDXrAX RW
                                                  , rCXrBX RO
                                                  , mem64o128 RW
                                                  ]
                           }
                       ]
   }


i_comisd :: X86Insn
i_comisd = insn
   { insnDesc        = "Compare scalar ordered double-precision floating-point values and set EFLAGS"
   , insnMnemonic    = "(V)COMISD"
   , insnFlags       = [ Modified [ZF,PF,CF]
                       , Unset    [OF,SF,AF]
                       ]
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix    = Just 0x66
                           , legacyOpcodeMap          = Map0F
                           , legacyOpcode             = 0x2F
                           , legacyProperties         = [ LegacyModeSupport
                                                        , LongModeSupport
                                                        , Extension SSE2
                                                        ]
                           , legacyParams             = [ vec128low64 RO Reg
                                                        , mvec128low64 RO
                                                        ]
                           }
                       , vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x2F
                           , vexLW              = LWIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128low64 RO Reg
                                                  , mvec128low64 RO
                                                  ]
                           }
                       ]
   }

i_comiss :: X86Insn
i_comiss = insn
   { insnDesc        = "Compare scalar ordered single-precision floating-point values and set EFLAGS"
   , insnMnemonic    = "(V)COMISS"
   , insnFlags       = [ Modified [ZF,PF,CF]
                       , Unset    [OF,SF,AF]
                       ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0x2F
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension SSE
                                                  ]
                           , legacyParams       = [ vec128low32 RO Reg
                                                  , mvec128low32 RO
                                                  ]
                           }
                       , vex
                           { vexOpcodeMap    = MapVex 0x01
                           , vexOpcode       = 0x2F
                           , vexLW           = LWIG
                           , vexProperties   = [ LegacyModeSupport
                                               , LongModeSupport
                                               , Extension AVX
                                               ]
                           , vexParams       = [ vec128low32 RO Reg
                                               , mvec128low32 RO
                                               ]
                           }
                       ]
   }

i_cpuid :: X86Insn
i_cpuid = insn
   { insnDesc        = "CPU identification"
   , insnMnemonic    = "CPUID"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0xA2
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ reg R_EAX RW Implicit
                                                  , reg R_ECX RW Implicit
                                                  , reg R_EBX WO Implicit
                                                  , reg R_EDX WO Implicit
                                                  ]
                           }
                       ]
   }

i_crc32 :: X86Insn
i_crc32 = insn
   { insnDesc        = "Accumulate CRC32 value"
   , insnMnemonic    = "CRC32"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF2
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0xF0
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ gpr RW Reg
                                                     , mgpr RO
                                                     ]
                           }
                       ]
   }

i_cvtdq2pd :: X86Insn
i_cvtdq2pd = insn
   { insnDesc        = "Convert packed Int32 to packed double-precision floating-point values"
   , insnMnemonic    = "CVTDQ2PD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF3
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xE6
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128low64 RO
                                                     ]
                           }
                       ]
   }

i_vcvtdq2pd :: X86Insn
i_vcvtdq2pd = insn
   { insnDesc        = "Convert packed Int32 to packed double-precision floating-point values"
   , insnMnemonic    = "VCVTDQ2PD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0xF3
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0xE6
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , mveclow RO
                                                  ]
                           }
                       ]
   }

i_cvtdq2ps :: X86Insn
i_cvtdq2ps = insn
   { insnDesc        = "Convert packed Int32 to packed single-precision floating-point values"
   , insnMnemonic    = "CVTDQ2PS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0x5B
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension SSE2
                                                  ]
                           , legacyParams       = [ vec128 WO Reg
                                                  , mvec128 RO
                                                  ]
                           }
                       ]
   }

i_vcvtdq2ps :: X86Insn
i_vcvtdq2ps = insn
   { insnDesc        = "Convert packed Int32 to packed single-precision floating-point values"
   , insnMnemonic    = "VCVTDQ2PS"
   , insnEncodings   = [ vex
                           { vexOpcodeMap    = MapVex 0x01
                           , vexOpcode       = 0x5B
                           , vexLW           = WIG
                           , vexProperties   = [ LegacyModeSupport
                                               , LongModeSupport
                                               , Extension AVX
                                               ]
                           , vexParams       = [ vec128o256 WO Reg
                                               , mvec128o256 RO
                                               ]
                           }
                       ]
   }

i_cvtpd2dq :: X86Insn
i_cvtpd2dq = insn
   { insnDesc        = "Convert packed double-precision floating-point values to packed Int32"
   , insnMnemonic    = "CVTPD2DQ"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF2
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xE6
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vcvtpd2dq :: X86Insn
i_vcvtpd2dq = insn
   { insnDesc        = "Convert packed double-precision floating-point values to packed Int32"
   , insnMnemonic    = "VCVTPD2DQ"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0xF2
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0xE6
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }

i_cvtpd2di :: X86Insn
i_cvtpd2di = insn
   { insnDesc        = "Convert packed double-precision floating-point values to packed Int32"
   , insnMnemonic    = "CVTPD2DI"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x2D
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ vec64 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_cvtpd2ps :: X86Insn
i_cvtpd2ps = insn
   { insnDesc        = "Convert packed double-precision floating-point values to packed single-precision floating-point values"
   , insnMnemonic    = "CVTPD2PS"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x5A
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vcvtpd2ps :: X86Insn
i_vcvtpd2ps = insn
   { insnDesc        = "Convert packed double-precision floating-point values to packed single-precision floating-point values"
   , insnMnemonic    = "VCVTPD2PS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x5A
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128 WO Reg
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }

i_cvtpi2pd :: X86Insn
i_cvtpi2pd = insn
   { insnDesc        = "Convert packed Int32 to packed double-precision floating-point values"
   , insnMnemonic    = "CVTPI2PD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x2A
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       ]
   }

i_cvtpi2ps :: X86Insn
i_cvtpi2ps = insn
   { insnDesc        = "Convert packed Int32 to packed single-precision floating-point values"
   , insnMnemonic    = "CVTPI2PS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0x2A
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ vec128 WO Reg
                                                  , mvec64 RO
                                                  ]
                           }
                       ]
   }

i_cvtps2dq :: X86Insn
i_cvtps2dq = insn
   { insnDesc        = "Convert packed single-precision floating-point values to packed Int32"
   , insnMnemonic    = "CVTPS2DQ"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x5B
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vcvtps2dq :: X86Insn
i_vcvtps2dq = insn
   { insnDesc        = "Convert packed single-precision floating-point values to packed Int32"
   , insnMnemonic    = "VCVTPS2DQ"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x5B
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }

i_cvtps2pd :: X86Insn
i_cvtps2pd = insn
   { insnDesc        = "Convert packed single-precision floating-point values to packed double-precision floating-point values"
   , insnMnemonic    = "CVTPS2PD"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0x5A
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension SSE2
                                                  ]
                           , legacyParams       = [ vec128 WO Reg
                                                  , mvec128 RO
                                                  ]
                           }
                       ]
   }

i_vcvtps2pd :: X86Insn
i_vcvtps2pd = insn
   { insnDesc        = "Convert packed single-precision floating-point values to packed double-precision floating-point values"
   , insnMnemonic    = "VCVTPS2PD"
   , insnEncodings   = [ vex
                           { vexOpcodeMap    = MapVex 0x01
                           , vexOpcode       = 0x5A
                           , vexLW           = WIG
                           , vexProperties   = [ LegacyModeSupport
                                               , LongModeSupport
                                               , Extension AVX
                                               ]
                           , vexParams       = [ vec128 WO Reg
                                               , mvec128o256 RO
                                               ]
                           }
                       ]
   }

i_cvtps2pi :: X86Insn
i_cvtps2pi = insn
   { insnDesc        = "Convert packed single-precision floating-point values to packed Int32"
   , insnMnemonic    = "CVTPS2PI"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0x2D
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ vec64 WO Reg
                                                  , mvec128low64 RO
                                                  ]
                           }
                       ]
   }

i_cvtsd2si :: X86Insn
i_cvtsd2si = insn
   { insnDesc        = "Convert scalar double-precision floating-point value to integer"
   , insnMnemonic    = "CVTSD2SI"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF2
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x2D
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ reg32o64 WO Reg
                                                     , mvec128low64 RO
                                                     ]
                           }
                       ]
   }

i_vcvtsd2si :: X86Insn
i_vcvtsd2si = insn
   { insnDesc        = "Convert scalar double-precision floating-point value to integer"
   , insnMnemonic    = "VCVTSD2SI"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0xF2
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x2D
                           , vexLW              = LIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ reg32o64 WO Reg
                                                  , mvec128low64 RO
                                                  ]
                           }
                       ]
   }

i_cvtsd2ss :: X86Insn
i_cvtsd2ss = insn
   { insnDesc        = "Convert scalar double-precision floating-point value to scalar single-precision floating-point value"
   , insnMnemonic    = "CVTSD2SS"
   , insnEncodings   = [leg
                           { legacyMandatoryPrefix = Just 0xF2
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x5A
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128low64 RO
                                                     ]
                           }
                       ]
   }

i_vcvtsd2ss :: X86Insn
i_vcvtsd2ss = insn
   { insnDesc        = "Convert scalar double-precision floating-point value to scalar single-precision floating-point value"
   , insnMnemonic    = "VCVTSD2SS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0xF2
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x5A
                           , vexLW              = LWIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128 WO Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low64 RO
                                                  ]
                           }
                       ]
   }

i_cvtsi2sd :: X86Insn
i_cvtsi2sd = insn
   { insnDesc        = "Convert Int32 to scalar double-precision floating-point value"
   , insnMnemonic    = "CVTSI2SD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF2
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x2A
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , rm32o64 RO
                                                     ]
                           }
                       ]
   }

i_vcvtsi2sd :: X86Insn
i_vcvtsi2sd = insn
   { insnDesc        = "Convert Int32 to scalar double-precision floating-point value"
   , insnMnemonic    = "VCVTSI2SD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0xF2
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x2A
                           , vexLW              = LIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128 WO Reg
                                                  , vec128 RO Vvvv
                                                  , rm32o64 RO
                                                  ]
                           }
                       ]
   }


i_cvtsi2ss :: X86Insn
i_cvtsi2ss = insn
   { insnDesc        = "Convert Int32 to scalar single-precision floating-point value"
   , insnMnemonic    = "CVTSI2SS"
   , insnEncodings   = [leg
                           { legacyMandatoryPrefix = Just 0xF3
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x2A
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , rm32o64 RO
                                                     ]
                           }
                       ]
   }

i_vcvtsi2ss :: X86Insn
i_vcvtsi2ss = insn
   { insnDesc        = "Convert Int32 to scalar single-precision floating-point value"
   , insnMnemonic    = "VCVTSI2SS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0xF3
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x2A
                           , vexLW              = LIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128 WO Reg
                                                  , vec128 RO Vvvv
                                                  , rm32o64 RO
                                                  ]
                           }
                       ]
   }

i_cvtss2sd :: X86Insn
i_cvtss2sd = insn
   { insnDesc        = "Convert scalar single-precision floating-point value to scalar double-precision floating-point value"
   , insnMnemonic    = "CVTSS2SD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF3
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x5A
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128low32 RO
                                                     ]
                           }
                       ]
   }

i_vcvtss2sd :: X86Insn
i_vcvtss2sd = insn
   { insnDesc        = "Convert scalar single-precision floating-point value to scalar double-precision floating-point value"
   , insnMnemonic    = "VCVTSS2SD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0xF3
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x5A
                           , vexLW              = LWIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128 WO Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low32 RO
                                                  ]
                           }
                       ]
   }

i_cvtss2si :: X86Insn
i_cvtss2si = insn
   { insnDesc        = "Convert scalar single-precision floating-point value to Int32"
   , insnMnemonic    = "CVTSS2SI"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF3
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x2D
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ reg32o64 WO Reg
                                                     , mvec128low32 RO
                                                     ]
                           }
                       ]
   }

i_vcvtss2si :: X86Insn
i_vcvtss2si = insn
   { insnDesc        = "Convert scalar single-precision floating-point value to Int32"
   , insnMnemonic    = "VCVTSS2SI"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0xF3
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x2D
                           , vexLW              = LIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ reg32o64 WO Reg
                                                  , mvec128low32 RO
                                                  ]
                           }
                       ]
   }

i_cvttpd2dq :: X86Insn
i_cvttpd2dq = insn
   { insnDesc        = "Convert with truncation packed double-precision floating-point values to packed Int32"
   , insnMnemonic    = "CVTTPD2DQ"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xE6
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vcvttpd2dq :: X86Insn
i_vcvttpd2dq = insn
   { insnDesc        = "Convert with truncation packed double-precision floating-point values to packed Int32"
   , insnMnemonic    = "VCVTTPD2DQ"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0xE6
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }

i_cvttpd2pi :: X86Insn
i_cvttpd2pi = insn
   { insnDesc        = "Convert with truncation packed double-precision floating-point values to packed Int32"
   , insnMnemonic    = "CVTTPD2PI"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x2C
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ vec64 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_cvttps2dq :: X86Insn
i_cvttps2dq = insn
   { insnDesc        = "Convert with truncation packed single-precision floating-point values to packed Int32"
   , insnMnemonic    = "CVTTPS2DQ"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF3
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x5B
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vcvttps2dq :: X86Insn
i_vcvttps2dq = insn
   { insnDesc        = "Convert with truncation packed single-precision floating-point values to packed Int32"
   , insnMnemonic    = "VCVTTPS2DQ"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0xF3
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x5B
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }

i_cvttps2pi :: X86Insn
i_cvttps2pi = insn
   { insnDesc        = "Convert with truncation packed single-precision floating-point values to packed Int32"
   , insnMnemonic    = "CVTTPS2PI"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0x2C
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ vec64 WO Reg
                                                  , mvec128low64 RO
                                                  ]
                           }
                       ]
   }

i_cvttsd2si :: X86Insn
i_cvttsd2si = insn
   { insnDesc        = "Convert with truncation scalar double-precision floating-point value to integer"
   , insnMnemonic    = "CVTTSD2SI"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF2
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x2C
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ reg32o64 WO Reg
                                                     , mvec128low64 RO
                                                     ]
                           }
                       ]
   }

i_vcvttsd2si :: X86Insn
i_vcvttsd2si = insn
   { insnDesc        = "Convert with truncation scalar double-precision floating-point value to integer"
   , insnMnemonic    = "VCVTTSD2SI"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0xF2
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x2C
                           , vexLW              = LIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ reg32o64 WO Reg
                                                  , mvec128low64 RO
                                                  ]
                           }
                       ]
   }

i_cvttss2si :: X86Insn
i_cvttss2si = insn
   { insnDesc        = "Convert with truncation scalar single-precision floating-point value to Int32"
   , insnMnemonic    = "CVTTSS2SI"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF3
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x2C
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ reg32o64 WO Reg
                                                     , mvec128low32 RO
                                                     ]
                           }
                       ]
   }

i_vcvttss2si :: X86Insn
i_vcvttss2si = insn
   { insnDesc        = "Convert with truncation scalar single-precision floating-point value to Int32"
   , insnMnemonic    = "VCVTTSS2SI"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0xF3
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x2C
                           , vexLW              = LIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ reg32o64 WO Reg
                                                  , mvec128low32 RO
                                                  ]
                           }
                       ]
   }

i_cwd :: X86Insn
i_cwd = insn
   { insnDesc        = "Convert between words (sign-extend)"
   , insnMnemonic    = "CWD/CDQ/CQO"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0x99
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ regFam RegFamDX WO Implicit
                                                  , regFam RegFamAX RW Implicit
                                                  ]
                           }
                       ]
   }

i_daa :: X86Insn
i_daa = insn
   { insnDesc        = "Decimal adjust AL after addition"
   , insnMnemonic    = "DAA"
   , insnFlags       = [ Modified  [AF,CF,SF,ZF,PF]
                       , Undefined [OF]
                       ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0x27
                           , legacyProperties   = [LegacyModeSupport]
                           , legacyParams       = [ reg R_AL RW Implicit ]
                           }
                       ]
   }

i_das :: X86Insn
i_das = insn
   { insnDesc        = "Decimal adjust AL after subtraction"
   , insnMnemonic    = "DAS"
   , insnFlags       = [ Modified  [AF,CF,SF,ZF,PF]
                       , Undefined [OF]
                       ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0x2F
                           , legacyProperties   = [LegacyModeSupport]
                           , legacyParams       = [ reg R_AL RW Implicit ]
                           }
                       ]
   }


i_dec :: X86Insn
i_dec = insn
   { insnDesc        = "Decrement by 1"
   , insnMnemonic    = "DEC"
   , insnFlags       = [Modified [OF,SF,ZF,AF,PF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0xFE
                           , legacyOpcodeExt    = Just 1
                           , legacyNoForce8bit  = Just 0
                           , legacyProperties   = [ Lockable
                                                  , LegacyModeSupport
                                                  , LongModeSupport
                                                  , HLE XBoth
                                                  ]
                           , legacyParams       = [ mgpr RW ]
                           }
                       , leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0x48
                           , legacyProperties   = [ LegacyModeSupport
                                                  , Lockable
                                                  ]
                           , legacyParams       = [ gpr RW OpcodeLow3 ]
                           }
                       ]
   }

i_div :: X86Insn
i_div = insn
   { insnDesc        = "Unsigned divide"
   , insnMnemonic    = "DIV"
   , insnProperties  = [FailOnZero 0]
   , insnFlags       = [Undefined [CF,OF,SF,ZF,AF,PF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0xF6
                           , legacyOpcodeExt    = Just 6
                           , legacyNoForce8bit  = Just 0
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ regFam RegFamDXAX RW Implicit
                                                  , mgpr RO
                                                  ]
                           }
                       ]
   }

i_divpd :: X86Insn
i_divpd = insn
   { insnDesc        = "Divide packed double-precision floating-point values"
   , insnMnemonic    = "DIVPD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x5E
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vdivpd :: X86Insn
i_vdivpd = insn
   { insnDesc        = "Divide packed double-precision floating-point values"
   , insnMnemonic    = "VDIVPD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x5E
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }

i_divps :: X86Insn
i_divps = insn
   { insnDesc        = "Divide packed float-precision floating-point values"
   , insnMnemonic    = "DIVPS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0x5E
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension SSE
                                                  ]
                           , legacyParams       = [ vec128 RW Reg
                                                  , mvec128 RO
                                                  ]
                           }
                       ]
   }

i_vdivps :: X86Insn
i_vdivps = insn
   { insnDesc        = "Divide packed float-precision floating-point values"
   , insnMnemonic    = "VDIVPS"
   , insnEncodings   = [ vex
                           { vexOpcodeMap    = MapVex 0x01
                           , vexOpcode       = 0x5E
                           , vexLW           = WIG
                           , vexProperties   = [ LegacyModeSupport
                                               , LongModeSupport
                                               , Extension AVX
                                               ]
                           , vexParams       = [ vec128o256 WO Reg
                                               , vec128o256 RO Vvvv
                                               , mvec128o256 RO
                                               ]
                           }
                       ]
   }

i_divsd :: X86Insn
i_divsd = insn
   { insnDesc        = "Divide scalar double-precision floating-point values"
   , insnMnemonic    = "DIVSD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF2
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x5E
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128low64 RO
                                                     ]
                           }
                       ]
   }

i_vdivsd :: X86Insn
i_vdivsd = insn
   { insnDesc        = "Divide scalar double-precision floating-point values"
   , insnMnemonic    = "VDIVSD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0xF2
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x5E
                           , vexLW              = LWIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128 WO Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low64 RO
                                                  ]
                           }
                       ]
   }

i_divss :: X86Insn
i_divss = insn
   { insnDesc        = "Divide scalar single-precision floating-point values"
   , insnMnemonic    = "DIVSS"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF3
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x5E
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128low32 RO
                                                     ]
                           }
                       ]
   }

i_vdivss :: X86Insn
i_vdivss = insn
   { insnDesc        = "Divide scalar single-precision floating-point values"
   , insnMnemonic    = "VDIVSS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0xF3
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x5E
                           , vexLW              = LWIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128 WO Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low32 RO
                                                  ]
                           }
                       ]
   }

i_dppd :: X86Insn
i_dppd = insn
   { insnDesc        = "Dot product of packed double precision floating-point values"
   , insnMnemonic    = "DPPD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F3A
                           , legacyOpcode          = 0x41
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     , imm8
                                                     ]
                           }
                       ]
   }

i_vdppd :: X86Insn
i_vdppd = insn
   { insnDesc        = "Dot product of packed double precision floating-point values"
   , insnMnemonic    = "VDPPD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x03
                           , vexOpcode          = 0x41
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128 WO Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128 RO
                                                  , imm8
                                                  ]
                           }
                       ]
   }

i_dpps :: X86Insn
i_dpps = insn
   { insnDesc        = "Dot product of packed single precision floating-point values"
   , insnMnemonic    = "DPPS"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F3A
                           , legacyOpcode          = 0x40
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     , imm8
                                                     ]
                           }
                       ]
   }

i_vdpps :: X86Insn
i_vdpps = insn
   { insnDesc        = "Dot product of packed single precision floating-point values"
   , insnMnemonic    = "VDPPS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x03
                           , vexOpcode          = 0x40
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  , imm8
                                                  ]
                           }
                       ]
   }

i_emms :: X86Insn
i_emms = insn
   { insnDesc        = "Empty MMX technology state"
   , insnMnemonic    = "EMMS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0x77
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           }
                       ]
   }

i_enter :: X86Insn
i_enter = insn
   { insnDesc        = "Make stack frame for procedure parameters"
   , insnMnemonic    = "ENTER"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0xC8
                           , legacyProperties   = [ DefaultOperandSize64
                                                  , LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ stackFrame
                                                  ]
                           }
                       ]
   }

i_extractps :: X86Insn
i_extractps = insn
   { insnDesc        = "Extract packed single precision floating-point value"
   , insnMnemonic    = "EXTRACTPS"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F3A
                           , legacyOpcode          = 0x17
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ rm32 RW
                                                     , vec128 RO Reg
                                                     , imm8
                                                     ]
                           }
                       ]
   }

i_vextractps :: X86Insn
i_vextractps = insn
   { insnDesc        = "Extract packed single precision floating-point value"
   , insnMnemonic    = "VEXTRACTPS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x03
                           , vexOpcode          = 0x17
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ rm32 WO
                                                  , vec128 RO Vvvv
                                                  , imm8
                                                  ]
                           }
                       ]
   }


i_f2xm1 :: X86Insn
i_f2xm1 = insn
   { insnDesc        = "Compute 2^x - 1"
   , insnMnemonic    = "F2XM1"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeFullExt = Just 0xF0
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RW Implicit ]
                           }
                       ]
   }
                                       
i_fabs :: X86Insn
i_fabs = insn
   { insnDesc        = "Absolute value"
   , insnMnemonic    = "FABS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeFullExt = Just 0xE1
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RW Implicit ]
                           }
                       ]
   }

i_fadd :: X86Insn
i_fadd = insn
   { insnDesc        = "Add"
   , insnMnemonic    = "FADD"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD8
                           , legacyOpcodeExt     = Just 0
                           , legacyFPUSizable    = Just 2
                           , legacyFPUDest       = Just 2
                           , legacyFPUPop        = Just 1
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RW Implicit
                                                   , mst RO
                                                   ]
                           }
                       ]
   }

i_fiadd :: X86Insn
i_fiadd = insn
   { insnDesc        = "Add"
   , insnMnemonic    = "FIADD"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDA
                           , legacyOpcodeExt     = Just 0
                           , legacyFPUSizable    = Just 2
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RW Implicit
                                                   , mint RO
                                                   ]
                           }
                       ]
   }

i_fbld :: X86Insn
i_fbld = insn
   { insnDesc        = "Load binary coded decimal"
   , insnMnemonic    = "FBLD"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDF
                           , legacyOpcodeExt     = Just 4
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RW Implicit
                                                   , mdec80 RO
                                                   ]
                           }
                       ]
   }

i_fbstp :: X86Insn
i_fbstp = insn
   { insnDesc        = "Store BCD integer and pop"
   , insnMnemonic    = "FBSTP"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDF
                           , legacyOpcodeExt     = Just 6
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RO Implicit
                                                   , mdec80 RW
                                                   ]
                           }
                       ]
   }

i_fchs :: X86Insn
i_fchs = insn
   { insnDesc        = "Change sign"
   , insnMnemonic    = "FCHS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeFullExt = Just 0xE0
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RW Implicit ]
                           }
                       ]
   }

i_fnclex :: X86Insn
i_fnclex = insn
   { insnDesc        = "Clear exceptions"
   , insnMnemonic    = "FNCLEX"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDB
                           , legacyOpcodeFullExt = Just 0xE2
                           , legacyProperties    = [ Extension FPU ]
                           }
                       ]
   }

i_fcmovb :: X86Insn
i_fcmovb = insn
   { insnDesc        = "Floating-point conditional move"
   , insnMnemonic    = "FCMOVB"
   , insnFlags       = [ Read [CF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDA
                           , legacyOpcodeExt     = Just 0
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) WO Implicit
                                                   , st RO
                                                   ]
                           }
                       ]
   }

i_fcmove :: X86Insn
i_fcmove = insn
   { insnDesc        = "Floating-point conditional move"
   , insnMnemonic    = "FCMOVE"
   , insnFlags       = [ Read [ZF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDA
                           , legacyOpcodeExt     = Just 1
                           , legacyProperties    = [ Extension FPU
                                                   , Extension CMOV
                                                   ]
                           , legacyParams        = [ reg (R_ST 0) WO Implicit
                                                   , st RO
                                                   ]
                           }
                       ]
   }

i_fcmovbe :: X86Insn
i_fcmovbe = insn
   { insnDesc        = "Floating-point conditional move"
   , insnMnemonic    = "FCMOVBE"
   , insnFlags       = [ Read [ZF,CF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDA
                           , legacyOpcodeExt     = Just 2
                           , legacyProperties    = [ Extension FPU
                                                   , Extension CMOV
                                                   ]
                           , legacyParams        = [ reg (R_ST 0) WO Implicit
                                                   , st RO
                                                   ]
                           }
                       ]
   }

i_fcmovu :: X86Insn
i_fcmovu = insn
   { insnDesc        = "Floating-point conditional move"
   , insnMnemonic    = "FCMOVU"
   , insnFlags       = [ Read [PF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDA
                           , legacyOpcodeExt     = Just 3
                           , legacyProperties    = [ Extension FPU
                                                   , Extension CMOV
                                                   ]
                           , legacyParams        = [ reg (R_ST 0) WO Implicit
                                                   , st RO
                                                   ]
                           }
                       ]
   }

i_fcmovnb :: X86Insn
i_fcmovnb = insn
   { insnDesc        = "Floating-point conditional move"
   , insnMnemonic    = "FCMOVNB"
   , insnFlags       = [ Read [CF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDB
                           , legacyOpcodeExt     = Just 0
                           , legacyProperties    = [ Extension FPU
                                                   , Extension CMOV
                                                   ]
                           , legacyParams        = [ reg (R_ST 0) WO Implicit
                                                   , st RO
                                                   ]
                           }
                       ]
   }

i_fcmovne :: X86Insn
i_fcmovne = insn
   { insnDesc        = "Floating-point conditional move"
   , insnMnemonic    = "FCMOVNE"
   , insnFlags       = [ Read [ZF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDB
                           , legacyOpcodeExt     = Just 1
                           , legacyProperties    = [ Extension FPU
                                                   , Extension CMOV
                                                   ]
                           , legacyParams        = [ reg (R_ST 0) WO Implicit
                                                   , st RO
                                                   ]
                           }
                       ]
   }

i_fcmovnbe :: X86Insn
i_fcmovnbe = insn
   { insnDesc        = "Floating-point conditional move"
   , insnMnemonic    = "FCMOVNBE"
   , insnFlags       = [ Read [ZF,CF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDB
                           , legacyOpcodeExt     = Just 2
                           , legacyProperties    = [ Extension FPU
                                                   , Extension CMOV
                                                   ]
                           , legacyParams        = [ reg (R_ST 0) WO Implicit
                                                   , st RO
                                                   ]
                           }
                       ]
   }

i_fcmovnu :: X86Insn
i_fcmovnu = insn
   { insnDesc        = "Floating-point conditional move"
   , insnMnemonic    = "FCMOVNU"
   , insnFlags       = [ Read [PF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDB
                           , legacyOpcodeExt     = Just 3
                           , legacyProperties    = [ Extension FPU
                                                   , Extension CMOV
                                                   ]
                           , legacyParams        = [ reg (R_ST 0) WO Implicit
                                                   , st RO
                                                   ]
                           }
                       ]
   }

i_fcom :: X86Insn
i_fcom = insn
   { insnDesc        = "Compare floating point values"
   , insnMnemonic    = "FCOM"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD8
                           , legacyOpcodeExt     = Just 2
                           , legacyFPUSizable    = Just 2
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RO Implicit
                                                   , mst RO
                                                   ]
                           }
                       ]
   }

i_fcomp :: X86Insn
i_fcomp = insn
   { insnDesc        = "Compare floating point values and pop"
   , insnMnemonic    = "FCOMP"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD8
                           , legacyOpcodeExt     = Just 3
                           , legacyFPUSizable    = Just 2
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RO Implicit
                                                   , mst RO
                                                   ]
                           }
                       ]
   }

i_fcompp :: X86Insn
i_fcompp = insn
   { insnDesc        = "Compare floating point values and pop twice"
   , insnMnemonic    = "FCOMPP"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDE
                           , legacyOpcodeFullExt = Just 0xD9
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RO Implicit
                                                   , reg (R_ST 1) RO Implicit
                                                   ]
                           }
                       ]
   }

i_fcomi :: X86Insn
i_fcomi = insn
   { insnDesc        = "Compare floating point values and set eflags"
   , insnMnemonic    = "FCOMI"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDB
                           , legacyOpcodeExt     = Just 6
                           , legacyFPUPop        = Just 2   -- FCOMIP
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RO Implicit
                                                   , st RO
                                                   ]
                           }
                       ]
   }

i_fucomi :: X86Insn
i_fucomi = insn
   { insnDesc        = "Compare floating point values and set eflags"
   , insnMnemonic    = "FUCOMI"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDB
                           , legacyOpcodeExt     = Just 5
                           , legacyFPUPop        = Just 2   -- FUCOMIP
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RO Implicit
                                                   , st RO
                                                   ]
                           }
                       ]
   }

i_fcos :: X86Insn
i_fcos = insn
   { insnDesc        = "Cosine"
   , insnMnemonic    = "FCOS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeFullExt = Just 0xff
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RW Implicit ]
                           }
                       ]
   }

i_fdecstp :: X86Insn
i_fdecstp = insn
   { insnDesc        = "Decrement stack-top pointer"
   , insnMnemonic    = "FDECSTP"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeFullExt = Just 0xf6
                           , legacyProperties    = [ Extension FPU ]
                           }
                       ]
   }

i_fdiv :: X86Insn
i_fdiv = insn
   { insnDesc        = "Divide ST(O)"
   , insnMnemonic    = "FDIV"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD8
                           , legacyOpcodeExt     = Just 6
                           , legacyFPUSizable    = Just 2
                           , legacyFPUDest       = Just 2
                           , legacyFPUPop        = Just 1
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RW Implicit
                                                   , mst RO
                                                   ]
                           }
                       ]
   }

i_fidiv :: X86Insn
i_fidiv = insn
   { insnDesc        = "Divide ST(0)"
   , insnMnemonic    = "FIDIV"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDA
                           , legacyOpcodeExt     = Just 6
                           , legacyFPUSizable    = Just 2
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RW Implicit
                                                   , mint RO
                                                   ]
                           }
                       ]
   }


i_fdivr :: X86Insn
i_fdivr = insn
   { insnDesc        = "Divide by ST(0)"
   , insnMnemonic    = "FDIVR"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD8
                           , legacyOpcodeExt     = Just 7
                           , legacyFPUSizable    = Just 2
                           , legacyFPUDest       = Just 2
                           , legacyFPUPop        = Just 1
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RW Implicit
                                                   , mst RO
                                                   ]
                           }
                       ]
   }

i_fidivr :: X86Insn
i_fidivr = insn
   { insnDesc        = "Divide by ST(0)"
   , insnMnemonic    = "FIDIVR"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDA
                           , legacyOpcodeExt     = Just 7
                           , legacyFPUSizable    = Just 2
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RW Implicit
                                                   , mint RO
                                                   ]
                           }
                       ]
   }

i_ffree :: X86Insn
i_ffree = insn
   { insnDesc        = "Free floating-point register"
   , insnMnemonic    = "FFREE"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDD
                           , legacyOpcodeExt     = Just 0
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ st NA ]
                           }
                       ]
   }

i_ficom :: X86Insn
i_ficom = insn
   { insnDesc        = "Compare integer"
   , insnMnemonic    = "FICOM"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDA
                           , legacyOpcodeExt     = Just 2
                           , legacyFPUSizable    = Just 2
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RO Implicit
                                                   , mint RO
                                                   ]
                           }
                       ]
   }

i_ficomp :: X86Insn
i_ficomp = insn
   { insnDesc        = "Compare integer and pop"
   , insnMnemonic    = "FICOMP"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDA
                           , legacyOpcodeExt     = Just 3
                           , legacyFPUSizable    = Just 2
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RO Implicit
                                                   , mint RO
                                                   ]
                           }
                       ]
   }

i_fild :: X86Insn
i_fild = insn
   { insnDesc        = "Load integer"
   , insnMnemonic    = "FILD"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDB
                           , legacyOpcodeExt     = Just 0
                           , legacyFPUSizable    = Just 2
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ mint RO ]
                           }
                       , leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDF
                           , legacyOpcodeExt     = Just 5
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ mint64 RO ]
                           }
                       ]
   }

i_fincstp :: X86Insn
i_fincstp = insn
   { insnDesc        = "Increment stack-top pointer"
   , insnMnemonic    = "FINCSTP"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeFullExt = Just 0xf7
                           , legacyProperties    = [ Extension FPU ]
                           }
                       ]
   }

i_finit :: X86Insn
i_finit = insn
   { insnDesc        = "Initialize floating-point unit"
   , insnMnemonic    = "FINIT"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDB
                           , legacyOpcodeFullExt = Just 0xE3
                           , legacyProperties    = [ Extension FPU ]
                           }
                       ]
   }

i_fist :: X86Insn
i_fist = insn
   { insnDesc        = "Store integer"
   , insnMnemonic    = "FIST"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDB
                           , legacyOpcodeExt     = Just 2
                           , legacyFPUSizable    = Just 2
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RO Implicit
                                                   , mint WO
                                                   ]
                           }
                       ]
   }

i_fistp :: X86Insn
i_fistp = insn
   { insnDesc        = "Store integer and pop"
   , insnMnemonic    = "FISTP"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDB
                           , legacyOpcodeExt     = Just 3
                           , legacyFPUSizable    = Just 2
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RO Implicit
                                                   , mint WO
                                                   ]
                           }
                       , leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDF
                           , legacyOpcodeExt     = Just 7
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RO Implicit
                                                   , mint64 WO
                                                   ]
                           }
                       ]
   }

i_fisttp :: X86Insn
i_fisttp = insn
   { insnDesc        = "Store integer with truncation and pop"
   , insnMnemonic    = "FISTTP"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDB
                           , legacyOpcodeExt     = Just 1
                           , legacyFPUSizable    = Just 2
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RO Implicit
                                                   , mint WO
                                                   ]
                           }
                       , leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDD
                           , legacyOpcodeExt     = Just 1
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RO Implicit
                                                   , mint64 WO
                                                   ]
                           }
                       ]
   }

i_fld :: X86Insn
i_fld = insn
   { insnDesc        = "Load floating-point value"
   , insnMnemonic    = "FLD"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeExt     = Just 0
                           , legacyFPUSizable    = Just 2
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) WO Implicit
                                                   , mst RO
                                                   ]
                           }
                       , leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDB
                           , legacyOpcodeExt     = Just 5
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) WO Implicit
                                                   , mfp80 RO
                                                   ]
                           }
                       ]
   }

i_fld1 :: X86Insn
i_fld1 = insn
   { insnDesc        = "Load constant +1.0"
   , insnMnemonic    = "FLD1"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeFullExt = Just 0xE8
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) WO Implicit ]
                           }
                       ]
   }

i_fldl2t :: X86Insn
i_fldl2t = insn
   { insnDesc        = "Load constant log2(10)"
   , insnMnemonic    = "FLDL2T"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeFullExt = Just 0xE9
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) WO Implicit ]
                           }
                       ]
   }

i_fldl2e :: X86Insn
i_fldl2e = insn
   { insnDesc        = "Load constant log2(e)"
   , insnMnemonic    = "FLDL2E"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeFullExt = Just 0xEA
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) WO Implicit ]
                           }
                       ]
   }

i_fldpi :: X86Insn
i_fldpi = insn
   { insnDesc        = "Load constant pi"
   , insnMnemonic    = "FLDPI"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeFullExt = Just 0xEB
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) WO Implicit ]
                           }
                       ]
   }

i_fldlg2 :: X86Insn
i_fldlg2 = insn
   { insnDesc        = "Load constant log10(2)"
   , insnMnemonic    = "FLDLG2"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeFullExt = Just 0xEC
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) WO Implicit ]
                           }
                       ]
   }


i_fldln2 :: X86Insn
i_fldln2 = insn
   { insnDesc        = "Load constant log_e(2)"
   , insnMnemonic    = "FLDLN2"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeFullExt = Just 0xED
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) WO Implicit ]
                           }
                       ]
   }


i_fldz :: X86Insn
i_fldz = insn
   { insnDesc        = "Load constant +0.0"
   , insnMnemonic    = "FLDZ"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeFullExt = Just 0xEE
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) WO Implicit ]
                           }
                       ]
   }

i_fldcw :: X86Insn
i_fldcw = insn
   { insnDesc        = "Load x87 FPU control word"
   , insnMnemonic    = "FLDCW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeExt     = Just 5
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ mem16 RO ]
                           }
                       ]
   }


i_fldenv :: X86Insn
i_fldenv = insn
   { insnDesc        = "Load x87 FPU environment"
   , insnMnemonic    = "FLDENV"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeExt     = Just 4
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ menv RO ]
                           }
                       ]
   }

i_fmul :: X86Insn
i_fmul = insn
   { insnDesc        = "Multiply"
   , insnMnemonic    = "FMUL"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD8
                           , legacyOpcodeExt     = Just 1
                           , legacyFPUSizable    = Just 2
                           , legacyFPUDest       = Just 2
                           , legacyFPUPop        = Just 1
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RW Implicit
                                                   , mst RO
                                                   ]
                           }
                       ]
   }

i_fimul :: X86Insn
i_fimul = insn
   { insnDesc        = "Multiply"
   , insnMnemonic    = "FIMUL"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDA
                           , legacyOpcodeExt     = Just 1
                           , legacyFPUSizable    = Just 2
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RW Implicit
                                                   , mint RO
                                                   ]
                           }
                       ]
   }


i_fnop :: X86Insn
i_fnop = insn
   { insnDesc        = "No operation"
   , insnMnemonic    = "FNOP"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeFullExt = Just 0xD0
                           , legacyProperties    = [ Extension FPU ]
                           }
                       ]
   }

i_fpatan :: X86Insn
i_fpatan = insn
   { insnDesc        = "Partial arctangent"
   , insnMnemonic    = "FPATAN"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeFullExt = Just 0xF3
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RW Implicit
                                                   , reg (R_ST 1) RO Implicit
                                                   ]
                           }
                       ]
   }

i_fprem :: X86Insn
i_fprem = insn
   { insnDesc        = "Partial remainder"
   , insnMnemonic    = "FPREM"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeFullExt = Just 0xF8
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RW Implicit
                                                   , reg (R_ST 1) RO Implicit
                                                   ]
                           }
                       ]
   }

i_fprem1 :: X86Insn
i_fprem1 = insn
   { insnDesc        = "Partial remainder"
   , insnMnemonic    = "FPREM1"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeFullExt = Just 0xF5
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RW Implicit
                                                   , reg (R_ST 1) RO Implicit
                                                   ]
                           }
                       ]
   }

i_fptan :: X86Insn
i_fptan = insn
   { insnDesc        = "Partial tangent"
   , insnMnemonic    = "FPTAN"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeFullExt = Just 0xF2
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RW Implicit
                                                   , reg (R_ST 1) RW Implicit
                                                   ]
                           }
                       ]
   }

i_frndint :: X86Insn
i_frndint = insn
   { insnDesc        = "Round to integer"
   , insnMnemonic    = "FRNDINT"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeFullExt = Just 0xFC
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RW Implicit ]
                           }
                       ]
   }

i_frstor :: X86Insn
i_frstor = insn
   { insnDesc        = "Restore x87 FPU state"
   , insnMnemonic    = "FRSTOR"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDD
                           , legacyOpcodeExt     = Just 4
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ mFPUstate RO ]
                           }
                       ]
   }

i_fnsave :: X86Insn
i_fnsave = insn
   { insnDesc        = "Store x87 FPU state"
   , insnMnemonic    = "FNSAVE"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDD
                           , legacyOpcodeExt     = Just 6
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ mFPUstate WO ]
                           }
                       ]
   }

i_fscale :: X86Insn
i_fscale = insn
   { insnDesc        = "Scale"
   , insnMnemonic    = "FSCALE"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeFullExt = Just 0xFD
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RW Implicit
                                                   , reg (R_ST 1) RO Implicit
                                                   ]
                           }
                       ]
   }

i_fsin :: X86Insn
i_fsin = insn
   { insnDesc        = "Sine"
   , insnMnemonic    = "FSIN"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeFullExt = Just 0xfe
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RW Implicit ]
                           }
                       ]
   }

i_fsincos :: X86Insn
i_fsincos = insn
   { insnDesc        = "Sine and cosine"
   , insnMnemonic    = "FSINCOS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeFullExt = Just 0xfb
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RW Implicit
                                                   , reg (R_ST 1) WO Implicit
                                                   ]
                           }
                       ]
   }

i_fsqrt :: X86Insn
i_fsqrt = insn
   { insnDesc        = "Square root"
   , insnMnemonic    = "FSQRT"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeFullExt = Just 0xfa
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RW Implicit ]
                           }
                       ]
   }

i_fst :: X86Insn
i_fst = insn
   { insnDesc        = "Store floating-point value"
   , insnMnemonic    = "FST"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeExt     = Just 2
                           , legacyFPUSizable    = Just 2
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RO Implicit
                                                   , mst WO
                                                   ]
                           }
                       ]
   }

i_fstp :: X86Insn
i_fstp = insn
   { insnDesc        = "Store floating-point value and pop"
   , insnMnemonic    = "FSTP"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeExt     = Just 3
                           , legacyFPUSizable    = Just 2
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RO Implicit
                                                   , mst WO
                                                   ]
                           }
                       , leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDB
                           , legacyOpcodeExt     = Just 7
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RO Implicit
                                                   , mfp80 WO
                                                   ]
                           }
                       , leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDD
                           , legacyOpcodeExt     = Just 3
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RO Implicit
                                                   , st WO
                                                   ]
                           }
                       ]
   }

i_fnstcw :: X86Insn
i_fnstcw = insn
   { insnDesc        = "Store x87 FPU control word"
   , insnMnemonic    = "FNSTCW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeExt     = Just 7
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ mem16 WO ]
                           }
                       ]
   }


i_fnstenv :: X86Insn
i_fnstenv = insn
   { insnDesc        = "Store x87 FPU environment"
   , insnMnemonic    = "FNSTENV"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeExt     = Just 6
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ menv WO ]
                           }
                       ]
   }


i_fnstsw :: X86Insn
i_fnstsw = insn
   { insnDesc        = "Store x87 FPU status word"
   , insnMnemonic    = "FNSTSW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDD
                           , legacyOpcodeExt     = Just 7
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ mem16 WO ]
                           }
                        , leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDF
                           , legacyOpcodeFullExt = Just 0xE0
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg R_AX RO Implicit ]
                           }
                       ]
   }

i_fsub :: X86Insn
i_fsub = insn
   { insnDesc        = "Subtract from ST(O)"
   , insnMnemonic    = "FSUB"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD8
                           , legacyOpcodeExt     = Just 4
                           , legacyFPUSizable    = Just 2
                           , legacyFPUDest       = Just 2
                           , legacyFPUPop        = Just 1
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RW Implicit
                                                   , mst RO
                                                   ]
                           }
                       ]
   }

i_fisub :: X86Insn
i_fisub = insn
   { insnDesc        = "Subtract from ST(0)"
   , insnMnemonic    = "FISUB"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDA
                           , legacyOpcodeExt     = Just 4
                           , legacyFPUSizable    = Just 2
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RW Implicit
                                                   , mint RO
                                                   ]
                           }
                       ]
   }

i_fsubr :: X86Insn
i_fsubr = insn
   { insnDesc        = "Subtract ST(0)"
   , insnMnemonic    = "FSUBR"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD8
                           , legacyOpcodeExt     = Just 5
                           , legacyFPUSizable    = Just 2
                           , legacyFPUDest       = Just 2
                           , legacyFPUPop        = Just 1
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RW Implicit
                                                   , mst RO
                                                   ]
                           }
                       ]
   }

i_fisubr :: X86Insn
i_fisubr = insn
   { insnDesc        = "Subtract ST(0)"
   , insnMnemonic    = "FISUBR"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDA
                           , legacyOpcodeExt     = Just 5
                           , legacyFPUSizable    = Just 2
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RW Implicit
                                                   , mint RO
                                                   ]
                           }
                       ]
   }

i_ftst :: X86Insn
i_ftst = insn
   { insnDesc        = "Test"
   , insnMnemonic    = "FTST"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeFullExt = Just 0xE4
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RO Implicit ]
                           }
                       ]
   }

i_fucom :: X86Insn
i_fucom = insn
   { insnDesc        = "Unordered compare floating point values"
   , insnMnemonic    = "FUCOM"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDD
                           , legacyOpcodeExt     = Just 4
                           , legacyFPUSizable    = Just 2
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RO Implicit
                                                   , st RO
                                                   ]
                           }
                       ]
   }

i_fucomp :: X86Insn
i_fucomp = insn
   { insnDesc        = "Unordered compare floating point values and pop"
   , insnMnemonic    = "FUCOMP"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDD
                           , legacyOpcodeExt     = Just 5
                           , legacyFPUSizable    = Just 2
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RO Implicit
                                                   , st RO
                                                   ]
                           }
                       ]
   }

i_fucompp :: X86Insn
i_fucompp = insn
   { insnDesc        = "Unorderd compare floating point values and pop twice"
   , insnMnemonic    = "FUCOMPP"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xDA
                           , legacyOpcodeFullExt = Just 0xE9
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RO Implicit
                                                   , reg (R_ST 1) RO Implicit
                                                   ]
                           }
                       ]
   }


i_fxam :: X86Insn
i_fxam = insn
   { insnDesc        = "Examine (classify)"
   , insnMnemonic    = "FXAM"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeFullExt = Just 0xE5
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RO Implicit ]
                           }
                       ]
   }


i_fxch :: X86Insn
i_fxch = insn
   { insnDesc        = "Exchange register contents"
   , insnMnemonic    = "FXCH"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeExt     = Just 1
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RW Implicit
                                                   , st RW
                                                   ]
                           }
                       ]
   }

i_fxrstor :: X86Insn
i_fxrstor = insn
   { insnDesc        = "Restore x87 FPU, MMX, XMM, and MXCSR state"
   , insnMnemonic    = "FXRSTOR"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = Map0F
                           , legacyOpcode        = 0xAE
                           , legacyOpcodeExt     = Just 1
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ mem512 RO ]
                           }
                       ]
   }

i_fxrstor64 :: X86Insn
i_fxrstor64 = insn
   { insnDesc        = "Restore x87 FPU, MMX, XMM, and MXCSR state"
   , insnMnemonic    = "FXRSTOR64"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = Map0F
                           , legacyOpcode        = 0xAE
                           , legacyOpcodeExt     = Just 1
                           , legacyProperties    = [ Extension FPU
                                                   , RequireRexW
                                                   ]
                           , legacyParams        = [ mem512 RO ]
                           }
                       ]
   }

i_fxsave :: X86Insn
i_fxsave = insn
   { insnDesc        = "Save x87 FPU, MMX, XMM, and MXCSR state"
   , insnMnemonic    = "FXSAVE"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = Map0F
                           , legacyOpcode        = 0xAE
                           , legacyOpcodeExt     = Just 0
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ mem512 WO ]
                           }
                       ]
   }

i_fxsave64 :: X86Insn
i_fxsave64 = insn
   { insnDesc        = "Restore x87 FPU, MMX, XMM, and MXCSR state"
   , insnMnemonic    = "FXSAVE64"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = Map0F
                           , legacyOpcode        = 0xAE
                           , legacyOpcodeExt     = Just 0
                           , legacyProperties    = [ Extension FPU
                                                   , RequireRexW
                                                   ]
                           , legacyParams        = [ mem512 WO ]
                           }
                       ]
   }


i_fxtract :: X86Insn
i_fxtract = insn
   { insnDesc        = "Extract exponent and significand"
   , insnMnemonic    = "FXTRACT"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeFullExt = Just 0xF4
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RW Implicit
                                                   , reg (R_ST 1) WO Implicit
                                                   ]
                           }
                       ]
   }

i_fyl2x :: X86Insn
i_fyl2x = insn
   { insnDesc        = "Compute y * log_2(x)"
   , insnMnemonic    = "FYL2X"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeFullExt = Just 0xF1
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RW Implicit
                                                   , reg (R_ST 1) RO Implicit
                                                   ]
                           }
                       ]
   }

i_fyl2xp1 :: X86Insn
i_fyl2xp1 = insn
   { insnDesc        = "Compute y * log_2(x+1)"
   , insnMnemonic    = "FYL2XP1"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = MapPrimary
                           , legacyOpcode        = 0xD9
                           , legacyOpcodeFullExt = Just 0xF9
                           , legacyProperties    = [ Extension FPU ]
                           , legacyParams        = [ reg (R_ST 0) RW Implicit
                                                   , reg (R_ST 1) RO Implicit
                                                   ]
                           }
                       ]
   }

i_haddpd :: X86Insn
i_haddpd = insn
   { insnDesc        = "Packed double-FP horizontal add"
   , insnMnemonic    = "HADDPD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x7C
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE3
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vhaddpd :: X86Insn
i_vhaddpd = insn
   { insnDesc        = "Packed double-FP horizontal add"
   , insnMnemonic    = "VHADDPD"
   , insnProperties  = [ MemAlign 16 ]
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x7C
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_haddps :: X86Insn
i_haddps = insn
   { insnDesc        = "Packed single-FP horizontal add"
   , insnMnemonic    = "HADDPS"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF2
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x7C
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE3
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vhaddps :: X86Insn
i_vhaddps = insn
   { insnDesc        = "Packed single-FP horizontal add"
   , insnMnemonic    = "VHADDPS"
   , insnProperties  = [ MemAlign 16 ]
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0xF2
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x7C
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }

i_hlt :: X86Insn
i_hlt = insn
   { insnDesc        = "Halt"
   , insnMnemonic    = "HLT"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0xF4
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           }
                       ]
   }

i_hsubpd :: X86Insn
i_hsubpd = insn
   { insnDesc        = "Packed double-FP horizontal subtract"
   , insnMnemonic    = "HSUBPD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x7D
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE3
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vhsubpd :: X86Insn
i_vhsubpd = insn
   { insnDesc        = "Packed double-FP horizontal subtract"
   , insnMnemonic    = "VHSUBPD"
   , insnProperties  = [ MemAlign 16 ]
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x7D
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_hsubps :: X86Insn
i_hsubps = insn
   { insnDesc        = "Packed single-FP horizontal subtract"
   , insnMnemonic    = "HSUBPS"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF2
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x7D
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE3
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vhsubps :: X86Insn
i_vhsubps = insn
   { insnDesc        = "Packed single-FP horizontal subtract"
   , insnMnemonic    = "VHSUBPS"
   , insnProperties  = [ MemAlign 16 ]
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0xF2
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x7D
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }

i_idiv :: X86Insn
i_idiv = insn
   { insnDesc        = "Signed divide"
   , insnMnemonic    = "IDIV"
   , insnProperties  = [FailOnZero 0]
   , insnFlags       = [Undefined [CF,OF,SF,ZF,AF,PF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xF6
                           , legacyOpcodeExt       = Just 7
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ regFam RegFamDXAX RW Implicit
                                                     , mgpr RO
                                                     ]
                           }
                       ]
   }

i_imul :: X86Insn
i_imul = insn
   { insnDesc        = "Signed multiply"
   , insnMnemonic    = "IMUL"
   , insnFlags       = [ Modified  [OF,CF]
                       , Undefined [SF,ZF,AF,PF]
                       ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xF6
                           , legacyOpcodeExt       = Just 5
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ regFam RegFamDXAX WO Implicit
                                                     , regAccu RO
                                                     , mgpr RO
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xAF
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ gpr RW Reg
                                                     , mgpr RO
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x69
                           , legacySignExtendable  = Just 1
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ gpr RW Reg
                                                     , mgpr RO
                                                     , immSE
                                                     ]
                           }
                       ]
   }

i_in :: X86Insn
i_in = insn
   { insnDesc        = "Input from port"
   , insnMnemonic    = "IN"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xE4
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , NoOperandSize64
                                                     ]
                           , legacyParams          = [ regAccu WO
                                                     , imm8
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xEC
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , NoOperandSize64
                                                     ]
                           , legacyParams          = [ regAccu WO
                                                     , reg R_DX RO Implicit
                                                     ]
                           }

                       ]
   }

i_inc :: X86Insn
i_inc = insn
   { insnDesc        = "Increment by 1"
   , insnMnemonic    = "INC"
   , insnFlags       = [ Modified [OF,SF,ZF,AF,PF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xFE
                           , legacyOpcodeExt       = Just 0
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ Lockable
                                                     , LegacyModeSupport
                                                     , LongModeSupport
                                                     , HLE XBoth
                                                     ]
                           , legacyParams          = [ mgpr RW ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x40
                           , legacyProperties      = [ LegacyModeSupport
                                                     , Lockable
                                                     ]
                           , legacyParams          = [ gpr RW OpcodeLow3 ]
                           }
                       ]
   }

i_ins :: X86Insn
i_ins = insn
   { insnDesc        = "Input from port to string"
   , insnMnemonic    = "INS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x6C
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , DefaultAddressSize64
                                                     , NoOperandSize64
                                                     , Repeatable
                                                     ]
                           , legacyParams          = [ mESrDI WO  
                                                     , reg R_DX RO Implicit
                                                     ]
                           }
                       ]
   }

i_insertps :: X86Insn
i_insertps = insn
   { insnDesc        = "Insert packed single precision floating-point value"
   , insnMnemonic    = "INSERTPS"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F3A
                           , legacyOpcode          = 0x21
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     , imm8
                                                     ]
                           }
                       ]
   }

i_vinsertps :: X86Insn
i_vinsertps = insn
   { insnDesc        = "Insert packed single precision floating-point value"
   , insnMnemonic    = "VINSERTPS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x03
                           , vexOpcode          = 0x21
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128 WO Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128 RO
                                                  , imm8
                                                  ]
                           }
                       ]
   }

i_int :: X86Insn
i_int = insn
   { insnDesc        = "Call to interrupt procedure"
   , insnMnemonic    = "INT"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xCC
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ constImm 3 ]
                           }
                        , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xCD
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ imm8 ]
                           }
                       ]
   }

i_into :: X86Insn
i_into = insn
   { insnDesc        = "Call to interrupt procedure if overflow"
   , insnMnemonic    = "INTO"
   , insnFlags       = [ Read [OF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xCE
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ constImm 3 ]
                           }
                       ]
   }

i_invd :: X86Insn
i_invd = insn
   { insnDesc        = "Invalid internal caches"
   , insnMnemonic    = "INVD"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x08
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Arch Intel486
                                                     ]
                           }
                       ]
   }

i_invlpg :: X86Insn
i_invlpg = insn
   { insnDesc        = "Invalid TLB entry"
   , insnMnemonic    = "INVLPG"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x01
                           , legacyOpcodeExt       = Just 7
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Arch Intel486
                                                     ]
                           , legacyParams          = [ mvoid ]
                           }
                       ]
   }

i_invpcid :: X86Insn
i_invpcid = insn
   { insnDesc        = "Invalid process-context identifier"
   , insnMnemonic    = "INVPCID"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x82
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension INVPCID
                                                     ]
                           , legacyParams          = [ reg32o64 WO Reg
                                                     , mem128 RO
                                                     ]
                           }
                       ]
   }

i_iret :: X86Insn
i_iret = insn
   { insnDesc        = "Interrupt return"
   , insnMnemonic    = "IRET"
   , insnFlags       = [ Undefined allFlags ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xCF
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           }
                       ]
   }

i_ja :: X86Insn
i_ja = insn
   { insnDesc        = "Jump if above"
   , insnMnemonic    = "JA/JNBE"
   , insnFlags       = [ Read [CF,ZF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x77
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ rel8 ]
                           }
                        , leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x87
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ rel16o32 ]
                           }
                       ]
   }

i_jae :: X86Insn
i_jae = insn
   { insnDesc        = "Jump if above or equal"
   , insnMnemonic    = "JAE/JNB/JNC"
   , insnFlags       = [ Read [CF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x73
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ rel8 ]
                           }
                        , leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x83
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ rel16o32 ]
                           }
                       ]
   }

i_jb :: X86Insn
i_jb = insn
   { insnDesc        = "Jump if below"
   , insnMnemonic    = "JB/JC/JNAE"
   , insnFlags       = [ Read [CF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x72
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ rel8 ]
                           }
                        , leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x82
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ rel16o32 ]
                           }
                       ]
   }

i_jbe :: X86Insn
i_jbe = insn
   { insnDesc        = "Jump if below or equal"
   , insnMnemonic    = "JBE/JNA"
   , insnFlags       = [ Read [CF,ZF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x76
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ rel8 ]
                           }
                        , leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x86
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ rel16o32 ]
                           }
                       ]
   }


i_jcxz :: X86Insn
i_jcxz = insn
   { insnDesc        = "Jump if rCX is 0"
   , insnMnemonic    = "JCXZ"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xE3
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ regCounter RO
                                                     , rel8
                                                     ]
                           }
                       ]
   }

i_je :: X86Insn
i_je = insn
   { insnDesc        = "Jump if equal"
   , insnMnemonic    = "JE/JZ"
   , insnFlags       = [ Read [ZF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x74
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ rel8 ]
                           }
                        , leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x84
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ rel16o32 ]
                           }
                       ]
   }

i_jg :: X86Insn
i_jg = insn
   { insnDesc        = "Jump if greater"
   , insnMnemonic    = "JG/JNLE"
   , insnFlags       = [ Read [ZF,SF,OF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x7F
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ rel8 ]
                           }
                        , leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x8F
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ rel16o32 ]
                           }
                       ]
   }

i_jge :: X86Insn
i_jge = insn
   { insnDesc        = "Jump if greater or equal"
   , insnMnemonic    = "JGE/JNL"
   , insnFlags       = [ Read [SF,OF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x7D
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ rel8 ]
                           }
                        , leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x8D
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ rel16o32 ]
                           }
                       ]
   }

i_jl :: X86Insn
i_jl = insn
   { insnDesc        = "Jump if less"
   , insnMnemonic    = "JL/JNGE"
   , insnFlags       = [ Read [SF,OF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x7C
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ rel8 ]
                           }
                        , leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x8C
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ rel16o32 ]
                           }
                       ]
   }

i_jle :: X86Insn
i_jle = insn
   { insnDesc        = "Jump if less or equal"
   , insnMnemonic    = "JLE/JNG"
   , insnFlags       = [ Read [ZF,SF,OF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x7E
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ rel8 ]
                           }
                        , leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x8E
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ rel16o32 ]
                           }
                       ]
   }

i_jne :: X86Insn
i_jne = insn
   { insnDesc        = "Jump if not equal"
   , insnMnemonic    = "JNE/JNZ"
   , insnFlags       = [ Read [ZF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x75
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ rel8 ]
                           }
                        , leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x85
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ rel16o32 ]
                           }
                       ]
   }

i_jno :: X86Insn
i_jno = insn
   { insnDesc        = "Jump if not overflow"
   , insnMnemonic    = "JNO"
   , insnFlags       = [ Read [OF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x71
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ rel8 ]
                           }
                        , leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x81
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ rel16o32 ]
                           }
                       ]
   }

i_jnp :: X86Insn
i_jnp = insn
   { insnDesc        = "Jump if not parity"
   , insnMnemonic    = "JNP/JPO"
   , insnFlags       = [ Read [PF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x7B
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ rel8 ]
                           }
                        , leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x8B
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ rel16o32 ]
                           }
                       ]
   }

i_jns :: X86Insn
i_jns = insn
   { insnDesc        = "Jump if not sign"
   , insnMnemonic    = "JNS"
   , insnFlags       = [ Read [SF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x79
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ rel8 ]
                           }
                        , leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x89
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ rel16o32 ]
                           }
                       ]
   }

i_jo :: X86Insn
i_jo = insn
   { insnDesc        = "Jump if overflow"
   , insnMnemonic    = "JO"
   , insnFlags       = [ Read [OF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x70
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ rel8 ]
                           }
                        , leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x80
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ rel16o32 ]
                           }
                       ]
   }

i_jp :: X86Insn
i_jp = insn
   { insnDesc        = "Jump if parity"
   , insnMnemonic    = "JP/JPE"
   , insnFlags       = [ Read [PF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x7A
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ rel8 ]
                           }
                        , leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x8A
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ rel16o32 ]
                           }
                       ]
   }

i_js :: X86Insn
i_js = insn
   { insnDesc        = "Jump if sign"
   , insnMnemonic    = "JS"
   , insnFlags       = [ Read [SF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x78
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ rel8 ]
                           }
                        , leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x88
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , BranchHintable
                                                     ]
                           , legacyParams          = [ rel16o32 ]
                           }
                       ]
   }

i_jmp :: X86Insn
i_jmp = insn
   { insnDesc        = "Jump"
   , insnMnemonic    = "JMP"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xEB
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ rel8 ]
                           }
                        , leg
                           { legacyOpcode          = 0xE9
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ rel16o32 ]
                           }
                        , leg
                           { legacyOpcode          = 0xFF
                           , legacyOpcodeExt       = Just 4
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mgpr RO ]
                           }
                        , leg
                           { legacyOpcode          = 0xEA
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ ptr16x ]
                           }
                        , leg
                           { legacyOpcode          = 0xFF
                           , legacyOpcodeExt       = Just 5
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ m16x ]
                           }
                       ]
   }

i_lahf :: X86Insn
i_lahf = insn
   { insnDesc        = "Load status flags into AH register"
   , insnMnemonic    = "LAHF"
   , insnFlags       = [ Read [SF,ZF,AF,PF,CF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x9F
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension LSAHF
                                                     ]
                           , legacyParams          = [ reg R_AH WO Implicit ]
                           }
                       ]
   }

i_lar :: X86Insn
i_lar = insn
   { insnDesc        = "Load access rights"
   , insnMnemonic    = "LAR"
   , insnFlags       = [ Modified [ZF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x02
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ gpr WO Reg
                                                     , mgpr RO
                                                     ]
                           }
                       ]
   }

i_lddqu :: X86Insn
i_lddqu = insn
   { insnDesc        = "Load unaligned integer 128 bits"
   , insnMnemonic    = "LDDQU"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF2
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xF0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE3
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mem128 RO
                                                     ]
                           }
                       ]
   }

i_vlddqu :: X86Insn
i_vlddqu = insn
   { insnDesc        = "Load unaligned integer 128 bits"
   , insnMnemonic    = "VLDDQU"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0xF2
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0xF0
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , m128o256 RO
                                                  ]
                           }
                       ]
   }

i_ldmxcsr :: X86Insn
i_ldmxcsr = insn
   { insnDesc        = "Load MXCSR register"
   , insnMnemonic    = "LDMXCSR"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xAE
                           , legacyOpcodeExt       = Just 2
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ mem32 RO ]
                           }
                       , vex
                           { vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0xAE
                           , vexOpcodeExt       = Just 2
                           , vexLW              = L0_WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ mem32 RO ]
                           }
                       ]
   }


i_ldfarptr :: X86Insn
i_ldfarptr = insn
   { insnDesc        = "Load far pointer"
   , insnMnemonic    = "LDS/LES/LFS/LGS/LSS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xC5
                           , legacyProperties      = [ LegacyModeSupport
                                                     , DefaultSegment R_DS
                                                     ]
                           , legacyParams          = [ gpr RO Reg
                                                     , m16x
                                                     ]
                           }
                       ,  leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xC4
                           , legacyProperties      = [ LegacyModeSupport
                                                     , DefaultSegment R_ES
                                                     ]
                           , legacyParams          = [ gpr RO Reg
                                                     , m16x
                                                     ]
                           }
                       ,  leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xB2
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , DefaultSegment R_SS
                                                     ]
                           , legacyParams          = [ gpr RO Reg
                                                     , m16x
                                                     ]
                           }
                       ,  leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xB4
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , DefaultSegment R_FS
                                                     ]
                           , legacyParams          = [ gpr RO Reg
                                                     , m16x
                                                     ]
                           }
                       ,  leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xB5
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , DefaultSegment R_GS
                                                     ]
                           , legacyParams          = [ gpr RO Reg
                                                     , m16x
                                                     ]
                           }
                       ]
   }

i_lea :: X86Insn
i_lea = insn
   { insnDesc        = "Load effective address"
   , insnMnemonic    = "LEA"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x8D
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , DefaultAddressSize64
                                                     ]
                           , legacyParams          = [ gpr WO Reg
                                                     , mvoid
                                                     ]
                           }
                       ]
   }

i_leave :: X86Insn
i_leave = insn
   { insnDesc        = "High level procedure exit"
   , insnMnemonic    = "LEAVE"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xC9
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ regStackPtr WO Implicit
                                                     , regBasePtr  RW Implicit
                                                     ]
                           }
                       ]
   }

i_lfence :: X86Insn
i_lfence = insn
   { insnDesc        = "Load fence"
   , insnMnemonic    = "LFENCE"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xAE
                           , legacyOpcodeExt       = Just 5
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           }
                       ]
   }

i_lgdt :: X86Insn
i_lgdt = insn
   { insnDesc        = "Load global descriptor table register"
   , insnMnemonic    = "LGDT"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x01
                           , legacyOpcodeExt       = Just 2
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mdt RO ]
                           }
                       ]
   }

i_lidt :: X86Insn
i_lidt = insn
   { insnDesc        = "Load interrupt descriptor table register"
   , insnMnemonic    = "LIDT"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x01
                           , legacyOpcodeExt       = Just 3
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mdt RO ]
                           }
                       ]
   }

i_lldt :: X86Insn
i_lldt = insn
   { insnDesc        = "Load local descriptor table register"
   , insnMnemonic    = "LLDT"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x00
                           , legacyOpcodeExt       = Just 2
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     -- TODO: not supported in
                                                     -- real/virtual mode
                                                     ]
                           , legacyParams          = [ rm16 RO ]
                           }
                       ]
   }

i_lmsw :: X86Insn
i_lmsw = insn
   { insnDesc        = "Load machine status word"
   , insnMnemonic    = "LMSW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x01
                           , legacyOpcodeExt       = Just 6
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ rm16 RO ]
                           }
                       ]
   }

i_lods :: X86Insn
i_lods = insn
   { insnDesc        = "Load string"
   , insnMnemonic    = "LODS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xAC
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Repeatable
                                                     ]
                           , legacyParams          = [ regAccu WO
                                                     , mDSrSI RO
                                                     ]
                           }
                       ]
   }

i_loop :: X86Insn
i_loop = insn
   { insnDesc        = "Loop according to rCX counter"
   , insnMnemonic    = "LOOP"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xE2
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ regCounter RW
                                                     , rel8
                                                     ]
                           }
                       ]
   }


i_loope :: X86Insn
i_loope = insn
   { insnDesc        = "Loop according to rCX counter and ZF"
   , insnMnemonic    = "LOOPE"
   , insnFlags       = [ Read [ZF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xE1
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ regCounter RW
                                                     , rel8
                                                     ]
                           }
                       ]
   }


i_loopne :: X86Insn
i_loopne = insn
   { insnDesc        = "Loop according to rCX counter and ZF"
   , insnMnemonic    = "LOOPNE"
   , insnFlags       = [ Read [ZF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xE0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ regCounter RW
                                                     , rel8
                                                     ]
                           }
                       ]
   }


i_lsl :: X86Insn
i_lsl = insn
   { insnDesc        = "Load segment limit"
   , insnMnemonic    = "LSL"
   , insnFlags       = [ Modified [ZF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x03
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ gpr RW Reg
                                                     , mgpr RO
                                                     ]
                           }
                       ]
   }


i_ltr :: X86Insn
i_ltr = insn
   { insnDesc        = "Load task register"
   , insnMnemonic    = "LTR"
   , insnFlags       = [ Modified [ZF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x00
                           , legacyOpcodeExt       = Just 3
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     -- TODO: invalid in
                                                     -- real/virtual modes
                                                     ]
                           , legacyParams          = [ rm16 RO ]
                           }
                       ]
   }

i_maskmovdqu :: X86Insn
i_maskmovdqu = insn
   { insnDesc        = "Store selected bytes of double quadword"
   , insnMnemonic    = "MASKMOVDQU"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xF7
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , vec128 RO RM
                                                     , mDSrDI RO
                                                     ]
                           }
                       ]
   }

i_vmaskmovdqu :: X86Insn
i_vmaskmovdqu = insn
   { insnDesc        = "Store selected bytes of double quadword"
   , insnMnemonic    = "VMASKMOVDQU"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xF7
                           , vexLW                 = WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO RM
                                                     , mDSrDI RO
                                                     ]
                           }
                       ]
   }


i_maskmovq :: X86Insn
i_maskmovq = insn
   { insnDesc        = "Store selected bytes of quadword"
   , insnMnemonic    = "MASKMOVQ"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xF7
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , vec64 RO RM
                                                     , mDSrDI RO
                                                     ]
                           }
                       ]
   }

i_maxpd :: X86Insn
i_maxpd = insn
   { insnDesc        = "Return maximum packed double-precision floating-point values"
   , insnMnemonic    = "MAXPD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x5F
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vmaxpd :: X86Insn
i_vmaxpd = insn
   { insnDesc        = "Return maximum packed double-precision floating-point values"
   , insnMnemonic    = "VMAXPD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x5F
                           , vexLW                 = WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128o256 WO Reg
                                                     , vec128o256 RO Vvvv
                                                     , mvec128o256 RO
                                                     ]
                           }
                       ]
   }

i_maxps :: X86Insn
i_maxps = insn
   { insnDesc        = "Return maximum packed single-precision floating-point values"
   , insnMnemonic    = "MAXPS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x5F
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vmaxps :: X86Insn
i_vmaxps = insn
   { insnDesc        = "Return maximum packed single-precision floating-point values"
   , insnMnemonic    = "VMAXPS"
   , insnEncodings   = [ vex
                           { vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x5F
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }

i_maxsd :: X86Insn
i_maxsd = insn
   { insnDesc        = "Return maximum scalar double-precision floating-point values"
   , insnMnemonic    = "MAXSD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF2
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x5F
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128low64 RO
                                                     ]
                           }
                       ]
   }

i_vmaxsd :: X86Insn
i_vmaxsd = insn
   { insnDesc        = "Return maximum scalar double-precision floating-point values"
   , insnMnemonic    = "VMAXSD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0xF2
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x5F
                           , vexLW              = LWIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128 WO Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low64 RO
                                                  ]
                           }
                       ]
   }

i_maxss :: X86Insn
i_maxss = insn
   { insnDesc        = "Return maximum scalar single-precision floating-point values"
   , insnMnemonic    = "MAXSS"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF3
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x5F
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128low32 RO
                                                     ]
                           }
                       ]
   }

i_vmaxss :: X86Insn
i_vmaxss = insn
   { insnDesc        = "Return maximum scalar single-precision floating-point values"
   , insnMnemonic    = "VMAXSS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0xF3
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x5F
                           , vexLW              = LWIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128 WO Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low32 RO
                                                  ]
                           }
                       ]
   }

i_mfence :: X86Insn
i_mfence = insn
   { insnDesc        = "Memory fence"
   , insnMnemonic    = "MFENCE"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xAE
                           , legacyOpcodeFullExt   = Just 0xF0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           }
                       ]
   }

i_minpd :: X86Insn
i_minpd = insn
   { insnDesc        = "Return minimum packed double-precision floating-point values"
   , insnMnemonic    = "MINPD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x5D
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vminpd :: X86Insn
i_vminpd = insn
   { insnDesc        = "Return minimum packed double-precision floating-point values"
   , insnMnemonic    = "VMINPD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x5D
                           , vexLW                 = WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128o256 WO Reg
                                                     , vec128o256 RO Vvvv
                                                     , mvec128o256 RO
                                                     ]
                           }
                       ]
   }

i_minps :: X86Insn
i_minps = insn
   { insnDesc        = "Return minimum packed single-precision floating-point values"
   , insnMnemonic    = "MINPS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x5D
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vminps :: X86Insn
i_vminps = insn
   { insnDesc        = "Return minimum packed single-precision floating-point values"
   , insnMnemonic    = "VMINPS"
   , insnEncodings   = [ vex
                           { vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x5D
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }

i_minsd :: X86Insn
i_minsd = insn
   { insnDesc        = "Return minimum scalar double-precision floating-point values"
   , insnMnemonic    = "MINSD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF2
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x5D
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128low64 RO
                                                     ]
                           }
                       ]
   }

i_vminsd :: X86Insn
i_vminsd = insn
   { insnDesc        = "Return minimum scalar double-precision floating-point values"
   , insnMnemonic    = "VMINSD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0xF2
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x5D
                           , vexLW              = LWIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128 WO Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low64 RO
                                                  ]
                           }
                       ]
   }

i_minss :: X86Insn
i_minss = insn
   { insnDesc        = "Return minimum scalar single-precision floating-point values"
   , insnMnemonic    = "MINSS"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF3
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x5D
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128low32 RO
                                                     ]
                           }
                       ]
   }

i_vminss :: X86Insn
i_vminss = insn
   { insnDesc        = "Return minimum scalar single-precision floating-point values"
   , insnMnemonic    = "VMINSS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0xF3
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x5D
                           , vexLW              = LWIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128 WO Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low32 RO
                                                  ]
                           }
                       ]
   }

i_monitor :: X86Insn
i_monitor = insn
   { insnDesc        = "Set up monitor address"
   , insnMnemonic    = "MONITOR"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = Map0F
                           , legacyOpcode        = 0x01
                           , legacyOpcodeFullExt = Just 0xC8
                           , legacyProperties    = [ LegacyModeSupport
                                                   , LongModeSupport
                                                   , Extension MONITOR
                                                   ]
                           , legacyParams          = [ reg R_ECX RO Implicit
                                                     , reg R_EDX RO Implicit
                                                     , op NA T_MemDSrAX Implicit
                                                     ]
                           }
                       ]
   }

i_mov :: X86Insn
i_mov = insn
   { insnDesc        = "Move"
   , insnMnemonic    = "MOV"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xA0
                           , legacyNoForce8bit     = Just 0
                           , legacyReversable      = Just 1
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ regAccu WO
                                                     , op    RO    T_MemOffset  Imm
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x88
                           , legacyNoForce8bit     = Just 0
                           , legacyReversable      = Just 1
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , HLE XRelease
                                                     ]
                           , legacyParams          = [ mgpr WO
                                                     , gpr RO Reg
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x8C
                           , legacyReversable      = Just 1
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mgpr WO
                                                     , op RO (T_Reg RegSegment) Reg
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xB0
                           , legacyNoForce8bit     = Just 3
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ gpr RW OpcodeLow3
                                                     , immOp
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xC6
                           , legacyOpcodeExt       = Just 0
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , HLE XRelease
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , immSE
                                                     ]
                           }
                       ]
   }

i_movcr :: X86Insn
i_movcr = insn
   { insnDesc        = "Move control register"
   , insnMnemonic    = "MOV"
   , insnFlags       = [ Undefined [OF,SF,ZF,AF,PF,CF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x20
                           , legacyReversable      = Just 1
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ op WO (T_Reg Reg32o64)   RM
                                                     , op RO (T_Reg RegControl) Reg
                                                     ]
                           }
                       ]
   }


i_movdr :: X86Insn
i_movdr = insn
   { insnDesc        = "Move debug register"
   , insnMnemonic    = "MOV"
   , insnFlags       = [ Undefined [OF,SF,ZF,AF,PF,CF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x21
                           , legacyReversable      = Just 1
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ op    WO (T_Reg Reg32o64) RM
                                                     , op    RO (T_Reg RegDebug) Reg
                                                     ]
                           }
                       ]
   }



i_movapd :: X86Insn
i_movapd = insn
   { insnDesc        = "Move aligned packed double-precision floating-point values"
   , insnMnemonic    = "MOVAPD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x28
                           , legacyReversable      = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vmovapd :: X86Insn
i_vmovapd = insn
   { insnDesc        = "Move aligned packed double-precision floating-point values"
   , insnMnemonic    = "VMOVAPD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x28
                           , vexReversable         = Just 0
                           , vexLW                 = WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128o256 WO Reg
                                                     , mvec128o256 RO
                                                     ]
                           }
                       ]
   }

i_movaps :: X86Insn
i_movaps = insn
   { insnDesc        = "Move aligned packed single-precision floating-point values"
   , insnMnemonic    = "MOVAPS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x28
                           , legacyReversable      = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vmovaps :: X86Insn
i_vmovaps = insn
   { insnDesc        = "Move aligned packed single-precision floating-point values"
   , insnMnemonic    = "VMOVAPS"
   , insnEncodings   = [ vex
                           { vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x28
                           , vexLW              = WIG
                           , vexReversable      = Just 0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }

i_movbe :: X86Insn
i_movbe = insn
   { insnDesc        = "Move data after swapping bytes"
   , insnMnemonic    = "MOVBE"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0xF0
                           , legacyReversable      = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ gpr WO Reg
                                                     , mem RO
                                                     ]
                           }
                       ]
   }

i_movdq :: X86Insn
i_movdq = insn
   { insnDesc        = "Move doubleword/quadword"
   , insnMnemonic    = "MOVD/MOVQ"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x6E
                           , legacyReversable      = Just 4
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 WO Reg
                                                     , rm32o64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x6E
                           , legacyReversable      = Just 4
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , rm32o64 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 1
                           , vexOpcode             = 0x6E
                           , vexReversable         = Just 4
                           , vexLW                 = L0
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , rm32o64 RO
                                                     ]
                           }
                       ]
   }

i_movddup :: X86Insn
i_movddup = insn
   { insnDesc        = "Move one double-FP and duplicate"
   , insnMnemonic    = "MOVDDUP"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF2
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x12
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE3
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128low64 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0xF2
                           , vexOpcodeMap          = MapVex 1
                           , vexOpcode             = 0x12
                           , vexLW                 = WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128o256 WO Reg
                                                     , mvecEven64 RO
                                                     ]
                           }
                       ]
   }

i_movdqa :: X86Insn
i_movdqa = insn
   { insnDesc        = "Move aligned doubleword/quadword"
   , insnMnemonic    = "MOVDQA/VMOVDQA"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x6F
                           , legacyReversable      = Just 4
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 1
                           , vexOpcode             = 0x6F
                           , vexReversable         = Just 4
                           , vexLW                 = WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128o256 WO Reg
                                                     , mvec128o256 RO
                                                     ]
                           }
                       ]
   }

i_movdqu :: X86Insn
i_movdqu = insn
   { insnDesc        = "Move unaligned doubleword/quadword"
   , insnMnemonic    = "MOVDQU/VMOVDQU"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF3
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x6F
                           , legacyReversable      = Just 4
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0xF3
                           , vexOpcodeMap          = MapVex 1
                           , vexOpcode             = 0x6F
                           , vexReversable         = Just 4
                           , vexLW                 = WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128o256 WO Reg
                                                     , mvec128o256 RO
                                                     ]
                           }
                       ]
   }

i_movdq2q :: X86Insn
i_movdq2q = insn
   { insnDesc        = "Move quadword from XMM to MMX register"
   , insnMnemonic    = "MOVDQ2Q"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF2
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xD6
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 WO Reg
                                                     , vec128low64 RO RM
                                                     ]
                           }
                       ]
   }

i_movhlps :: X86Insn
i_movhlps = insn
   { insnDesc        = "Move packed single-precision FP values high to low"
   , insnMnemonic    = "MOVHLPS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x12
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ vec128low64 WO Reg
                                                     , vec128high64 RO RM
                                                     ]
                           }
                        ]
   }

i_vmovhlps :: X86Insn
i_vmovhlps = insn
   { insnDesc        = "Move packed single-precision FP values high to low"
   , insnMnemonic    = "VMOVHLPS"
   , insnEncodings   = [ vex
                           { vexOpcodeMap          = MapVex 1
                           , vexOpcode             = 0x12
                           , vexLW                 = L0
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128low64 RO Vvvv
                                                     , vec128high64 RO RM
                                                     ]
                           }
                       ]
   }



i_movhpd :: X86Insn
i_movhpd = insn
   { insnDesc        = "Move high packed double-precision FP value"
   , insnMnemonic    = "MOVHPD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x16
                           , legacyReversable      = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128high64 WO Reg
                                                     , mem64 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 1
                           , vexOpcode             = 0x17
                           , vexLW                 = L0
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ mem64 WO
                                                     , vec128high64 RO Reg
                                                     ]
                           }
                       ]
   }

i_vmovhpd :: X86Insn
i_vmovhpd = insn
   { insnDesc        = "Move high packed double-precision FP value"
   , insnMnemonic    = "VMOVHPD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 1
                           , vexOpcode             = 0x16
                           , vexLW                 = L0
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128low64 RO Vvvv
                                                     , mem64 RO
                                                     ]
                           }
                       ]
   }


i_movhps :: X86Insn
i_movhps = insn
   { insnDesc        = "Move high packed single-precision FP values"
   , insnMnemonic    = "MOVHPS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x16
                           , legacyReversable      = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ vec128high64 WO Reg
                                                     , mem64 RO
                                                     ]
                           }
                       , vex
                           { vexOpcodeMap          = MapVex 1
                           , vexOpcode             = 0x17
                           , vexLW                 = L0
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ mem64 WO
                                                     , vec128high64 RO Reg
                                                     ]
                           }
                       ]
   }

i_vmovhps :: X86Insn
i_vmovhps = insn
   { insnDesc        = "Move high packed singke-precision FP values"
   , insnMnemonic    = "VMOVHPS"
   , insnEncodings   = [ vex
                           { vexOpcodeMap          = MapVex 1
                           , vexOpcode             = 0x16
                           , vexLW                 = L0
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128low64 RO Vvvv
                                                     , mem64 RO
                                                     ]
                           }
                       ]
   }


i_movlpd :: X86Insn
i_movlpd = insn
   { insnDesc        = "Move low packed double-precision FP value"
   , insnMnemonic    = "MOVLPD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x12
                           , legacyReversable      = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128low64 WO Reg
                                                     , mem64 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 1
                           , vexOpcode             = 0x13
                           , vexLW                 = L0
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ mem64 WO
                                                     , vec128low64 RO Reg
                                                     ]
                           }
                       ]
   }

i_vmovlpd :: X86Insn
i_vmovlpd = insn
   { insnDesc        = "Move low packed double-precision FP value"
   , insnMnemonic    = "VMOVLPD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 1
                           , vexOpcode             = 0x12
                           , vexLW                 = L0
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128high64 RO Vvvv
                                                     , mem64 RO
                                                     ]
                           }
                       ]
   }


i_movlps :: X86Insn
i_movlps = insn
   { insnDesc        = "Move low packed single-precision FP values"
   , insnMnemonic    = "MOVLPS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x12
                           , legacyReversable      = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ vec128low64 WO Reg
                                                     , mem64 RO
                                                     ]
                           }
                       , vex
                           { vexOpcodeMap          = MapVex 1
                           , vexOpcode             = 0x13
                           , vexLW                 = L0
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ mem64 WO
                                                     , vec128low64 RO Reg
                                                     ]
                           }
                       ]
   }

i_vmovlps :: X86Insn
i_vmovlps = insn
   { insnDesc        = "Move low packed singke-precision FP values"
   , insnMnemonic    = "VMOVLPS"
   , insnEncodings   = [ vex
                           { vexOpcodeMap          = MapVex 1
                           , vexOpcode             = 0x12
                           , vexLW                 = L0
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128high64 RO Vvvv
                                                     , mem64 RO
                                                     ]
                           }
                       ]
   }

i_movlhps :: X86Insn
i_movlhps = insn
   { insnDesc        = "Move packed single-precision FP values low ti high"
   , insnMnemonic    = "MOVLHPS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x16
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ vec128high64 WO Reg
                                                     , vec128low64 RO RM
                                                     ]
                           }
                        ]
   }

i_vmovlhps :: X86Insn
i_vmovlhps = insn
   { insnDesc        = "Move packed single-precision FP values low to high"
   , insnMnemonic    = "VMOVLHPS"
   , insnEncodings   = [ vex
                           { vexOpcodeMap          = MapVex 1
                           , vexOpcode             = 0x16
                           , vexLW                 = L0
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128high64 RO Vvvv
                                                     , vec128low64 RO RM
                                                     ]
                           }
                       ]
   }


i_movmskpd :: X86Insn
i_movmskpd = insn
   { insnDesc        = "Move packed double-precision FP sign mask"
   , insnMnemonic    = "MOVMSKPD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x50
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     , DefaultOperandSize64
                                                     ]
                           , legacyParams          = [ gpr WO Reg
                                                     , vec128 RO RM
                                                     ]
                           }
                        ]
   }

i_vmovmskpd :: X86Insn
i_vmovmskpd = insn
   { insnDesc        = "Move packed double-precision FP sign mask"
   , insnMnemonic    = "VMOVMSKPD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 1
                           , vexOpcode             = 0x50
                           , vexLW                 = WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     , DefaultOperandSize64
                                                     ]
                           , vexParams             = [ gpr WO Reg
                                                     , vec128o256 RO RM
                                                     ]
                           }
                       ]
   }


i_movmskps :: X86Insn
i_movmskps = insn
   { insnDesc        = "Move packed single-precision FP sign mask"
   , insnMnemonic    = "MOVMSKPS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x50
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     , DefaultOperandSize64
                                                     ]
                           , legacyParams          = [ gpr WO Reg
                                                     , vec128 RO RM
                                                     ]
                           }
                        ]
   }

i_vmovmskps :: X86Insn
i_vmovmskps = insn
   { insnDesc        = "Move packed single-precision FP sign mask"
   , insnMnemonic    = "VMOVMSKPS"
   , insnEncodings   = [ vex
                           { vexOpcodeMap          = MapVex 1
                           , vexOpcode             = 0x50
                           , vexLW                 = WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     , DefaultOperandSize64
                                                     ]
                           , vexParams             = [ gpr WO Reg
                                                     , vec128o256 RO RM
                                                     ]
                           }
                       ]
   }

i_movntdqa :: X86Insn
i_movntdqa = insn
   { insnDesc        = "Move aligned doubleword/quadword non temporal"
   , insnMnemonic    = "MOVNTDQA/VMOVNTDQA"
   , insnProperties  = [ MemAlignDefault ]
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x2A
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mem128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 2
                           , vexOpcode             = 0x2A
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , mem128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 2
                           , vexOpcode             = 0x2A
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , mem256 RO
                                                     ]
                           }
                       ]
   }


i_movntdq :: X86Insn
i_movntdq = insn
   { insnDesc        = "Store double quadword non temporal"
   , insnMnemonic    = "MOVNTDQ/VMOVNTDQ"
   , insnProperties  = [ MemAlignDefault ]
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xE7
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ mem128 WO
                                                     , vec128 RO Reg
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 1
                           , vexOpcode             = 0xE7
                           , vexLW                 = WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ mem128o256 WO
                                                     , vec128o256 RO Reg
                                                     ]
                           }
                       ]
   }


i_movnti :: X86Insn
i_movnti = insn
   { insnDesc        = "Store doubleword non temporal"
   , insnMnemonic    = "MOVNTI"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xC3
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mem32o64 WO
                                                     , reg32o64 RO Reg
                                                     ]
                           }
                       ]
   }

i_movntpd :: X86Insn
i_movntpd = insn
   { insnDesc        = "Move aligned packed double-precision FP values non temporal"
   , insnMnemonic    = "(V)MOVNTPD"
   , insnProperties  = [ MemAlignDefault ]
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x2B
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ mem128 WO
                                                     , vec128 RO Reg
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x2B
                           , vexLW                 = WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ mem128o256 WO
                                                     , vec128o256 RO Reg
                                                     ]
                           }
                       ]
   }

i_movntps :: X86Insn
i_movntps = insn
   { insnDesc        = "Move aligned packed single-precision FP values non temporal"
   , insnMnemonic    = "MOVNTPS"
   , insnProperties  = [ MemAlignDefault ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x2B
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ mem128 WO
                                                     , vec128 RO Reg
                                                     ]
                           }
                       , vex
                           { vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x2B
                           , vexLW              = WIG
                           , vexReversable      = Just 0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ mem128o256 WO
                                                  , vec128o256 RO Reg
                                                  ]
                           }
                       ]
   }

i_movntq :: X86Insn
i_movntq = insn
   { insnDesc        = "Store quadword non temporal"
   , insnMnemonic    = "MOVNTQ"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xE7
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ mem64 WO
                                                     , vec64 RO Reg
                                                     ]
                           }
                       ]
   }

i_movq :: X86Insn
i_movq = insn
   { insnDesc        = "Move quadword"
   , insnMnemonic    = "MOVQ"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x6F
                           , legacyReversable      = Just 4
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 WO Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0xF3
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x7E
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128low64 WO Reg
                                                     , mvec128low64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xD6
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ mvec128low64 WO
                                                     , vec128low64 RO Reg
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix = Just 0xF3
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x7E
                           , vexLW              = L0_WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128low64 WO Reg
                                                  , mvec128low64 RO
                                                  ]
                           }
                       , vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0xD6
                           , vexLW              = L0_WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ mvec128low64 WO
                                                  , vec128low64 RO Reg
                                                  ]
                           }
                       ]
   }

i_movq2dq :: X86Insn
i_movq2dq = insn
   { insnDesc        = "Move quadword from MMX to XMM register"
   , insnMnemonic    = "MOVQ2DQ"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF3
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xD6
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec128low64 WO Reg
                                                     , vec64 RO RM
                                                     ]
                           }
                       ]
   }

i_movs :: X86Insn
i_movs = insn
   { insnDesc        = "Move string"
   , insnMnemonic    = "MOVS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0xA4
                           , legacyNoForce8bit  = Just 0
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Repeatable
                                                  ]
                           , legacyParams       = [ mDSrSI RO
                                                  , mESrDI WO
                                                  ]
                           }
                       ]
   }

i_movsd :: X86Insn
i_movsd = insn
   { insnDesc        = "Move scalar double-precision floating-point values"
   , insnMnemonic    = "MOVSD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix    = Just 0xF2
                           , legacyOpcodeMap          = Map0F
                           , legacyOpcode             = 0x10
                           , legacyReversable         = Just 0
                           , legacyProperties         = [ LegacyModeSupport
                                                        , LongModeSupport
                                                        , Extension SSE2
                                                        ]
                           , legacyParams             = [ vec128low64 WO Reg
                                                        , mvec128low64 RO
                                                        ]
                           }
                       ]
   }

i_vmovsd :: X86Insn
i_vmovsd = insn
   { insnDesc        = "Move scalar double-precision floating-point values"
   , insnMnemonic    = "VMOVSD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix    = Just 0xF2
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x10
                           , vexLW                 = LWIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128o256 WO Reg
                                                     , vec128o256 RO Vvvv
                                                     , vec128o256 RO RM
                                                     ]
                           }
                       ,  vex
                           { vexMandatoryPrefix    = Just 0xF2
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x11
                           , vexLW                 = LWIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128high64 RO Vvvv
                                                     , vec128low64 RO RM
                                                     ]
                           }
                       ,  vex
                           { vexMandatoryPrefix    = Just 0xF2
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x10
                           , vexLW                 = LWIG
                           , vexReversable         = Just 0
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128low64 WO Reg
                                                     , mem64 RO
                                                     ]
                           }
                       ]
   }

i_movshdup :: X86Insn
i_movshdup = insn
   { insnDesc        = "Move packed single-FP high and duplicate"
   , insnMnemonic    = "MOVSHDUP"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF3
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x16
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE3
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0xF3
                           , vexOpcodeMap          = MapVex 1
                           , vexOpcode             = 0x16
                           , vexLW                 = WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128o256 WO Reg
                                                     , mvec128o256 RO
                                                     ]
                           }
                       ]
   }


i_movsldup :: X86Insn
i_movsldup = insn
   { insnDesc        = "Move packed single-FP low and duplicate"
   , insnMnemonic    = "MOVSLDUP"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF3
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x12
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE3
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0xF3
                           , vexOpcodeMap          = MapVex 1
                           , vexOpcode             = 0x12
                           , vexLW                 = WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128o256 WO Reg
                                                     , mvec128o256 RO
                                                     ]
                           }
                       ]
   }

i_movss :: X86Insn
i_movss = insn
   { insnDesc        = "Move scalar single-precision floating-point values"
   , insnMnemonic    = "MOVSS"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix    = Just 0xF3
                           , legacyOpcodeMap          = Map0F
                           , legacyOpcode             = 0x10
                           , legacyReversable         = Just 0
                           , legacyProperties         = [ LegacyModeSupport
                                                        , LongModeSupport
                                                        , Extension SSE
                                                        ]
                           , legacyParams             = [ vec128low32 WO Reg
                                                        , mvec128low32 RO
                                                        ]
                           }
                       ]
   }

i_vmovss :: X86Insn
i_vmovss = insn
   { insnDesc        = "Move scalar single-precision floating-point values"
   , insnMnemonic    = "VMOVSS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix    = Just 0xF3
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x10
                           , vexLW                 = LWIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128o256 WO Reg
                                                     , vec128o256 RO Vvvv
                                                     , vec128o256 RO RM
                                                     ]
                           }
                       ,  vex
                           { vexMandatoryPrefix    = Just 0xF3
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x11
                           , vexLW                 = LWIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128high64 RO Vvvv
                                                     , vec128low64 RO RM
                                                     ]
                           }
                       ,  vex
                           { vexMandatoryPrefix    = Just 0xF3
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x10
                           , vexLW                 = LWIG
                           , vexReversable         = Just 0
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128low64 WO Reg
                                                     , mem64 RO
                                                     ]
                           }
                       ]
   }

i_movsx :: X86Insn
i_movsx = insn
   { insnDesc        = "Move with sign-extension"
   , insnMnemonic    = "MOVSX"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap          = Map0F
                           , legacyOpcode             = 0xBE
                           , legacyProperties         = [ LegacyModeSupport
                                                        , LongModeSupport
                                                        ]
                           , legacyParams             = [ gpr WO Reg
                                                        , rm8 RO
                                                        ]
                           }
                       , leg
                           { legacyOpcodeMap          = Map0F
                           , legacyOpcode             = 0xBF
                           , legacyProperties         = [ LegacyModeSupport
                                                        , LongModeSupport
                                                        ]
                           , legacyParams             = [ reg32o64 WO Reg
                                                        , rm16 RO
                                                        ]
                           }
                       , leg
                           { legacyOpcodeMap          = Map0F
                           , legacyOpcode             = 0x63
                           , legacyProperties         = [ LegacyModeSupport
                                                        , LongModeSupport
                                                        ]
                           , legacyParams             = [ reg32o64 WO Reg
                                                        , rm32 RO
                                                        ]
                           }
                       ]
   }


i_movupd :: X86Insn
i_movupd = insn
   { insnDesc        = "Move unaligned packed double-precision floating-point values"
   , insnMnemonic    = "MOVUPD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x10
                           , legacyReversable      = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vmovupd :: X86Insn
i_vmovupd = insn
   { insnDesc        = "Move unaligned packed double-precision floating-point values"
   , insnMnemonic    = "VMOVUPD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x10
                           , vexReversable         = Just 0
                           , vexLW                 = WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128o256 WO Reg
                                                     , mvec128o256 RO
                                                     ]
                           }
                       ]
   }

i_movups :: X86Insn
i_movups = insn
   { insnDesc        = "Move unaligned packed single-precision floating-point values"
   , insnMnemonic    = "MOVUPS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x10
                           , legacyReversable      = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vmovups :: X86Insn
i_vmovups = insn
   { insnDesc        = "Move unaligned packed single-precision floating-point values"
   , insnMnemonic    = "VMOVUPS"
   , insnEncodings   = [ vex
                           { vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x10
                           , vexLW              = WIG
                           , vexReversable      = Just 0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }

i_movzx :: X86Insn
i_movzx = insn
   { insnDesc        = "Move with zerp-extend"
   , insnMnemonic    = "MOVZX"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap          = Map0F
                           , legacyOpcode             = 0xB6
                           , legacyProperties         = [ LegacyModeSupport
                                                        , LongModeSupport
                                                        ]
                           , legacyParams             = [ gpr WO Reg
                                                        , rm8 RO
                                                        ]
                           }
                       , leg
                           { legacyOpcodeMap          = Map0F
                           , legacyOpcode             = 0xB7
                           , legacyProperties         = [ LegacyModeSupport
                                                        , LongModeSupport
                                                        ]
                           , legacyParams             = [ reg32o64 WO Reg
                                                        , rm16 RO
                                                        ]
                           }
                       ]
   }

i_mpsadbw :: X86Insn
i_mpsadbw = insn
   { insnDesc        = "Compute multiple packed sums of absolute difference"
   , insnMnemonic    = "MPSADBW"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F3A
                           , legacyOpcode          = 0x42
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x03
                           , vexOpcode          = 0x42
                           , vexLW              = L0_WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128 WO Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128 RO
                                                  , imm8
                                                  ]
                           }
                       , vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x03
                           , vexOpcode          = 0x42
                           , vexLW              = L1_WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX2
                                                  ]
                           , vexParams          = [ vec256 WO Reg
                                                  , vec256 RO Vvvv
                                                  , mvec256 RO
                                                  , imm8
                                                  ]
                           }
                       ]
   }

i_mul :: X86Insn
i_mul = insn
   { insnDesc        = "Unsigned multiply"
   , insnMnemonic    = "MUL"
   , insnFlags       = [ Modified [OF,CF]
                       , Undefined [SF,ZF,AF,PF]
                       ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0xF6
                           , legacyOpcodeExt    = Just 4
                           , legacyNoForce8bit  = Just 0
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ regFam RegFamDXAX RW Implicit
                                                  , regAccu RO
                                                  , mgpr RO
                                                  ]
                           }
                       ]
   }

i_mulpd :: X86Insn
i_mulpd = insn
   { insnDesc        = "Multiply packed double-precision floating-point values"
   , insnMnemonic    = "MULPD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x59
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vmulpd :: X86Insn
i_vmulpd = insn
   { insnDesc        = "Multiply packed double-precision floating-point values"
   , insnMnemonic    = "VMULPD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x59
                           , vexLW                 = WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128o256 WO Reg
                                                     , vec128o256 RO Vvvv
                                                     , mvec128o256 RO
                                                     ]
                           }
                       ]
   }

i_mulps :: X86Insn
i_mulps = insn
   { insnDesc        = "Multiply packed single-precision floating-point values"
   , insnMnemonic    = "MULPS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x59
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ vec128  RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vmulps :: X86Insn
i_vmulps = insn
   { insnDesc        = "Multiply packed single-precision floating-point values"
   , insnMnemonic    = "VMULPS"
   , insnEncodings   = [ vex
                           { vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x59
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }

i_mulsd :: X86Insn
i_mulsd = insn
   { insnDesc        = "Multiply scalar double-precision floating-point values"
   , insnMnemonic    = "MULSD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF2
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x59
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128low64 RO
                                                     ]
                           }
                       ]
   }

i_vmulsd :: X86Insn
i_vmulsd = insn
   { insnDesc        = "Multiply scalar double-precision floating-point values"
   , insnMnemonic    = "VMULSD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0xF2
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x59
                           , vexLW              = LWIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128 WO Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low64 RO
                                                  ]
                           }
                       ]
   }

i_mulss :: X86Insn
i_mulss = insn
   { insnDesc        = "Multiply scalar single-precision floating-point values"
   , insnMnemonic    = "MULSS"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF3
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x59
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128low32 RO
                                                     ]
                           }
                       ]
   }

i_vmulss :: X86Insn
i_vmulss = insn
   { insnDesc        = "Multiply scalar single-precision floating-point values"
   , insnMnemonic    = "VMULSS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0xF3
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x59
                           , vexLW              = LWIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128 WO Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low32 RO
                                                  ]
                           }
                       ]
   }

i_mulx :: X86Insn
i_mulx = insn
   { insnDesc           = "Unsigned multiply without affecting flags"
   , insnMnemonic       = "MULX"
   , insnEncodings      = [ vex
                              { vexMandatoryPrefix = Just 0xF2
                              , vexOpcodeMap       = MapVex 0x02
                              , vexOpcode          = 0xF6
                              , vexLW              = L0
                              , vexProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension BMI2
                                                     ]
                              , vexParams          = [ reg32o64 WO Reg
                                                     , reg32o64 WO Vvvv
                                                     , rm32o64 RO
                                                     , rDX RO
                                                     ]
                              }
                          ]
   }

i_mwait :: X86Insn
i_mwait = insn
   { insnDesc        = "Monitor wait"
   , insnMnemonic    = "MWAIT"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap     = Map0F
                           , legacyOpcode        = 0x01
                           , legacyOpcodeFullExt = Just 0xC9
                           , legacyProperties    = [ LegacyModeSupport
                                                   , LongModeSupport
                                                   , Extension MONITOR
                                                   ]
                           , legacyParams          = [ reg R_ECX RO Implicit
                                                     , reg R_EAX RO Implicit
                                                     ]
                           }
                       ]
   }

i_neg :: X86Insn
i_neg = insn
   { insnDesc        = "Two's complement negation"
   , insnMnemonic    = "NEG"
   , insnFlags       = [ Modified [CF,OF,SF,ZF,AF,PF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0xF6
                           , legacyOpcodeExt    = Just 3
                           , legacyNoForce8bit  = Just 0
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , HLE XBoth
                                                  ]
                           , legacyParams       = [ mgpr RW
                                                  ]
                           }
                       ]
   }

i_nop :: X86Insn
i_nop = insn
   { insnDesc        = "No operation"
   , insnMnemonic    = "NOP"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0x90
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ ]
                           }
                       , leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0x1F
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , NoOperandSize64
                                                  ]
                           , legacyParams       = [ mgpr NA ]
                           }
                       ]
   }

i_not :: X86Insn
i_not = insn
   { insnDesc        = "One's complement negation"
   , insnMnemonic    = "NOT"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0xF6
                           , legacyOpcodeExt    = Just 2
                           , legacyNoForce8bit  = Just 0
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Lockable
                                                  , HLE XBoth
                                                  ]
                           , legacyParams       = [ mgpr RW
                                                  ]
                           }
                       ]
   }

i_or :: X86Insn
i_or = insn
   { insnDesc        = "Logical inclusive OR"
   , insnMnemonic    = "OR"
   , insnFlags       = [ Unset     [OF,CF]
                       , Modified  [SF,ZF,PF]
                       , Undefined [AF]
                       ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0x0C
                           , legacyNoForce8bit  = Just 0
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ regAccu RW
                                                  , immSE
                                                  ]
                           }
                       , leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0x08
                           , legacyNoForce8bit  = Just 0
                           , legacyReversable   = Just 1
                           , legacyProperties   = [ Lockable
                                                  , LegacyModeSupport
                                                  , LongModeSupport
                                                  , HLE XBoth
                                                  ]
                           , legacyParams       = [ mgpr RW
                                                  , gpr RO Reg
                                                  ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x80
                           , legacyOpcodeExt       = Just 1
                           , legacyNoForce8bit     = Just 0
                           , legacySignExtendable  = Just 1
                           , legacyProperties      = [ Lockable
                                                     , LegacyModeSupport
                                                     , LongModeSupport
                                                     , HLE XBoth
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , immSE
                                                     ]
                           }
                       ]
   }

i_orpd :: X86Insn
i_orpd = insn
   { insnDesc        = "Bitwise logical OR of packed double-precision floating-point values"
   , insnMnemonic    = "ORPD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x56
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vorpd :: X86Insn
i_vorpd = insn
   { insnDesc        = "Bitwise logical OR of packed double-precision floating-point values"
   , insnMnemonic    = "VORPD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x56
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }

i_orps :: X86Insn
i_orps = insn
   { insnDesc        = "Bitwise logical OR of packed float-precision floating-point values"
   , insnMnemonic    = "ORPS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0x56
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension SSE
                                                  ]
                           , legacyParams       = [ vec128 RW Reg
                                                  , mvec128 RO
                                                  ]
                           }
                       ]
   }

i_vorps :: X86Insn
i_vorps = insn
   { insnDesc        = "Bitwise logical OR of packed float-precision floating-point values"
   , insnMnemonic    = "VORPS"
   , insnEncodings   = [ vex
                           { vexOpcodeMap    = MapVex 0x01
                           , vexOpcode       = 0x56
                           , vexLW           = WIG
                           , vexProperties   = [ LegacyModeSupport
                                               , LongModeSupport
                                               , Extension AVX
                                               ]
                           , vexParams       = [ vec128o256 WO Reg
                                               , vec128o256 RO Vvvv
                                               , mvec128o256 RO
                                               ]
                           }
                       ]
   }

i_out :: X86Insn
i_out = insn
   { insnDesc        = "Output to port"
   , insnMnemonic    = "OUT"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xE6
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , NoOperandSize64
                                                     ]
                           , legacyParams          = [ imm8
                                                     , regAccu RO 
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xEE
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , NoOperandSize64
                                                     ]
                           , legacyParams          = [ reg R_DX RO Implicit
                                                     , regAccu RO
                                                     ]
                           }

                       ]
   }

i_outs :: X86Insn
i_outs = insn
   { insnDesc        = "Output string to port"
   , insnMnemonic    = "OUTS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x6E
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , DefaultAddressSize64
                                                     , NoOperandSize64
                                                     , Repeatable
                                                     ]
                           , legacyParams          = [ reg R_DX RO Implicit
                                                     , mDSrSI RO  
                                                     ]
                           }
                       ]
   }

i_pabsb :: X86Insn
i_pabsb = insn
   { insnDesc        = "Packed absolute value of bytes"
   , insnMnemonic    = "PABSB"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x1C
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSSE3
                                                     ]
                           , legacyParams          = [ vec64 WO Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x1C
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSSE3
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x1C
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x1C
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , mvec256 RO
                                                     ]
                           }

                       ]
   }


i_pabsw :: X86Insn
i_pabsw = insn
   { insnDesc        = "Packed absolute value of 16-bit integers"
   , insnMnemonic    = "PABSW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x1D
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSSE3
                                                     ]
                           , legacyParams          = [ vec64 WO Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x1D
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSSE3
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x1D
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x1D
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , mvec256 RO
                                                     ]
                           }

                       ]
   }


i_pabsd :: X86Insn
i_pabsd = insn
   { insnDesc        = "Packed absolute value of 32-bit integers"
   , insnMnemonic    = "PABSD"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x1E
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSSE3
                                                     ]
                           , legacyParams          = [ vec64 WO Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x1E
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSSE3
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x1E
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x1E
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , mvec256 RO
                                                     ]
                           }

                       ]
   }

i_packsswb :: X86Insn
i_packsswb = insn
   { insnDesc        = "Pack with signed saturation"
   , insnMnemonic    = "PACKSSWB"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x63
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x63
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x63
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x63
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }

                       ]
   }


i_packssdw :: X86Insn
i_packssdw = insn
   { insnDesc        = "Pack with signed saturation"
   , insnMnemonic    = "PACKSSDW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x6B
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x6B
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x6B
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x6B
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }


i_packusdw :: X86Insn
i_packusdw = insn
   { insnDesc        = "Pack with unsigned saturation"
   , insnMnemonic    = "PACKUSDW"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x2B
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x2B
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x2B
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }

i_packuswb :: X86Insn
i_packuswb = insn
   { insnDesc        = "Pack with unsigned saturation"
   , insnMnemonic    = "PACKUSWB"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x67
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x67
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x67
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x67
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }

                       ]
   }

i_paddb :: X86Insn
i_paddb = insn
   { insnDesc        = "Add packed integers"
   , insnMnemonic    = "PADDB"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xFC
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 WO Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xFC
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xFC
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xFC
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }

                       ]
   }



i_paddw :: X86Insn
i_paddw = insn
   { insnDesc        = "Add packed integers"
   , insnMnemonic    = "PADDW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xFD
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 WO Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xFD
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xFD
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xFD
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }

                       ]
   }


i_paddd :: X86Insn
i_paddd = insn
   { insnDesc        = "Add packed integers"
   , insnMnemonic    = "PADDD"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xFE
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 WO Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xFE
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xFE
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xFE
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }

                       ]
   }



i_paddq :: X86Insn
i_paddq = insn
   { insnDesc        = "Add packed quadword integers"
   , insnMnemonic    = "PADDQ"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xD4
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec64 WO Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xD4
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xD4
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xD4
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }

                       ]
   }



i_paddsb :: X86Insn
i_paddsb = insn
   { insnDesc        = "Add packed signed integers with signed saturation"
   , insnMnemonic    = "PADDSB"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xEC
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xEC
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xEC
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xEC
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }

                       ]
   }


i_paddsw :: X86Insn
i_paddsw = insn
   { insnDesc        = "Add packed signed integers with signed saturation"
   , insnMnemonic    = "PADDSW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xED
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xED
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xED
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xED
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }

                       ]
   }


i_paddusb :: X86Insn
i_paddusb = insn
   { insnDesc        = "Add packed unsigned integers with unsigned saturation"
   , insnMnemonic    = "PADDUSB"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xDC
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xDC
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xDC
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xDC
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }

                       ]
   }


i_paddusw :: X86Insn
i_paddusw = insn
   { insnDesc        = "Add packed unsigned integers with unsigned saturation"
   , insnMnemonic    = "PADDUSW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xDD
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xDD
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xDD
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xDD
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }

                       ]
   }

i_palignr :: X86Insn
i_palignr = insn
   { insnDesc        = "Packed align right"
   , insnMnemonic    = "PALIGNR"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F3A
                           , legacyOpcode          = 0x0F
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSSE3
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     , imm8
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F3A
                           , legacyOpcode          = 0x0F
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSSE3
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x03
                           , vexOpcode             = 0x0F
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x03
                           , vexOpcode             = 0x0F
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     , imm8
                                                     ]
                           }

                       ]
   }

i_pand :: X86Insn
i_pand = insn
   { insnDesc        = "Logical AND"
   , insnMnemonic    = "PAND"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xDB
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xDB
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xDB
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xDB
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }

                       ]
   }


i_pandn :: X86Insn
i_pandn = insn
   { insnDesc        = "Logical AND NOT"
   , insnMnemonic    = "PANDN"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xDF
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xDF
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xDF
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xDF
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }

                       ]
   }

i_pause :: X86Insn
i_pause = insn
   { insnDesc        = "Spin loop hint"
   , insnMnemonic    = "PAUSE"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF3
                           , legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x90
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           }
                       ]
   }

i_pavgb :: X86Insn
i_pavgb = insn
   { insnDesc        = "Average packed integers"
   , insnMnemonic    = "PAVGB"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xE0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xE0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xE0
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xE0
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }

                       ]
   }



i_pavgw :: X86Insn
i_pavgw = insn
   { insnDesc        = "Average packed integers"
   , insnMnemonic    = "PAVGW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xE3
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xE3
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xE3
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xE3
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }

                       ]
   }



i_pblendvb :: X86Insn
i_pblendvb = insn
   { insnDesc        = "Variable blend packed bytes"
   , insnMnemonic    = "PBLENDVB"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x10
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     , xmm0 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x03
                           , vexOpcode             = 0x4C
                           , vexLW                 = L0_W0
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     , vec128 RO Imm8h
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x03
                           , vexOpcode             = 0x4C
                           , vexLW                 = L1_W0
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     , vec256 RO Imm8h
                                                     ]
                           }

                       ]
   }


i_pblendw :: X86Insn
i_pblendw = insn
   { insnDesc        = "Blend packed words"
   , insnMnemonic    = "PBLENDW"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F3A
                           , legacyOpcode          = 0x0E
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x03
                           , vexOpcode             = 0x0E
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x03
                           , vexOpcode             = 0x0E
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     , imm8
                                                     ]
                           }

                       ]
   }


i_pclmulqdq :: X86Insn
i_pclmulqdq = insn
   { insnDesc        = "Carry-less multiplication quadword"
   , insnMnemonic    = "PCLMULQDQ"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F3A
                           , legacyOpcode          = 0x44
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension PCLMULQDQ
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x03
                           , vexOpcode             = 0x44
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     , Extension PCLMULQDQ
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     , imm8
                                                     ]
                           }
                       ]
   }


i_pcmpeqb :: X86Insn
i_pcmpeqb = insn
   { insnDesc        = "Compare packed data for equality"
   , insnMnemonic    = "PCMPEQB"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x74
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x74
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x74
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x74
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }


i_pcmpeqw :: X86Insn
i_pcmpeqw = insn
   { insnDesc        = "Compare packed data for equality"
   , insnMnemonic    = "PCMPEQW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x75
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x75
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x75
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x75
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }


i_pcmpeqd :: X86Insn
i_pcmpeqd = insn
   { insnDesc        = "Compare packed data for equality"
   , insnMnemonic    = "PCMPEQD"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x76
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x76
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x76
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x76
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }


i_pcmpeqq :: X86Insn
i_pcmpeqq = insn
   { insnDesc        = "Compare packed quadword data for equality"
   , insnMnemonic    = "PCMPEQQ"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x29
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x29
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x29
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }


i_pcmpestri :: X86Insn
i_pcmpestri = insn
   { insnDesc        = "Packed compare explicit length strings, return index"
   , insnMnemonic    = "PCMPESTRI"
   , insnFlags       = [ Modified [CF, ZF, SF, OF]
                       , Unset [AF, PF]
                       ]
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F3A
                           , legacyOpcode          = 0x61
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_2
                                                     ]
                           , legacyParams          = [ vec128 RO Reg
                                                     , mvec128 RO
                                                     , imm8
                                                     , rCX WO
                                                     , rAX RO
                                                     , rDX RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x03
                           , vexOpcode             = 0x61
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     , imm8
                                                     , rCX WO
                                                     , rAX RO
                                                     , rDX RO
                                                     ]
                           }
                       ]
   }


i_pcmpestrm :: X86Insn
i_pcmpestrm = insn
   { insnDesc        = "Packed compare explicit length strings, return mask"
   , insnMnemonic    = "PCMPESTRM"
   , insnFlags       = [ Modified [CF, ZF, SF, OF]
                       , Unset [AF, PF]
                       ]
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F3A
                           , legacyOpcode          = 0x60
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_2
                                                     ]
                           , legacyParams          = [ vec128 RO Reg
                                                     , mvec128 RO
                                                     , imm8
                                                     , xmm0 WO
                                                     , rAX RO
                                                     , rDX RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x03
                           , vexOpcode             = 0x60
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     , imm8
                                                     , xmm0 WO
                                                     , rAX RO
                                                     , rDX RO
                                                     ]
                           }
                       ]
   }

i_pcmpgtb :: X86Insn
i_pcmpgtb = insn
   { insnDesc        = "Compare packed data for greater than"
   , insnMnemonic    = "PCMPGTB"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x64
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x64
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x64
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x64
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }


i_pcmpgtw :: X86Insn
i_pcmpgtw = insn
   { insnDesc        = "Compare packed data for greater than"
   , insnMnemonic    = "PCMPGTW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x65
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x65
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x65
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x65
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }


i_pcmpgtd :: X86Insn
i_pcmpgtd = insn
   { insnDesc        = "Compare packed data for greater than"
   , insnMnemonic    = "PCMPGTD"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x66
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x66
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x66
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x66
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }


i_pcmpgtq :: X86Insn
i_pcmpgtq = insn
   { insnDesc        = "Compare packed quadword data for greater than"
   , insnMnemonic    = "PCMPGTQ"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x37
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x37
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x37
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }

i_pcmpistri :: X86Insn
i_pcmpistri = insn
   { insnDesc        = "Packed compare implicit length strings, return index"
   , insnMnemonic    = "PCMPiSTRI"
   , insnFlags       = [ Modified [CF, ZF, SF, OF]
                       , Unset [AF, PF]
                       ]
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F3A
                           , legacyOpcode          = 0x63
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_2
                                                     ]
                           , legacyParams          = [ vec128 RO Reg
                                                     , mvec128 RO
                                                     , imm8
                                                     , rCX WO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x03
                           , vexOpcode             = 0x63
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     , imm8
                                                     , rCX WO
                                                     ]
                           }
                       ]
   }


i_pcmpistrm :: X86Insn
i_pcmpistrm = insn
   { insnDesc        = "Packed compare implicit length strings, return mask"
   , insnMnemonic    = "PCMPISTRM"
   , insnFlags       = [ Modified [CF, ZF, SF, OF]
                       , Unset [AF, PF]
                       ]
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F3A
                           , legacyOpcode          = 0x62
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_2
                                                     ]
                           , legacyParams          = [ vec128 RO Reg
                                                     , mvec128 RO
                                                     , imm8
                                                     , xmm0 WO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x03
                           , vexOpcode             = 0x62
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     , imm8
                                                     , xmm0 WO
                                                     ]
                           }
                       ]
   }

i_pdep :: X86Insn
i_pdep = insn
   { insnDesc           = "Parallel bits deposit"
   , insnMnemonic       = "PDEP"
   , insnEncodings      = [ vex
                              { vexMandatoryPrefix = Just 0xF2
                              , vexOpcodeMap       = MapVex 0x02
                              , vexOpcode          = 0xF5
                              , vexLW              = L0
                              , vexProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension BMI2
                                                     ]
                              , vexParams          = [ reg32o64 WO Reg
                                                     , reg32o64 RO Vvvv
                                                     , rm32o64 RO
                                                     ]
                              }
                          ]
   }

i_pext :: X86Insn
i_pext = insn
   { insnDesc           = "Parallel bits extract"
   , insnMnemonic       = "PEXT"
   , insnEncodings      = [ vex
                              { vexMandatoryPrefix = Just 0xF3
                              , vexOpcodeMap       = MapVex 0x02
                              , vexOpcode          = 0xF5
                              , vexLW              = L0
                              , vexProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension BMI2
                                                     ]
                              , vexParams          = [ reg32o64 WO Reg
                                                     , reg32o64 RO Vvvv
                                                     , rm32o64 RO
                                                     ]
                              }
                          ]
   }


i_pextrb :: X86Insn
i_pextrb = insn
   { insnDesc        = "Extract byte"
   , insnMnemonic    = "PEXTRB"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F3A
                           , legacyOpcode          = 0x14
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ rm8 WO
                                                     , vec128 RO Reg
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x03
                           , vexOpcode             = 0x14
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ rm8 WO
                                                     , vec128 RO Reg
                                                     , imm8
                                                     ]
                           }
                       ]
   }


i_pextrd :: X86Insn
i_pextrd = insn
   { insnDesc        = "Extract dword/qword"
   , insnMnemonic    = "PEXTRD/PEXTRQ"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F3A
                           , legacyOpcode          = 0x16
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ rm32o64 WO
                                                     , vec128 RO Reg
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x03
                           , vexOpcode             = 0x16
                           , vexLW                 = L0
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ rm32o64 WO
                                                     , vec128 RO Reg
                                                     , imm8
                                                     ]
                           }
                       ]
   }

i_pextrw :: X86Insn
i_pextrw = insn
   { insnDesc        = "Extract word"
   , insnMnemonic    = "PEXTRW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xC5
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ reg16 WO Reg
                                                     , vec64 RO RM
                                                     , imm8
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xC5
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ reg16 WO Reg
                                                     , vec128 RO RM
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xC5
                           , vexLW                 = L0_W0
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ reg16 WO Reg
                                                     , vec128 RO RM
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x03
                           , vexOpcode             = 0x15
                           , vexLW                 = L0_W0
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ rm16 WO
                                                     , vec128 RO Reg
                                                     , imm8
                                                     ]
                           }
                       ]
   }


i_phaddw :: X86Insn
i_phaddw = insn
   { insnDesc        = "Packed horizontal add"
   , insnMnemonic    = "PHADDW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x01
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSSE3
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x01
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSSE3
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x01
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x01
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }


i_phaddd :: X86Insn
i_phaddd = insn
   { insnDesc        = "Packed horizontal add"
   , insnMnemonic    = "PHADDD"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x02
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSSE3
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x02
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSSE3
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x02
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x02
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }


i_phaddsw :: X86Insn
i_phaddsw = insn
   { insnDesc        = "Packed horizontal add and saturate"
   , insnMnemonic    = "PHADDSW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x03
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSSE3
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x03
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSSE3
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x03
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x03
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }

i_phminposuw :: X86Insn
i_phminposuw = insn
   { insnDesc        = "Packed horizontal word minimum"
   , insnMnemonic    = "PHMINPOSUW"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x41
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x41
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_phsubw :: X86Insn
i_phsubw = insn
   { insnDesc        = "Packed horizontal subtract"
   , insnMnemonic    = "PHSUBW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x05
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSSE3
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x05
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSSE3
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x05
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x05
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }


i_phsubd :: X86Insn
i_phsubd = insn
   { insnDesc        = "Packed horizontal subtract"
   , insnMnemonic    = "PHSUBD"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x06
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSSE3
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x06
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSSE3
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x06
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x06
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }


i_phsubsw :: X86Insn
i_phsubsw = insn
   { insnDesc        = "Packed horizontal subtract and saturate"
   , insnMnemonic    = "PHSUBSW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x07
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSSE3
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x07
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSSE3
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x07
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x07
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }

i_pinsrb :: X86Insn
i_pinsrb = insn
   { insnDesc        = "Insert byte"
   , insnMnemonic    = "PINSRB"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F3A
                           , legacyOpcode          = 0x20
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , rm8 RO
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x03
                           , vexOpcode             = 0x20
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , rm8 RO
                                                     , imm8
                                                     ]
                           }
                       ]
   }


i_pinsrd :: X86Insn
i_pinsrd = insn
   { insnDesc        = "Insert dword/qword"
   , insnMnemonic    = "PINSRD/PINSRQ"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F3A
                           , legacyOpcode          = 0x22
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , rm32o64 RO
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x03
                           , vexOpcode             = 0x22
                           , vexLW                 = L0
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , rm32o64 RO
                                                     , imm8
                                                     ]
                           }
                       ]
   }

i_pinsrw :: X86Insn
i_pinsrw = insn
   { insnDesc        = "Insert word"
   , insnMnemonic    = "PINSRW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xC4
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ vec64 WO Reg
                                                     , rm16 RO
                                                     , imm8
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xC4
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , rm16 RO
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xC4
                           , vexLW                 = L0_W0
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , rm16 RO
                                                     , imm8
                                                     ]
                           }
                       ]
   }

i_pmaddubsw :: X86Insn
i_pmaddubsw = insn
   { insnDesc        = "Multiply and add packed signed and unsigned bytes"
   , insnMnemonic    = "PMADDUBSW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x04
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSSE3
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x04
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSSE3
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x04
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x04
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }

i_pmaddwd :: X86Insn
i_pmaddwd = insn
   { insnDesc        = "Multiply and add packed integers"
   , insnMnemonic    = "PMADDWD"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xF5
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xF5
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xF5
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xF5
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }


i_pmaxsb :: X86Insn
i_pmaxsb = insn
   { insnDesc        = "Maximum of packed signed byte integers"
   , insnMnemonic    = "PMAXSB"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x3C
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x3C
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x3C
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }


i_pmaxsd :: X86Insn
i_pmaxsd = insn
   { insnDesc        = "Maximum of packed signed dword integers"
   , insnMnemonic    = "PMAXSD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x3D
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x3D
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x3D
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }

i_pmaxsw :: X86Insn
i_pmaxsw = insn
   { insnDesc        = "Maximum of packed signed word integers"
   , insnMnemonic    = "PMAXSW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xEE
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xEE
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xEE
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xEE
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }


i_pmaxub :: X86Insn
i_pmaxub = insn
   { insnDesc        = "Maximum of packed unsigned byte integers"
   , insnMnemonic    = "PMAXUB"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xDE
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xDE
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xDE
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xDE
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }

i_pmaxud :: X86Insn
i_pmaxud = insn
   { insnDesc        = "Maximum of packed unsigned dword integers"
   , insnMnemonic    = "PMAXUD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x3F
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x3F
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x3F
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }



i_pmaxuw :: X86Insn
i_pmaxuw = insn
   { insnDesc        = "Maximum of packed unsigned word integers"
   , insnMnemonic    = "PMAXUW"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x3E
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x3E
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x3E
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }




i_pminsb :: X86Insn
i_pminsb = insn
   { insnDesc        = "Minimum of packed signed byte integers"
   , insnMnemonic    = "PMINSB"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x38
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x38
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x38
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }


i_pminsd :: X86Insn
i_pminsd = insn
   { insnDesc        = "Minimum of packed signed dword integers"
   , insnMnemonic    = "PMINSD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x39
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x39
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x39
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }

i_pminsw :: X86Insn
i_pminsw = insn
   { insnDesc        = "Minimum of packed signed word integers"
   , insnMnemonic    = "PMINSW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xEA
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xEA
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xEA
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xEA
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }


i_pminub :: X86Insn
i_pminub = insn
   { insnDesc        = "Minimum of packed unsigned byte integers"
   , insnMnemonic    = "PMINUB"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xDA
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xDA
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xDA
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xDA
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }

i_pminud :: X86Insn
i_pminud = insn
   { insnDesc        = "Minimum of packed unsigned dword integers"
   , insnMnemonic    = "PMINUD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x3B
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x3B
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x3B
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }



i_pminuw :: X86Insn
i_pminuw = insn
   { insnDesc        = "Minimum of packed unsigned word integers"
   , insnMnemonic    = "PMINUW"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x3A
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x3A
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x3A
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }


i_pmovmskb :: X86Insn
i_pmovmskb = insn
   { insnDesc        = "Move byte mask"
   , insnMnemonic    = "PMOVMSKB"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xD7
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ gpr WO Reg
                                                     , vec64 RO RM
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xD7
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ gpr WO Reg
                                                     , vec128 RO RM
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xD7
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ gpr WO Reg
                                                     , vec128 RO RM
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xD7
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ gpr WO Reg
                                                     , vec256 RO RM
                                                     ]
                           }
                       ]
   }

i_pmovsxbw :: X86Insn
i_pmovsxbw = insn
   { insnDesc        = "Packed move with sign extend"
   , insnMnemonic    = "PMOVSXBW"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x20
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128low64 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x20
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , mvec128low64 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x20
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , mvec128low64 RO
                                                     ]
                           }
                       ]
   }


i_pmovsxbd :: X86Insn
i_pmovsxbd = insn
   { insnDesc        = "Packed move with sign extend"
   , insnMnemonic    = "PMOVSXBD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x21
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128low32 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x21
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , mvec128low32 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x21
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , mvec128low32 RO
                                                     ]
                           }
                       ]
   }


i_pmovsxbq :: X86Insn
i_pmovsxbq = insn
   { insnDesc        = "Packed move with sign extend"
   , insnMnemonic    = "PMOVSXBQ"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x22
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128low16 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x22
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , mvec128low16 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x22
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , mvec128low16 RO
                                                     ]
                           }
                       ]
   }


i_pmovsxwd :: X86Insn
i_pmovsxwd = insn
   { insnDesc        = "Packed move with sign extend"
   , insnMnemonic    = "PMOVSXWD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x23
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128low64 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x23
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , mvec128low64 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x23
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , mvec128low64 RO
                                                     ]
                           }
                       ]
   }


i_pmovsxwq :: X86Insn
i_pmovsxwq = insn
   { insnDesc        = "Packed move with sign extend"
   , insnMnemonic    = "PMOVSXWQ"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x24
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128low32 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x24
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , mvec128low32 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x24
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , mvec128low32 RO
                                                     ]
                           }
                       ]
   }


i_pmovsxdq :: X86Insn
i_pmovsxdq = insn
   { insnDesc        = "Packed move with sign extend"
   , insnMnemonic    = "PMOVSXWQ"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x25
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128low64 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x25
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , mvec128low64 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x25
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , mvec128low64 RO
                                                     ]
                           }
                       ]
   }


i_pmovzxbw :: X86Insn
i_pmovzxbw = insn
   { insnDesc        = "Packed move with zero extend"
   , insnMnemonic    = "PMOVZXBW"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x30
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128low64 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x30
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , mvec128low64 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x30
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , mvec128low64 RO
                                                     ]
                           }
                       ]
   }


i_pmovzxbd :: X86Insn
i_pmovzxbd = insn
   { insnDesc        = "Packed move with zero extend"
   , insnMnemonic    = "PMOVZXBD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x31
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128low32 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x31
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , mvec128low32 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x31
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , mvec128low32 RO
                                                     ]
                           }
                       ]
   }


i_pmovzxbq :: X86Insn
i_pmovzxbq = insn
   { insnDesc        = "Packed move with zero extend"
   , insnMnemonic    = "PMOVZXBQ"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x32
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128low16 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x32
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , mvec128low16 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x32
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , mvec128low16 RO
                                                     ]
                           }
                       ]
   }


i_pmovzxwd :: X86Insn
i_pmovzxwd = insn
   { insnDesc        = "Packed move with zero extend"
   , insnMnemonic    = "PMOVZXWD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x33
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128low64 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x33
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , mvec128low64 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x33
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , mvec128low64 RO
                                                     ]
                           }
                       ]
   }


i_pmovzxwq :: X86Insn
i_pmovzxwq = insn
   { insnDesc        = "Packed move with zero extend"
   , insnMnemonic    = "PMOVZXWQ"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x34
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128low32 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x34
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , mvec128low32 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x34
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , mvec128low32 RO
                                                     ]
                           }
                       ]
   }


i_pmovzxdq :: X86Insn
i_pmovzxdq = insn
   { insnDesc        = "Packed move with zero extend"
   , insnMnemonic    = "PMOVZXWQ"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x35
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128low64 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x35
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , mvec128low64 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x35
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , mvec128low64 RO
                                                     ]
                           }
                       ]
   }


i_pmuldq :: X86Insn
i_pmuldq = insn
   { insnDesc        = "Multiply packed signed dword integers"
   , insnMnemonic    = "PMULDQ"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x28
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x28
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x28
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }

                       ]
   }


i_pmulhrsw :: X86Insn
i_pmulhrsw = insn
   { insnDesc        = "Packed multiply high with round and scale"
   , insnMnemonic    = "PMULHRSW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x0B
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSSE3
                                                     ]
                           , legacyParams          = [ vec64 WO Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x0B
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSSE3
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x0B
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x0B
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }

                       ]
   }


i_pmulhuw :: X86Insn
i_pmulhuw = insn
   { insnDesc        = "Multiply packed unsigned integers and store high result"
   , insnMnemonic    = "PMULHUW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xE4
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ vec64 WO Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xE4
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xE4
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xE4
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }


i_pmulhw :: X86Insn
i_pmulhw = insn
   { insnDesc        = "Multiply packed signed integers and store high result"
   , insnMnemonic    = "PMULHW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xE5
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 WO Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xE5
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xE5
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xE5
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }

i_pmulld :: X86Insn
i_pmulld = insn
   { insnDesc        = "Multiply packed signed dword integers and store low result"
   , insnMnemonic    = "PMULLD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x40
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x40
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x40
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }

                       ]
   }

i_pmullw :: X86Insn
i_pmullw = insn
   { insnDesc        = "Multiply packed signed integers and store low result"
   , insnMnemonic    = "PMULLW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xD5
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 WO Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xD5
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xD5
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xD5
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }

i_pmuludq :: X86Insn
i_pmuludq = insn
   { insnDesc        = "Multiply packed unsigned doubleword integers"
   , insnMnemonic    = "PMULUDQ"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xF4
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec64 WO Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xF4
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xF4
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xF4
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }

i_pop :: X86Insn
i_pop = insn
   { insnDesc        = "Pop a value from the stack"
   , insnMnemonic    = "POP"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x8F
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , DefaultOperandSize64
                                                     , NoOperandSize64
                                                     ]
                           , legacyParams          = [ mgpr WO
                                                     , regStackPtr RW Implicit
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x58
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , DefaultOperandSize64
                                                     , NoOperandSize64
                                                     ]
                           , legacyParams          = [ gpr WO OpcodeLow3
                                                     , regStackPtr RW Implicit
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x1F
                           , legacyProperties      = [ LegacyModeSupport ]
                           , legacyParams          = [ reg R_DS WO Implicit
                                                     , regStackPtr RW Implicit
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x07
                           , legacyProperties      = [ LegacyModeSupport ]
                           , legacyParams          = [ reg R_ES WO Implicit
                                                     , regStackPtr RW Implicit
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x17
                           , legacyProperties      = [ LegacyModeSupport ]
                           , legacyParams          = [ reg R_SS WO Implicit
                                                     , regStackPtr RW Implicit
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xA1
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ reg R_FS WO Implicit
                                                     , regStackPtr RW Implicit
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xA9
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ reg R_GS WO Implicit
                                                     , regStackPtr RW Implicit
                                                     ]
                           }
                       ]
   }

i_popa :: X86Insn
i_popa = insn
   { insnDesc        = "Pop all general-purpose registers"
   , insnMnemonic    = "POPA"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x61
                           , legacyProperties      = [ LegacyModeSupport ]
                           , legacyParams          = [ regBasePtr WO Implicit
                                                     , regFam RegFamDI WO Implicit
                                                     , regFam RegFamSI WO Implicit
                                                     , regFam RegFamAX WO Implicit
                                                     , regFam RegFamBX WO Implicit
                                                     , regFam RegFamCX WO Implicit
                                                     , regFam RegFamDX WO Implicit
                                                     , regStackPtr RW Implicit
                                                     ]
                           }
                       ]
   }


i_popcnt :: X86Insn
i_popcnt = insn
   { insnDesc        = "Return the count of number of bits set to 1"
   , insnMnemonic    = "POPCNT"
   , insnFlags       = [ Unset [OF,SF,AF,CF,PF]
                       , Modified [ZF]
                       ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xB8
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ gpr WO Reg
                                                     , mgpr RO
                                                     ]
                           }
                       ]
   }


i_popf :: X86Insn
i_popf = insn
   { insnDesc        = "Pop stack into EFLAGS register"
   , insnMnemonic    = "POPF"
   , insnFlags       = [ Modified allFlags ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x9D
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ regStackPtr RW Implicit
                                                     ]
                           }
                       ]
   }

i_por :: X86Insn
i_por = insn
   { insnDesc        = "Bitwise logical OR"
   , insnMnemonic    = "POR"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xEB
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xEB
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xEB
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xEB
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }

i_prefetcht0 :: X86Insn
i_prefetcht0 = insn
   { insnDesc        = "Prefetch data into caches"
   , insnMnemonic    = "PREFETCHT0"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x18
                           , legacyOpcodeExt       = Just 1
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mem8 NA ]
                           }
                       ]
   }


i_prefetcht1 :: X86Insn
i_prefetcht1 = insn
   { insnDesc        = "Prefetch data into caches"
   , insnMnemonic    = "PREFETCHT1"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x18
                           , legacyOpcodeExt       = Just 2
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mem8 NA ]
                           }
                       ]
   }


i_prefetcht2 :: X86Insn
i_prefetcht2 = insn
   { insnDesc        = "Prefetch data into caches"
   , insnMnemonic    = "PREFETCHT2"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x18
                           , legacyOpcodeExt       = Just 3
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mem8 NA ]
                           }
                       ]
   }


i_prefetchnta :: X86Insn
i_prefetchnta = insn
   { insnDesc        = "Prefetch data into caches"
   , insnMnemonic    = "PREFETCHNTA"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x18
                           , legacyOpcodeExt       = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mem8 NA ]
                           }
                       ]
   }


i_prefetchw :: X86Insn
i_prefetchw = insn
   { insnDesc        = "Prefetch data into caches in anticipation of a write"
   , insnMnemonic    = "PREFETCHW"
   , insnFlags       = [ Modified allFlags ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x0D
                           , legacyOpcodeExt       = Just 1
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension PRFCHW
                                                     ]
                           , legacyParams          = [ mem8 NA ]
                           }
                       ]
   }


i_prefetchwt1 :: X86Insn
i_prefetchwt1 = insn
   { insnDesc        = "Prefetch vecor data into caches with intent to write and T1 hint"
   , insnMnemonic    = "PREFETCHWT1"
   , insnFlags       = [ Modified allFlags ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x0D
                           , legacyOpcodeExt       = Just 2
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension PREFETCHWT1
                                                     ]
                           , legacyParams          = [ mem8 NA ]
                           }
                       ]
   }

i_psadbw :: X86Insn
i_psadbw = insn
   { insnDesc        = "Compute sum of absolute differences"
   , insnMnemonic    = "PSADBW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xF6
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xF6
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xF6
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xF6
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }

                       ]
   }

i_pshufb :: X86Insn
i_pshufb = insn
   { insnDesc        = "Packed shuffle bytes"
   , insnMnemonic    = "PSHUFB"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x00
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSSE3
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x00
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSSE3
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x00
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x00
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }

i_pshufd :: X86Insn
i_pshufd = insn
   { insnDesc        = "Shuffle packed doublewords"
   , insnMnemonic    = "PSHUFD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x70
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x70
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x70
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , mvec256 RO
                                                     , imm8
                                                     ]
                           }
                       ]
   }

i_pshufhw :: X86Insn
i_pshufhw = insn
   { insnDesc        = "Shuffle packed high words"
   , insnMnemonic    = "PSHUFHW"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF3
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x70
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0xF3
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x70
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0xF3
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x70
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , mvec256 RO
                                                     , imm8
                                                     ]
                           }
                       ]
   }


i_pshuflw :: X86Insn
i_pshuflw = insn
   { insnDesc        = "Shuffle packed low words"
   , insnMnemonic    = "PSHUFLW"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF2
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x70
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0xF2
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x70
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0xF2
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x70
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , mvec256 RO
                                                     , imm8
                                                     ]
                           }
                       ]
   }

i_pshufw :: X86Insn
i_pshufw = insn
   { insnDesc        = "Shuffle packed words"
   , insnMnemonic    = "PSHUFW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x70
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ vec64 WO Reg
                                                     , mvec64 RO
                                                     , imm8
                                                     ]
                           }
                       ]
   }

i_psignb :: X86Insn
i_psignb = insn
   { insnDesc        = "Packed sign"
   , insnMnemonic    = "PSIGNB"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x08
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSSE3
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x08
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSSE3
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x08
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x08
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }


i_psignw :: X86Insn
i_psignw = insn
   { insnDesc        = "Packed sign"
   , insnMnemonic    = "PSIGNW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x09
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSSE3
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x09
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSSE3
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x09
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x09
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }


i_psignd :: X86Insn
i_psignd = insn
   { insnDesc        = "Packed sign"
   , insnMnemonic    = "PSIGND"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x0A
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSSE3
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x0A
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSSE3
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x0A
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x0A
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }

i_pslldq :: X86Insn
i_pslldq = insn
   { insnDesc        = "Shift double quadword left logical"
   , insnMnemonic    = "PSLLDQ"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x73
                           , legacyOpcodeExt       = Just 7
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x73
                           , vexOpcodeExt          = Just 7
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Vvvv
                                                     , mvec128 RO
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x73
                           , vexOpcodeExt          = Just 7
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Vvvv
                                                     , mvec256 RO
                                                     , imm8
                                                     ]
                           }

                       ]
   }

i_psllw :: X86Insn
i_psllw = insn
   { insnDesc        = "Shift packed data left logical"
   , insnMnemonic    = "PSLLW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xF1
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xF1
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x71
                           , legacyOpcodeExt       = Just 6
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , imm8
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x71
                           , legacyOpcodeExt       = Just 6
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xF1
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xF1
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x71
                           , vexOpcodeExt          = Just 6
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Vvvv
                                                     , vec128 RO RM
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x71
                           , vexOpcodeExt          = Just 6
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Vvvv
                                                     , vec256 RO RM
                                                     , imm8
                                                     ]
                           }
                       ]
   }


i_pslld :: X86Insn
i_pslld = insn
   { insnDesc        = "Shift packed data left logical"
   , insnMnemonic    = "PSLLD"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xF2
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xF2
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x72
                           , legacyOpcodeExt       = Just 6
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , imm8
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x72
                           , legacyOpcodeExt       = Just 6
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xF2
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xF2
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x72
                           , vexOpcodeExt          = Just 6
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Vvvv
                                                     , vec128 RO RM
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x72
                           , vexOpcodeExt          = Just 6
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Vvvv
                                                     , vec256 RO RM
                                                     , imm8
                                                     ]
                           }
                       ]
   }


i_psllq :: X86Insn
i_psllq = insn
   { insnDesc        = "Shift packed data left logical"
   , insnMnemonic    = "PSLLD"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xF3
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xF3
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x73
                           , legacyOpcodeExt       = Just 6
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , imm8
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x73
                           , legacyOpcodeExt       = Just 6
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xF3
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xF3
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x73
                           , vexOpcodeExt          = Just 6
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Vvvv
                                                     , vec128 RO RM
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x73
                           , vexOpcodeExt          = Just 6
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Vvvv
                                                     , vec256 RO RM
                                                     , imm8
                                                     ]
                           }
                       ]
   }

i_psraw :: X86Insn
i_psraw = insn
   { insnDesc        = "Shift packed data right arithmetic"
   , insnMnemonic    = "PSRAW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xE1
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xE1
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x71
                           , legacyOpcodeExt       = Just 4
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , imm8
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x71
                           , legacyOpcodeExt       = Just 4
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xE1
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xE1
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x71
                           , vexOpcodeExt          = Just 4
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Vvvv
                                                     , vec128 RO RM
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x71
                           , vexOpcodeExt          = Just 4
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Vvvv
                                                     , vec256 RO RM
                                                     , imm8
                                                     ]
                           }
                       ]
   }


i_psrad :: X86Insn
i_psrad = insn
   { insnDesc        = "Shift packed data right arithmetic"
   , insnMnemonic    = "PSRAD"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xE2
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xE2
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x72
                           , legacyOpcodeExt       = Just 4
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , imm8
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x72
                           , legacyOpcodeExt       = Just 4
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xE2
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xE2
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x72
                           , vexOpcodeExt          = Just 4
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Vvvv
                                                     , vec128 RO RM
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x72
                           , vexOpcodeExt          = Just 4
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Vvvv
                                                     , vec256 RO RM
                                                     , imm8
                                                     ]
                           }
                       ]
   }

i_psrldq :: X86Insn
i_psrldq = insn
   { insnDesc        = "Shift double quadword right logical"
   , insnMnemonic    = "PSRLDQ"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x73
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW RM
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x73
                           , vexOpcodeExt          = Just 3
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Vvvv
                                                     , vec128 RO RM
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x73
                           , vexOpcodeExt          = Just 3
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Vvvv
                                                     , vec256 RO RM
                                                     , imm8
                                                     ]
                           }
                       ]
   }

i_psrlw :: X86Insn
i_psrlw = insn
   { insnDesc        = "Shift packed data right logical"
   , insnMnemonic    = "PSRLW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xD1
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xD1
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x71
                           , legacyOpcodeExt       = Just 2
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , imm8
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x71
                           , legacyOpcodeExt       = Just 2
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xD1
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xD1
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x71
                           , vexOpcodeExt          = Just 2
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Vvvv
                                                     , vec128 RO RM
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x71
                           , vexOpcodeExt          = Just 2
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Vvvv
                                                     , vec256 RO RM
                                                     , imm8
                                                     ]
                           }
                       ]
   }

i_psrld :: X86Insn
i_psrld = insn
   { insnDesc        = "Shift packed data right logical"
   , insnMnemonic    = "PSRLD"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xD2
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xD2
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x72
                           , legacyOpcodeExt       = Just 2
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , imm8
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x72
                           , legacyOpcodeExt       = Just 2
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xD2
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xD2
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x72
                           , vexOpcodeExt          = Just 2
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Vvvv
                                                     , vec128 RO RM
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x72
                           , vexOpcodeExt          = Just 2
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Vvvv
                                                     , vec256 RO RM
                                                     , imm8
                                                     ]
                           }
                       ]
   }


i_psrlq :: X86Insn
i_psrlq = insn
   { insnDesc        = "Shift packed data right logical"
   , insnMnemonic    = "PSRLQ"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xD3
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xD3
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x73
                           , legacyOpcodeExt       = Just 2
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , imm8
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x73
                           , legacyOpcodeExt       = Just 2
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xD3
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xD3
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x73
                           , vexOpcodeExt          = Just 2
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Vvvv
                                                     , vec128 RO RM
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x73
                           , vexOpcodeExt          = Just 2
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Vvvv
                                                     , vec256 RO RM
                                                     , imm8
                                                     ]
                           }
                       ]
   }

i_psubb :: X86Insn
i_psubb = insn
   { insnDesc        = "Subtract packed integers"
   , insnMnemonic    = "PSUBB"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xF8
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 WO Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xF8
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xF8
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xF8
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }

                       ]
   }



i_psubw :: X86Insn
i_psubw = insn
   { insnDesc        = "Subtract packed integers"
   , insnMnemonic    = "PSUBW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xF9
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 WO Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xF9
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xF9
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xF9
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }

                       ]
   }


i_psubd :: X86Insn
i_psubd = insn
   { insnDesc        = "Subtract packed integers"
   , insnMnemonic    = "PSUBD"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xFA
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 WO Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xFA
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xFA
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xFA
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }

                       ]
   }



i_psubq :: X86Insn
i_psubq = insn
   { insnDesc        = "Subtract packed quadword integers"
   , insnMnemonic    = "PSUBQ"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xFB
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec64 WO Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xFB
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xFB
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xFB
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }

                       ]
   }



i_psubsb :: X86Insn
i_psubsb = insn
   { insnDesc        = "Subtract packed signed integers with signed saturation"
   , insnMnemonic    = "PSUBSB"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xE8
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xE8
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xE8
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xE8
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }

                       ]
   }


i_psubsw :: X86Insn
i_psubsw = insn
   { insnDesc        = "Subtract packed signed integers with signed saturation"
   , insnMnemonic    = "PSUBSW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xE9
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xE9
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xE9
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xE9
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }

                       ]
   }

i_psubusb :: X86Insn
i_psubusb = insn
   { insnDesc        = "Subtract packed unsigned integers with unsigned saturation"
   , insnMnemonic    = "PSUBUSB"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xD8
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xD8
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xD8
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xD8
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }

                       ]
   }


i_psubusw :: X86Insn
i_psubusw = insn
   { insnDesc        = "Subtract packed unsigned integers with unsigned saturation"
   , insnMnemonic    = "PSUBUSW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xD9
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xD9
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xD9
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xD9
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }

i_ptest :: X86Insn
i_ptest = insn
   { insnDesc        = "Logical compare"
   , insnMnemonic    = "PTEST"
   , insnFlags       = [ Modified [ZF,CF]
                       , Unset [OF,AF,PF,SF]
                       ]
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F38
                           , legacyOpcode          = 0x17
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 RO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x17
                           , vexLW                 = WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128o256 RO Reg
                                                     , mvec128o256 RO
                                                     ]
                           }
                       ]
   }

i_punpckhbw :: X86Insn
i_punpckhbw = insn
   { insnDesc        = "Unpack high data"
   , insnMnemonic    = "PUNPCKHBW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x68
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x68
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x68
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x68
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }


i_punpckhwd :: X86Insn
i_punpckhwd = insn
   { insnDesc        = "Unpack high data"
   , insnMnemonic    = "PUNPCKHWD"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x69
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x69
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x69
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x69
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }


i_punpckhdq :: X86Insn
i_punpckhdq = insn
   { insnDesc        = "Unpack high data"
   , insnMnemonic    = "PUNPCKHDQ"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x6A
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x6A
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x6A
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x6A
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }


i_punpckhqdq :: X86Insn
i_punpckhqdq = insn
   { insnDesc        = "Unpack high data"
   , insnMnemonic    = "PUNPCKHQDQ"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x6D
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x6D
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x6D
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }


i_punpcklbw :: X86Insn
i_punpcklbw = insn
   { insnDesc        = "Unpack low data"
   , insnMnemonic    = "PUNPCKLBW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x60
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x60
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x60
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x60
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }


i_punpcklwd :: X86Insn
i_punpcklwd = insn
   { insnDesc        = "Unpack low data"
   , insnMnemonic    = "PUNPCKLWD"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x61
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x61
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x61
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x61
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }


i_punpckldq :: X86Insn
i_punpckldq = insn
   { insnDesc        = "Unpack low data"
   , insnMnemonic    = "PUNPCKLDQ"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x62
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x62
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x62
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x62
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }


i_punpcklqdq :: X86Insn
i_punpcklqdq = insn
   { insnDesc        = "Unpack low data"
   , insnMnemonic    = "PUNPCKLQDQ"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x6C
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x6C
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x6C
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }

i_push :: X86Insn
i_push = insn
   { insnDesc        = "Push a value onto the stack"
   , insnMnemonic    = "PUSH"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xFF
                           , legacyOpcodeExt       = Just 6
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , DefaultOperandSize64
                                                     , NoOperandSize64
                                                     ]
                           , legacyParams          = [ mgpr RO
                                                     , regStackPtr RW Implicit
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x50
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , DefaultOperandSize64
                                                     , NoOperandSize64
                                                     ]
                           , legacyParams          = [ gpr RO OpcodeLow3
                                                     , regStackPtr RW Implicit
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x6A
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ imm8
                                                     , regStackPtr RW Implicit
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x68
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , NoOperandSize64
                                                     ]
                           , legacyParams          = [ immOp
                                                     , regStackPtr RW Implicit
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x0E
                           , legacyProperties      = [ LegacyModeSupport ]
                           , legacyParams          = [ reg R_CS RO Implicit
                                                     , regStackPtr RW Implicit
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x1E
                           , legacyProperties      = [ LegacyModeSupport ]
                           , legacyParams          = [ reg R_DS RO Implicit
                                                     , regStackPtr RW Implicit
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x06
                           , legacyProperties      = [ LegacyModeSupport ]
                           , legacyParams          = [ reg R_ES RO Implicit
                                                     , regStackPtr RW Implicit
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x16
                           , legacyProperties      = [ LegacyModeSupport ]
                           , legacyParams          = [ reg R_SS RO Implicit
                                                     , regStackPtr RW Implicit
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xA0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ reg R_FS RO Implicit
                                                     , regStackPtr RW Implicit
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xA8
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ reg R_GS RO Implicit
                                                     , regStackPtr RW Implicit
                                                     ]
                           }
                       ]
   }

i_pusha :: X86Insn
i_pusha = insn
   { insnDesc        = "Push all general-purpose registers"
   , insnMnemonic    = "PUSHA"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x60
                           , legacyProperties      = [ LegacyModeSupport ]
                           , legacyParams          = [ regBasePtr RO Implicit
                                                     , regFam RegFamDI RO Implicit
                                                     , regFam RegFamSI RO Implicit
                                                     , regFam RegFamAX RO Implicit
                                                     , regFam RegFamBX RO Implicit
                                                     , regFam RegFamCX RO Implicit
                                                     , regFam RegFamDX RO Implicit
                                                     , regStackPtr RW Implicit
                                                     ]
                           }
                       ]
   }

i_pushf :: X86Insn
i_pushf = insn
   { insnDesc        = "Push EFLAGS register onto the stack"
   , insnMnemonic    = "PUSHF"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x9C
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ regStackPtr RW Implicit
                                                     ]
                           }
                       ]
   }

i_pxor :: X86Insn
i_pxor = insn
   { insnDesc        = "Logical exclusive OR"
   , insnMnemonic    = "PXOR"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xEF
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension MMX
                                                     ]
                           , legacyParams          = [ vec64 RW Reg
                                                     , mvec64 RO
                                                     ]
                           }
                       , leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xEF
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xEF
                           , vexLW                 = L0_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xEF
                           , vexLW                 = L1_WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , vec256 RO Vvvv
                                                     , mvec256 RO
                                                     ]
                           }
                       ]
   }

i_rcl :: X86Insn
i_rcl = insn
   { insnDesc        = "Rotate left"
   , insnMnemonic    = "RCL"
   , insnFlags       = [Modified [OF,CF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xD0
                           , legacyOpcodeExt       = Just 2
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , constImm 1
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xD2
                           , legacyOpcodeExt       = Just 2
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , reg R_CL RO Implicit
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xC0
                           , legacyOpcodeExt       = Just 2
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , imm8
                                                     ]
                           }
                       ]
   }


i_rcr :: X86Insn
i_rcr = insn
   { insnDesc        = "Rotate right"
   , insnMnemonic    = "RCR"
   , insnFlags       = [Modified [OF,CF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xD0
                           , legacyOpcodeExt       = Just 3
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , constImm 1
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xD2
                           , legacyOpcodeExt       = Just 3
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , reg R_CL RO Implicit
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xC0
                           , legacyOpcodeExt       = Just 3
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , imm8
                                                     ]
                           }
                       ]
   }


i_rol :: X86Insn
i_rol = insn
   { insnDesc        = "Rotate right"
   , insnMnemonic    = "RCR"
   , insnFlags       = [Modified [OF,CF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xD0
                           , legacyOpcodeExt       = Just 0
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , constImm 1
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xD2
                           , legacyOpcodeExt       = Just 0
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , reg R_CL RO Implicit
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xC0
                           , legacyOpcodeExt       = Just 0
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , imm8
                                                     ]
                           }
                       ]
   }


i_ror :: X86Insn
i_ror = insn
   { insnDesc        = "Rotate right"
   , insnMnemonic    = "ROR"
   , insnFlags       = [Modified [OF,CF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xD0
                           , legacyOpcodeExt       = Just 1
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , constImm 1
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xD2
                           , legacyOpcodeExt       = Just 1
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , reg R_CL RO Implicit
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xC0
                           , legacyOpcodeExt       = Just 1
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , imm8
                                                     ]
                           }
                       ]
   }

i_rcpps :: X86Insn
i_rcpps = insn
   { insnDesc        = "Compute reciprocals of packed single-precision FP values"
   , insnMnemonic    = "RCPPS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x53
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ vec128  WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x53
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_rcpss :: X86Insn
i_rcpss = insn
   { insnDesc        = "Compute reciprocal of scalar single-precision FP values"
   , insnMnemonic    = "RCPSS"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF3
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x53
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ vec128  WO Reg
                                                     , mvec128low32 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix = Just 0xF3
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x53
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128 WO Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low32 RO
                                                  ]
                           }
                       ]
   }


i_rdfsbase :: X86Insn
i_rdfsbase = insn
   { insnDesc        = "Read FS segment base"
   , insnMnemonic    = "RDFSBASE"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF3
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xAE
                           , legacyOpcodeExt       = Just 0
                           , legacyProperties      = [ LongModeSupport
                                                     , Extension FSGSBASE
                                                     ]
                           , legacyParams          = [ reg32o64 WO RM
                                                     , reg R_FS RO Implicit
                                                     ]
                           }
                       ]
   }


i_rdgsbase :: X86Insn
i_rdgsbase = insn
   { insnDesc        = "Read GS segment base"
   , insnMnemonic    = "RDGSBASE"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF3
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xAE
                           , legacyOpcodeExt       = Just 1
                           , legacyProperties      = [ LongModeSupport
                                                     , Extension FSGSBASE
                                                     ]
                           , legacyParams          = [ reg32o64 WO RM
                                                     , reg R_GS RO Implicit
                                                     ]
                           }
                       ]
   }


i_rdmsr :: X86Insn
i_rdmsr = insn
   { insnDesc        = "Read from Model Specific Register (MSR)"
   , insnMnemonic    = "RDMSR"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x32
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ eDXeAX WO
                                                     , reg R_ECX RO Implicit
                                                     ]
                           }
                       ]
   }


i_rdpkru :: X86Insn
i_rdpkru = insn
   { insnDesc        = "Read protection key rights for user pages"
   , insnMnemonic    = "RDPKRU"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x01
                           , legacyOpcodeFullExt   = Just 0xEE
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension OSPKE
                                                     ]
                           , legacyParams          = [ rAX WO
                                                     , rDX WO
                                                     , reg R_ECX RO Implicit
                                                     ]
                           }
                       ]
   }


i_rdpmc :: X86Insn
i_rdpmc = insn
   { insnDesc        = "Read performance-monitoring counters"
   , insnMnemonic    = "RDPMC"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x33
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ eDXeAX WO
                                                     , reg R_ECX RO Implicit
                                                     ]
                           }
                       ]
   }


i_rdrand :: X86Insn
i_rdrand = insn
   { insnDesc        = "Read random number"
   , insnMnemonic    = "RDRAND"
   , insnFlags       = [ Modified [CF]
                       , Unset [OF,SF,ZF,AF,PF]
                       ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xC7
                           , legacyOpcodeExt       = Just 6
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ gpr WO RM ]
                           }
                       ]
   }


i_rdseed :: X86Insn
i_rdseed = insn
   { insnDesc        = "Read random SEED"
   , insnMnemonic    = "RDSEED"
   , insnFlags       = [ Modified [CF]
                       , Unset [OF,SF,ZF,AF,PF]
                       ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xC7
                           , legacyOpcodeExt       = Just 7
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ gpr WO RM ]
                           }
                       ]
   }


i_rdtsc :: X86Insn
i_rdtsc = insn
   { insnDesc        = "Read time-stamp counter"
   , insnMnemonic    = "RDTSC"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x31
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ eDXeAX WO ]
                           }
                       ]
   }


i_rdtscp :: X86Insn
i_rdtscp = insn
   { insnDesc        = "Read time-stamp counter and processor ID"
   , insnMnemonic    = "RDTSCP"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x01
                           , legacyOpcodeFullExt   = Just 0xF9
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ eDXeAX WO
                                                     , reg R_ECX WO Implicit
                                                     ]
                           }
                       ]
   }


i_ret :: X86Insn
i_ret = insn
   { insnDesc        = "Return from procedure (near)"
   , insnMnemonic    = "RET"
   , insnEncodings   = [ leg
                           { legacyOpcode          = 0xC3
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           }
                       , leg
                           { legacyOpcode          = 0xC2
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ imm16
                                                     , regStackPtr WO Implicit
                                                     ]
                           }
                       ]
   }


i_retfar :: X86Insn
i_retfar = insn
   { insnDesc        = "Return from procedure (far)"
   , insnMnemonic    = "FARRET"
   , insnEncodings   = [ leg
                           { legacyOpcode          = 0xCB
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           }
                       , leg
                           { legacyOpcode          = 0xCA
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ imm16
                                                     , regStackPtr WO Implicit
                                                     ]
                           }
                       ]
   }

i_rorx :: X86Insn
i_rorx = insn
   { insnDesc           = "Rotate right logical without affecting flags"
   , insnMnemonic       = "RORX"
   , insnEncodings      = [ vex
                              { vexMandatoryPrefix = Just 0xF2
                              , vexOpcodeMap       = MapVex 0x03
                              , vexOpcode          = 0xF0
                              , vexLW              = L0
                              , vexProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension BMI2
                                                     ]
                              , vexParams          = [ reg32o64 WO Reg
                                                     , reg32o64 RO RM
                                                     , imm8
                                                     ]
                              }
                          ]
   }

i_roundpd :: X86Insn
i_roundpd = insn
   { insnDesc        = "Round packed double precision floating-point values"
   , insnMnemonic    = "ROUNDPD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F3A
                           , legacyOpcode          = 0x09
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x03
                           , vexOpcode          = 0x09
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , mvec128o256 RO
                                                  , imm8
                                                  ]
                           }
                       ]
   }


i_roundps :: X86Insn
i_roundps = insn
   { insnDesc        = "Round packed single precision floating-point values"
   , insnMnemonic    = "ROUNDPS"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F3A
                           , legacyOpcode          = 0x08
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x03
                           , vexOpcode          = 0x08
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , mvec128o256 RO
                                                  , imm8
                                                  ]
                           }
                       ]
   }


i_roundsd :: X86Insn
i_roundsd = insn
   { insnDesc        = "Round scalar double precision floating-point values"
   , insnMnemonic    = "ROUNDSD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F3A
                           , legacyOpcode          = 0x0B
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x03
                           , vexOpcode          = 0x0B
                           , vexLW              = LWIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128 WO Reg
                                                  , mvec128 RO
                                                  , imm8
                                                  ]
                           }
                       ]
   }


i_roundss :: X86Insn
i_roundss = insn
   { insnDesc        = "Round scalar single precision floating-point values"
   , insnMnemonic    = "ROUNDSS"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F3A
                           , legacyOpcode          = 0x0A
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE4_1
                                                     ]
                           , legacyParams          = [ vec128 WO Reg
                                                     , mvec128 RO
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x03
                           , vexOpcode          = 0x0A
                           , vexLW              = LWIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128 WO Reg
                                                  , mvec128 RO
                                                  , imm8
                                                  ]
                           }
                       ]
   }

i_rsm :: X86Insn
i_rsm = insn
   { insnDesc        = "Resume from system management mode"
   , insnMnemonic    = "RSL"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xAA
                           , legacyProperties      = [ LegacyModeSupport
                                                     ]
                           }
                       ]
   }

i_rsqrtps :: X86Insn
i_rsqrtps = insn
   { insnDesc        = "Compute reciprocals of square roots of packed single-precision FP values"
   , insnMnemonic    = "RSQRTPS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x52
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ vec128  WO Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x52
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_rsqrtss :: X86Insn
i_rsqrtss = insn
   { insnDesc        = "Compute reciprocal of square root of scalar single-precision FP values"
   , insnMnemonic    = "RSQRTSS"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF3
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x52
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ vec128  WO Reg
                                                     , mvec128low32 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix = Just 0xF3
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x52
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128 WO Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low32 RO
                                                  ]
                           }
                       ]
   }


i_sahf :: X86Insn
i_sahf = insn
   { insnDesc        = "Store AH into flags"
   , insnMnemonic    = "SAHF"
   , insnFlags       = [ Modified allFlags ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x9E
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ reg R_AX RO Implicit ]
                           }
                       ]
   }

i_shl :: X86Insn
i_shl = insn
   { insnDesc        = "Shift left"
   , insnMnemonic    = "SHL (SAL)"
   , insnFlags       = [ Modified [OF,CF,SF,ZF,PF]
                       , Undefined [AF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xD0
                           , legacyOpcodeExt       = Just 4
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , constImm 1
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xD2
                           , legacyOpcodeExt       = Just 4
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , reg R_CL RO Implicit
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xC0
                           , legacyOpcodeExt       = Just 4
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , imm8
                                                     ]
                           }
                       ]
   }


i_sar :: X86Insn
i_sar = insn
   { insnDesc        = "Arithmetic shift right"
   , insnMnemonic    = "SAR"
   , insnFlags       = [ Modified [OF,CF,SF,ZF,PF]
                       , Undefined [AF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xD0
                           , legacyOpcodeExt       = Just 7
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , constImm 1
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xD2
                           , legacyOpcodeExt       = Just 7
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , reg R_CL RO Implicit
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xC0
                           , legacyOpcodeExt       = Just 7
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , imm8
                                                     ]
                           }
                       ]
   }


i_shr :: X86Insn
i_shr = insn
   { insnDesc        = "Shift right"
   , insnMnemonic    = "SHR"
   , insnFlags       = [ Modified [OF,CF,SF,ZF,PF]
                       , Undefined [AF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xD0
                           , legacyOpcodeExt       = Just 5
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , constImm 1
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xD2
                           , legacyOpcodeExt       = Just 5
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , reg R_CL RO Implicit
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xC0
                           , legacyOpcodeExt       = Just 5
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , imm8
                                                     ]
                           }
                       ]
   }

i_sarx :: X86Insn
i_sarx = insn
   { insnDesc           = "Arithmetic shift right without affecting flags"
   , insnMnemonic       = "SARX"
   , insnEncodings      = [ vex
                              { vexMandatoryPrefix = Just 0xF3
                              , vexOpcodeMap       = MapVex 0x02
                              , vexOpcode          = 0xF7
                              , vexLW              = L0
                              , vexProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension BMI2
                                                     ]
                              , vexParams          = [ reg32o64 WO Reg
                                                     , rm32o64 RO
                                                     , reg32o64 RO Vvvv
                                                     ]
                              }
                          ]
   }

i_shlx :: X86Insn
i_shlx = insn
   { insnDesc           = "Shift left without affecting flags"
   , insnMnemonic       = "SHLX"
   , insnEncodings      = [ vex
                              { vexMandatoryPrefix = Just 0x66
                              , vexOpcodeMap       = MapVex 0x02
                              , vexOpcode          = 0xF7
                              , vexLW              = L0
                              , vexProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension BMI2
                                                     ]
                              , vexParams          = [ reg32o64 WO Reg
                                                     , rm32o64 RO
                                                     , reg32o64 RO Vvvv
                                                     ]
                              }
                          ]
   }


i_shrx :: X86Insn
i_shrx = insn
   { insnDesc           = "Shift right without affecting flags"
   , insnMnemonic       = "SHRX"
   , insnEncodings      = [ vex
                              { vexMandatoryPrefix = Just 0xF2
                              , vexOpcodeMap       = MapVex 0x02
                              , vexOpcode          = 0xF7
                              , vexLW              = L0
                              , vexProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension BMI2
                                                     ]
                              , vexParams          = [ reg32o64 WO Reg
                                                     , rm32o64 RO
                                                     , reg32o64 RO Vvvv
                                                     ]
                              }
                          ]
   }

i_sbb :: X86Insn
i_sbb = insn
   { insnDesc        = "Integer subtraction with borrow"
   , insnMnemonic    = "SBB"
   , insnFlags       = [Modified [OF,SF,ZF,AF,CF,PF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x1C
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ regAccu RW
                                                     , immSE
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x18
                           , legacyNoForce8bit     = Just 0
                           , legacyReversable      = Just 1
                           , legacyProperties      = [ Lockable
                                                     , LegacyModeSupport
                                                     , LongModeSupport
                                                     , HLE XBoth
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , gpr RO Reg
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x80
                           , legacyOpcodeExt       = Just 3
                           , legacyNoForce8bit     = Just 0
                           , legacySignExtendable  = Just 1
                           , legacyProperties      = [ Lockable
                                                     , LegacyModeSupport
                                                     , LongModeSupport
                                                     , HLE XBoth
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , immSE
                                                     ]
                           }
                       ]
   }

i_scas :: X86Insn
i_scas = insn
   { insnDesc        = "Scan string"
   , insnMnemonic    = "SCAS"
   , insnFlags       = [Modified [CF,OF,SF,ZF,AF,PF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0xAE
                           , legacyNoForce8bit  = Just 0
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Repeatable
                                                  ]
                           , legacyParams       = [ mESrDI RO
                                                  , regAccu RO
                                                  ]
                           }
                       ]
   }

i_seta :: X86Insn
i_seta = insn
   { insnDesc        = "Set if above"
   , insnMnemonic    = "SETA/SETNBE"
   , insnFlags       = [ Read [CF,ZF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x97
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ rm8 RW ]
                           }
                       ]
   }

i_setae :: X86Insn
i_setae = insn
   { insnDesc        = "Set if above or equal"
   , insnMnemonic    = "SETAE/SETNB/SETNC"
   , insnFlags       = [ Read [CF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x93
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ rm8 RW ]
                           }
                       ]
   }

i_setb :: X86Insn
i_setb = insn
   { insnDesc        = "Set if below"
   , insnMnemonic    = "SETB/SETC/SETNAE"
   , insnFlags       = [ Read [CF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x92
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ rm8 RW ]
                           }
                       ]
   }

i_setbe :: X86Insn
i_setbe = insn
   { insnDesc        = "Set if below or equal"
   , insnMnemonic    = "SETBE/SETNA"
   , insnFlags       = [ Read [CF,ZF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x96
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ rm8 RW ]
                           }
                       ]
   }


i_sete :: X86Insn
i_sete = insn
   { insnDesc        = "Set if equal"
   , insnMnemonic    = "SETE/SETZ"
   , insnFlags       = [ Read [ZF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x94
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ rm8 RW ]
                           }
                       ]
   }

i_setg :: X86Insn
i_setg = insn
   { insnDesc        = "Set if greater"
   , insnMnemonic    = "SETG/SETNLE"
   , insnFlags       = [ Read [ZF,SF,OF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x9F
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ rm8 RW ]
                           }
                       ]
   }

i_setge :: X86Insn
i_setge = insn
   { insnDesc        = "Set if greater or equal"
   , insnMnemonic    = "SETGE/SETNL"
   , insnFlags       = [ Read [SF,OF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x9D
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ rm8 RW ]
                           }
                       ]
   }

i_setl :: X86Insn
i_setl = insn
   { insnDesc        = "Set if less"
   , insnMnemonic    = "SETL/SETNGE"
   , insnFlags       = [ Read [SF,OF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x9C
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ rm8 RW ]
                           }
                       ]
   }

i_setle :: X86Insn
i_setle = insn
   { insnDesc        = "Set if less or equal"
   , insnMnemonic    = "SETLE/SETNG"
   , insnFlags       = [ Read [ZF,SF,OF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x9E
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ rm8 RW ]
                           }
                       ]
   }

i_setne :: X86Insn
i_setne = insn
   { insnDesc        = "Set if not equal"
   , insnMnemonic    = "SETNE/SETNZ"
   , insnFlags       = [ Read [ZF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x95
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ rm8 RW ]
                           }
                       ]
   }

i_setno :: X86Insn
i_setno = insn
   { insnDesc        = "Set if not overflow"
   , insnMnemonic    = "SETNO"
   , insnFlags       = [ Read [OF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x91
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ rm8 RW ]
                           }
                       ]
   }

i_setnp :: X86Insn
i_setnp = insn
   { insnDesc        = "Set if not parity"
   , insnMnemonic    = "SETNP/SETPO"
   , insnFlags       = [ Read [PF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x9B
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ rm8 RW ]
                           }
                       ]
   }

i_setns :: X86Insn
i_setns = insn
   { insnDesc        = "Set if not sign"
   , insnMnemonic    = "SETNS"
   , insnFlags       = [ Read [SF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x99
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ rm8 RW ]
                           }
                       ]
   }

i_seto :: X86Insn
i_seto = insn
   { insnDesc        = "Set if overflow"
   , insnMnemonic    = "SETO"
   , insnFlags       = [ Read [OF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x90
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ rm8 RW ]
                           }
                       ]
   }

i_setp :: X86Insn
i_setp = insn
   { insnDesc        = "Set if parity"
   , insnMnemonic    = "SETP/SETPE"
   , insnFlags       = [ Read [PF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x9A
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ rm8 RW ]
                           }
                       ]
   }

i_sets :: X86Insn
i_sets = insn
   { insnDesc        = "Set if sign"
   , insnMnemonic    = "SETS"
   , insnFlags       = [ Read [SF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x98
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ rm8 RW ]
                           }
                       ]
   }

i_sfence :: X86Insn
i_sfence = insn
   { insnDesc        = "Store fence"
   , insnMnemonic    = "SFENCE"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xAE
                           , legacyOpcodeFullExt   = Just 0xF8
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           }
                       ]
   }

i_sgdt :: X86Insn
i_sgdt = insn
   { insnDesc        = "Store global descriptor table register"
   , insnMnemonic    = "SGDT"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x01
                           , legacyOpcodeExt       = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mdt WO ]
                           }
                       ]
   }

i_shld :: X86Insn
i_shld = insn
   { insnDesc        = "Double precision shift left"
   , insnMnemonic    = "SHLD"
   , insnFlags       = [ Modified [OF,CF,SF,ZF,PF]
                       , Undefined [AF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xA4
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , gpr RO Reg
                                                     , imm8
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xA5
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , gpr RO Reg
                                                     , reg R_CL RO Implicit
                                                     ]
                           }
                       ]
   }


i_shrd :: X86Insn
i_shrd = insn
   { insnDesc        = "Double precision shift right"
   , insnMnemonic    = "SHRD"
   , insnFlags       = [ Modified [OF,CF,SF,ZF,PF]
                       , Undefined [AF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xAC
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , gpr RO Reg
                                                     , imm8
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xAD
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , gpr RO Reg
                                                     , reg R_CL RO Implicit
                                                     ]
                           }
                       ]
   }

i_shufpd :: X86Insn
i_shufpd = insn
   { insnDesc        = "Shuffle packed double-precision floating-point values"
   , insnMnemonic    = "SHUFPD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix    = Just 0x66
                           , legacyOpcodeMap          = Map0F
                           , legacyOpcode             = 0xC6
                           , legacyProperties         = [ LegacyModeSupport
                                                        , LongModeSupport
                                                        , Extension SSE2
                                                        ]
                           , legacyParams             = [ vec128 RW Reg
                                                        , mvec128 RO
                                                        , imm8
                                                        ]
                           }
                       ]
   }

i_vshufpd :: X86Insn
i_vshufpd = insn
   { insnDesc        = "Shuffle packed double-precision floating-point values"
   , insnMnemonic    = "VSHUFPD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0xC6
                           , vexLW                 = WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128o256 WO Reg
                                                     , vec128o256 RO Vvvv
                                                     , mvec128o256 RO
                                                     , imm8
                                                     ]
                           }
                       ]
   }

i_shufps :: X86Insn
i_shufps = insn
   { insnDesc        = "Shuffle packed single-precision floating-point values"
   , insnMnemonic    = "SHUFPS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0xC6
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension SSE
                                                  ]
                           , legacyParams       = [ vec128 RW Reg
                                                  , mvec128 RO
                                                  , imm8
                                                  ]
                           }
                       ]
   }

i_vshufps :: X86Insn
i_vshufps = insn
   { insnDesc        = "Shuffle packed single-precision floating-point values"
   , insnMnemonic    = "VSHUFPS"
   , insnEncodings   = [ vex
                           { vexOpcodeMap    = MapVex 0x01
                           , vexOpcode       = 0xC6
                           , vexLW           = WIG
                           , vexProperties   = [ LegacyModeSupport
                                               , LongModeSupport
                                               , Extension AVX
                                               ]
                           , vexParams       = [ vec128o256 WO Reg
                                               , vec128o256 RO Vvvv
                                               , mvec128o256 RO
                                               , imm8
                                               ]
                           }
                       ]
   }

i_sidt :: X86Insn
i_sidt = insn
   { insnDesc        = "Store interrupt descriptor table register"
   , insnMnemonic    = "SIDT"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x01
                           , legacyOpcodeExt       = Just 1
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mdt WO ]
                           }
                       ]
   }

i_sldt :: X86Insn
i_sldt = insn
   { insnDesc        = "Store local descriptor table register"
   , insnMnemonic    = "SLDT"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x00
                           , legacyOpcodeExt       = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     -- TODO: not supported in
                                                     -- real/virtual mode
                                                     ]
                           , legacyParams          = [ rm16 WO ]
                           }
                       ]
   }

i_smsw :: X86Insn
i_smsw = insn
   { insnDesc        = "Store machine status word"
   , insnMnemonic    = "SMSW"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x01
                           , legacyOpcodeExt       = Just 4
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ rm16 WO ]
                           }
                       ]
   }

i_sqrtpd :: X86Insn
i_sqrtpd = insn
   { insnDesc        = "Compure square roots of packed double-precision floating-point values"
   , insnMnemonic    = "SQRTPD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix    = Just 0x66
                           , legacyOpcodeMap          = Map0F
                           , legacyOpcode             = 0x51
                           , legacyProperties         = [ LegacyModeSupport
                                                        , LongModeSupport
                                                        , Extension SSE2
                                                        ]
                           , legacyParams             = [ vec128 WO Reg
                                                        , mvec128 RO
                                                        ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x51
                           , vexLW                 = WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128o256 WO Reg
                                                     , mvec128o256 RO
                                                     ]
                           }
                       ]
   }


i_sqrtps :: X86Insn
i_sqrtps = insn
   { insnDesc        = "Compure square roots of packed single-precision floating-point values"
   , insnMnemonic    = "SQRTPS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap          = Map0F
                           , legacyOpcode             = 0x51
                           , legacyProperties         = [ LegacyModeSupport
                                                        , LongModeSupport
                                                        , Extension SSE
                                                        ]
                           , legacyParams             = [ vec128 WO Reg
                                                        , mvec128 RO
                                                        ]
                           }
                       , vex
                           { vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x51
                           , vexLW                 = WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128o256 WO Reg
                                                     , mvec128o256 RO
                                                     ]
                           }
                       ]
   }


i_sqrtsd :: X86Insn
i_sqrtsd = insn
   { insnDesc        = "Compure square root of scalar double-precision floating-point value"
   , insnMnemonic    = "SQRTSD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix    = Just 0xF2
                           , legacyOpcodeMap          = Map0F
                           , legacyOpcode             = 0x51
                           , legacyProperties         = [ LegacyModeSupport
                                                        , LongModeSupport
                                                        , Extension SSE2
                                                        ]
                           , legacyParams             = [ vec128 RW Reg
                                                        , mvec128low64 RO
                                                        ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0xF2
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x51
                           , vexLW                 = LWIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128low64 RO
                                                     ]
                           }
                       ]
   }


i_sqrtss :: X86Insn
i_sqrtss = insn
   { insnDesc        = "Compure square root of scalar single-precision floating-point values"
   , insnMnemonic    = "SQRTSS"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix    = Just 0xF3
                           , legacyOpcodeMap          = Map0F
                           , legacyOpcode             = 0x51
                           , legacyProperties         = [ LegacyModeSupport
                                                        , LongModeSupport
                                                        , Extension SSE
                                                        ]
                           , legacyParams             = [ vec128 RW Reg
                                                        , mvec128low32 RO
                                                        ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0xF3
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x51
                           , vexLW                 = LWIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , vec128 RO Vvvv
                                                     , mvec128low32 RO
                                                     ]
                           }
                       ]
   }

i_stac :: X86Insn
i_stac = insn
   { insnDesc        = "Set AC flag in EFLAGS register"
   , insnMnemonic    = "STAC"
   , insnFlags       = [ St [AC] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x01
                           , legacyOpcodeFullExt   = Just 0xCB
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           }
                       ]
   }


i_stc :: X86Insn
i_stc = insn
   { insnDesc        = "Set carry flag"
   , insnMnemonic    = "STC"
   , insnFlags       = [ St [CF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xF9
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           }
                       ]
   }


i_std :: X86Insn
i_std = insn
   { insnDesc        = "Set direction flag"
   , insnMnemonic    = "STD"
   , insnFlags       = [ St [DF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xFD
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           }
                       ]
   }


i_sti :: X86Insn
i_sti = insn
   { insnDesc        = "Set interrupt flag"
   , insnMnemonic    = "STI"
   , insnFlags       = [ St [IF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xFB
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           }
                       ]
   }

i_stmxcsr :: X86Insn
i_stmxcsr = insn
   { insnDesc        = "Store MXCSR register"
   , insnMnemonic    = "STMXCSR"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xAE
                           , legacyOpcodeExt       = Just 3
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ mem32 WO ]
                           }
                       , vex
                           { vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0xAE
                           , vexOpcodeExt       = Just 3
                           , vexLW              = L0_WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ mem32 WO ]
                           }
                       ]
   }

i_stos :: X86Insn
i_stos = insn
   { insnDesc        = "Store string"
   , insnMnemonic    = "STOS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xAA
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Repeatable
                                                     ]
                           , legacyParams          = [ regAccu RO
                                                     , mESrDI WO
                                                     ]
                           }
                       ]
   }


i_str :: X86Insn
i_str = insn
   { insnDesc        = "Store task register"
   , insnMnemonic    = "STR"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x00
                           , legacyOpcodeExt       = Just 1
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ rm16 WO
                                                     ]
                           }
                       ]
   }

i_sub :: X86Insn
i_sub = insn
   { insnDesc        = "Subtract"
   , insnMnemonic    = "SUB"
   , insnFlags       = [Modified [OF,SF,ZF,AF,CF,PF]]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x2C
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ regAccu RW
                                                     , immSE
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x28
                           , legacyNoForce8bit     = Just 0
                           , legacyReversable      = Just 1
                           , legacyProperties      = [ Lockable
                                                     , LegacyModeSupport
                                                     , LongModeSupport
                                                     , HLE XBoth
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , gpr RO Reg
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x80
                           , legacyOpcodeExt       = Just 5
                           , legacyNoForce8bit     = Just 0
                           , legacySignExtendable  = Just 1
                           , legacyProperties      = [ Lockable
                                                     , LegacyModeSupport
                                                     , LongModeSupport
                                                     , HLE XBoth
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , immSE
                                                     ]
                           }
                       ]
   }

i_subpd :: X86Insn
i_subpd = insn
   { insnDesc        = "Subtract packed double-precision floating-point values"
   , insnMnemonic    = "SUBPD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x5C
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vsubpd :: X86Insn
i_vsubpd = insn
   { insnDesc        = "Subtract packed double-precision floating-point values"
   , insnMnemonic    = "VSUBPD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x5C
                           , vexLW                 = WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128o256 WO Reg
                                                     , vec128o256 RO Vvvv
                                                     , mvec128o256 RO
                                                     ]
                           }
                       ]
   }

i_subps :: X86Insn
i_subps = insn
   { insnDesc        = "Subtract packed single-precision floating-point values"
   , insnMnemonic    = "SUBPS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x5C
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ vec128  RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vsubps :: X86Insn
i_vsubps = insn
   { insnDesc        = "Subtract packed single-precision floating-point values"
   , insnMnemonic    = "VSUBPS"
   , insnEncodings   = [ vex
                           { vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x5C
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }

i_subsd :: X86Insn
i_subsd = insn
   { insnDesc        = "Subtract scalar double-precision floating-point values"
   , insnMnemonic    = "SUBSD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF2
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x5C
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128low64 RO
                                                     ]
                           }
                       ]
   }

i_vsubsd :: X86Insn
i_vsubsd = insn
   { insnDesc        = "Subtract scalar double-precision floating-point values"
   , insnMnemonic    = "VSUBSD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0xF2
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x5C
                           , vexLW              = LWIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128 WO Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low64 RO
                                                  ]
                           }
                       ]
   }

i_subss :: X86Insn
i_subss = insn
   { insnDesc        = "Subtract scalar single-precision floating-point values"
   , insnMnemonic    = "SUBSS"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF3
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x5C
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128low32 RO
                                                     ]
                           }
                       ]
   }

i_vsubss :: X86Insn
i_vsubss = insn
   { insnDesc        = "Subtract scalar single-precision floating-point values"
   , insnMnemonic    = "VSUBSS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0xF3
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x5C
                           , vexLW              = LWIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128 WO Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low32 RO
                                                  ]
                           }
                       ]
   }

i_swapgs :: X86Insn
i_swapgs = insn
   { insnDesc        = "Swap GS base register"
   , insnMnemonic    = "SWAPGS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x01
                           , legacyOpcodeFullExt   = Just 0xF8
                           , legacyProperties      = [ LongModeSupport
                                                     ]
                           , legacyParams          = [ reg R_GS WO Implicit
                                                     ]
                           }
                       ]
   }


i_syscall :: X86Insn
i_syscall = insn
   { insnDesc        = "Fast system call"
   , insnMnemonic    = "SYSCALL"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x05
                           , legacyProperties      = [ LongModeSupport
                                                     ]
                           }
                       ]
   }


i_sysenter :: X86Insn
i_sysenter = insn
   { insnDesc        = "Fast system call"
   , insnMnemonic    = "SYSENTER"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x34
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           }
                       ]
   }


i_sysexit :: X86Insn
i_sysexit = insn
   { insnDesc        = "Fast return from fast system call"
   , insnMnemonic    = "SYSEXIT"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x35
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           }
                       ]
   }


i_sysret :: X86Insn
i_sysret = insn
   { insnDesc        = "Return from fast system call"
   , insnMnemonic    = "SYSRET"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x07
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           }
                       ]
   }

i_test :: X86Insn
i_test = insn
   { insnDesc        = "Logical compare"
   , insnMnemonic    = "TEST"
   , insnFlags       = [ Modified [SF,ZF,PF]
                       , Unset [OF,CF]
                       , Undefined [AF]
                       ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0xA8
                           , legacyNoForce8bit  = Just 0
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ regAccu RO
                                                  , immSE
                                                  ]
                           }
                       , leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0x84
                           , legacyNoForce8bit  = Just 0
                           , legacyProperties   = [ Lockable
                                                  , LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ mgpr RO
                                                  , gpr RO Reg
                                                  ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xF6
                           , legacyOpcodeExt       = Just 0
                           , legacyNoForce8bit     = Just 0
                           , legacySignExtendable  = Just 1
                           , legacyProperties      = [ Lockable
                                                     , LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ mgpr RO
                                                     , immSE
                                                     ]
                           }
                       ]
   }

i_tzcnt :: X86Insn
i_tzcnt = insn
   { insnDesc        = "Count the number of trailing zero bits"
   , insnMnemonic    = "TZCNT"
   , insnFlags       = [ Modified  [CF,ZF]
                       , Undefined [AF,PF,OF,SF]
                       ]
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF3
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xBC
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension BMI1
                                                     ]
                           , legacyParams          = [ gpr WO Reg
                                                     , mgpr RO
                                                     ]
                           }
                       ]
   }

i_ucomisd :: X86Insn
i_ucomisd = insn
   { insnDesc        = "Compare scalar unordered double-precision floating-point values and set EFLAGS"
   , insnMnemonic    = "(V)UCOMISD"
   , insnFlags       = [ Modified [ZF,PF,CF]
                       , Unset    [OF,SF,AF]
                       ]
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix    = Just 0x66
                           , legacyOpcodeMap          = Map0F
                           , legacyOpcode             = 0x2E
                           , legacyProperties         = [ LegacyModeSupport
                                                        , LongModeSupport
                                                        , Extension SSE2
                                                        ]
                           , legacyParams             = [ vec128low64 RO Reg
                                                        , mvec128low64 RO
                                                        ]
                           }
                       , vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x2E
                           , vexLW              = LWIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128low64 RO Reg
                                                  , mvec128low64 RO
                                                  ]
                           }
                       ]
   }

i_ucomiss :: X86Insn
i_ucomiss = insn
   { insnDesc        = "Compare scalar unordered single-precision floating-point values and set EFLAGS"
   , insnMnemonic    = "(V)UCOMISS"
   , insnFlags       = [ Modified [ZF,PF,CF]
                       , Unset    [OF,SF,AF]
                       ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0x2E
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension SSE
                                                  ]
                           , legacyParams       = [ vec128low32 RO Reg
                                                  , mvec128low32 RO
                                                  ]
                           }
                       , vex
                           { vexOpcodeMap    = MapVex 0x01
                           , vexOpcode       = 0x2E
                           , vexLW           = LWIG
                           , vexProperties   = [ LegacyModeSupport
                                               , LongModeSupport
                                               , Extension AVX
                                               ]
                           , vexParams       = [ vec128low32 RO Reg
                                               , mvec128low32 RO
                                               ]
                           }
                       ]
   }


i_ud2 :: X86Insn
i_ud2 = insn
   { insnDesc        = "Raise invalid opcode exception"
   , insnMnemonic    = "UD2"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x0B
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           }
                       ]
   }

i_unpckhpd :: X86Insn
i_unpckhpd = insn
   { insnDesc        = "Unpack and interleave high packed double-precision FP values"
   , insnMnemonic    = "PUNPCKHPD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x15
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x15
                           , vexLW                 = WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128o256 WO Reg
                                                     , vec128o256 RO Vvvv
                                                     , mvec128o256 RO
                                                     ]
                           }
                       ]
   }


i_unpckhps :: X86Insn
i_unpckhps = insn
   { insnDesc        = "Unpack and interleave high packed single-precision FP values"
   , insnMnemonic    = "PUNPCKHPS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x15
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x15
                           , vexLW                 = WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128o256 WO Reg
                                                     , vec128o256 RO Vvvv
                                                     , mvec128o256 RO
                                                     ]
                           }
                       ]
   }


i_unpcklpd :: X86Insn
i_unpcklpd = insn
   { insnDesc        = "Unpack and interleave low packed double-precision FP values"
   , insnMnemonic    = "PUNPCKLPD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x14
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x14
                           , vexLW                 = WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128o256 WO Reg
                                                     , vec128o256 RO Vvvv
                                                     , mvec128o256 RO
                                                     ]
                           }
                       ]
   }


i_unpcklps :: X86Insn
i_unpcklps = insn
   { insnDesc        = "Unpack and interleave low packed single-precision FP values"
   , insnMnemonic    = "PUNPCKLPS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x14
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       , vex
                           { vexOpcodeMap          = MapVex 0x01
                           , vexOpcode             = 0x14
                           , vexLW                 = WIG
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128o256 WO Reg
                                                     , vec128o256 RO Vvvv
                                                     , mvec128o256 RO
                                                     ]
                           }
                       ]
   }


i_vbroadcastss :: X86Insn
i_vbroadcastss = insn
   { insnDesc        = "Broadcast floating-point data"
   , insnMnemonic    = "VBROADCASTSS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x18
                           , vexLW                 = W0
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec128o256 WO Reg
                                                     , mem32 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x18
                           , vexLW                 = W0
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec128o256 WO Reg
                                                     , vec128low32 RO RM
                                                     ]
                           }

                       ]
   }


i_vbroadcastsd :: X86Insn
i_vbroadcastsd = insn
   { insnDesc        = "Broadcast floating-point data"
   , insnMnemonic    = "VBROADCASTSD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x19
                           , vexLW                 = L1_W0
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , mem64 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x19
                           , vexLW                 = L1_W0
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX2
                                                     ]
                           , vexParams             = [ vec128o256 WO Reg
                                                     , vec128low64 RO RM
                                                     ]
                           }

                       ]
   }


i_vbroadcastf128 :: X86Insn
i_vbroadcastf128 = insn
   { insnDesc        = "Broadcast floating-point data"
   , insnMnemonic    = "VBROADCASTF128"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x1A
                           , vexLW                 = L1_W0
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension AVX
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , mem128 RO
                                                     ]
                           }
                       ]
   }


i_vcvtph2ps :: X86Insn
i_vcvtph2ps = insn
   { insnDesc        = "Convert 16-bit FP values to single-precision FP values"
   , insnMnemonic    = "VCVTPH2PS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x13
                           , vexLW                 = L0_W0
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension F16C
                                                     ]
                           , vexParams             = [ vec128 WO Reg
                                                     , mvec128low64 RO
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x02
                           , vexOpcode             = 0x13
                           , vexLW                 = L1_W0
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension F16C
                                                     ]
                           , vexParams             = [ vec256 WO Reg
                                                     , mvec128 RO
                                                     ]
                           }

                       ]
   }


i_vcvtps2ph :: X86Insn
i_vcvtps2ph = insn
   { insnDesc        = "Convert single-precision FP value to 16-bit FP value"
   , insnMnemonic    = "VCVTPS2PH"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x03
                           , vexOpcode             = 0x1D
                           , vexLW                 = L0_W0
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension F16C
                                                     ]
                           , vexParams             = [ mvec128low64 WO
                                                     , vec128 RO Reg
                                                     , imm8
                                                     ]
                           }
                       , vex
                           { vexMandatoryPrefix    = Just 0x66
                           , vexOpcodeMap          = MapVex 0x03
                           , vexOpcode             = 0x1D
                           , vexLW                 = L1_W0
                           , vexProperties         = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension F16C
                                                     ]
                           , vexParams             = [ mvec128 WO
                                                     , vec256 RO Reg
                                                     , imm8
                                                     ]
                           }
                       ]
   }


i_verr :: X86Insn
i_verr = insn
   { insnDesc        = "Verify a segment for reading"
   , insnMnemonic    = "VERR"
   , insnFlags       = [ Modified [ZF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x00
                           , legacyOpcodeExt       = Just 4
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ rm16 NA ]
                           }
                       ]
   }


i_verw :: X86Insn
i_verw = insn
   { insnDesc        = "Verify a segment for writing"
   , insnMnemonic    = "VERW"
   , insnFlags       = [ Modified [ZF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x00
                           , legacyOpcodeExt       = Just 5
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ rm16 NA ]
                           }
                       ]
   }

i_vextractf128 :: X86Insn
i_vextractf128 = insn
   { insnDesc        = "Extract packed floating-point values"
   , insnMnemonic    = "VEXTRACTF128"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x03
                           , vexOpcode          = 0x19
                           , vexLW              = L1_W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ mvec128 WO
                                                  , vec256 RO Reg
                                                  , imm8
                                                  ]
                           }
                       ]
   }


i_vextracti128 :: X86Insn
i_vextracti128 = insn
   { insnDesc        = "Extract packed integer values"
   , insnMnemonic    = "VEXTRACTI128"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x03
                           , vexOpcode          = 0x39
                           , vexLW              = L1_W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX2
                                                  ]
                           , vexParams          = [ mvec128 WO
                                                  , vec256 RO Reg
                                                  , imm8
                                                  ]
                           }
                       ]
   }

i_vfmadd132pd :: X86Insn
i_vfmadd132pd = insn
   { insnDesc        = "Fused multiply-add of packed double-precision FP values"
   , insnMnemonic    = "VFMADD132PD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x98
                           , vexLW              = W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfmadd213pd :: X86Insn
i_vfmadd213pd = insn
   { insnDesc        = "Fused multiply-add of packed double-precision FP values"
   , insnMnemonic    = "VFMADD213PD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xA8
                           , vexLW              = W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfmadd231pd :: X86Insn
i_vfmadd231pd = insn
   { insnDesc        = "Fused multiply-add of packed double-precision FP values"
   , insnMnemonic    = "VFMADD231PD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xB8
                           , vexLW              = W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfmadd132ps :: X86Insn
i_vfmadd132ps = insn
   { insnDesc        = "Fused multiply-add of packed single-precision FP values"
   , insnMnemonic    = "VFMADD132PS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x98
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfmadd213ps :: X86Insn
i_vfmadd213ps = insn
   { insnDesc        = "Fused multiply-add of packed single-precision FP values"
   , insnMnemonic    = "VFMADD213PS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xA8
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfmadd231ps :: X86Insn
i_vfmadd231ps = insn
   { insnDesc        = "Fused multiply-add of packed single-precision FP values"
   , insnMnemonic    = "VFMADD231PS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xB8
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfmadd132sd :: X86Insn
i_vfmadd132sd = insn
   { insnDesc        = "Fused multiply-add of scalar double-precision FP values"
   , insnMnemonic    = "VFMADD132SD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x99
                           , vexLW              = LIG_W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128 RW Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low64 RO
                                                  ]
                           }
                       ]
   }


i_vfmadd213sd :: X86Insn
i_vfmadd213sd = insn
   { insnDesc        = "Fused multiply-add of scalar double-precision FP values"
   , insnMnemonic    = "VFMADD213SD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xA9
                           , vexLW              = LIG_W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128 RW Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low64 RO
                                                  ]
                           }
                       ]
   }


i_vfmadd231sd :: X86Insn
i_vfmadd231sd = insn
   { insnDesc        = "Fused multiply-add of scalar double-precision FP values"
   , insnMnemonic    = "VFMADD231PD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xB9
                           , vexLW              = LIG_W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128 RW Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low64 RO
                                                  ]
                           }
                       ]
   }


i_vfmadd132ss :: X86Insn
i_vfmadd132ss = insn
   { insnDesc        = "Fused multiply-add of scalar single-precision FP values"
   , insnMnemonic    = "VFMADD132SS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x99
                           , vexLW              = LIG_W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128 RW Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low32 RO
                                                  ]
                           }
                       ]
   }


i_vfmadd213ss :: X86Insn
i_vfmadd213ss = insn
   { insnDesc        = "Fused multiply-add of scalar single-precision FP values"
   , insnMnemonic    = "VFMADD213SS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xA9
                           , vexLW              = LIG_W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128 RW Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low32 RO
                                                  ]
                           }
                       ]
   }


i_vfmadd231ss :: X86Insn
i_vfmadd231ss = insn
   { insnDesc        = "Fused multiply-add of scalar single-precision FP values"
   , insnMnemonic    = "VFMADD231SS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xB9
                           , vexLW              = LIG_W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128 RW Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low32 RO
                                                  ]
                           }
                       ]
   }


i_vfmaddsub132pd :: X86Insn
i_vfmaddsub132pd = insn
   { insnDesc        = "Fused multiply-alternating add/subtract of packed double-precision FP values"
   , insnMnemonic    = "VFMADDSUB132PD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x96
                           , vexLW              = W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfmaddsub213pd :: X86Insn
i_vfmaddsub213pd = insn
   { insnDesc        = "Fused multiply-alternating add/subtract of packed double-precision FP values"
   , insnMnemonic    = "VFMADDSUB213PD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xA6
                           , vexLW              = W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfmaddsub231pd :: X86Insn
i_vfmaddsub231pd = insn
   { insnDesc        = "Fused multiply-alternating add/subtract of packed double-precision FP values"
   , insnMnemonic    = "VFMADDSUB231PD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xB6
                           , vexLW              = W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfmaddsub132ps :: X86Insn
i_vfmaddsub132ps = insn
   { insnDesc        = "Fused multiply-alternating add/subtract of packed single-precision FP values"
   , insnMnemonic    = "VFMADDSUB132PS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x96
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfmaddsub213ps :: X86Insn
i_vfmaddsub213ps = insn
   { insnDesc        = "Fused multiply-alternating add/subtract of packed single-precision FP values"
   , insnMnemonic    = "VFMADDSUB213PS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xA6
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfmaddsub231ps :: X86Insn
i_vfmaddsub231ps = insn
   { insnDesc        = "Fused multiply-alternating add/subtract of packed single-precision FP values"
   , insnMnemonic    = "VFMADDSUB231PS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xB6
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfmsubadd132pd :: X86Insn
i_vfmsubadd132pd = insn
   { insnDesc        = "Fused multiply-alternating subtract/add of packed double-precision FP values"
   , insnMnemonic    = "VFMSUBADD132PD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x97
                           , vexLW              = W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfmsubadd213pd :: X86Insn
i_vfmsubadd213pd = insn
   { insnDesc        = "Fused multiply-alternating subtract/add of packed double-precision FP values"
   , insnMnemonic    = "VFMSUBADD213PD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xA7
                           , vexLW              = W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfmsubadd231pd :: X86Insn
i_vfmsubadd231pd = insn
   { insnDesc        = "Fused multiply-alternating subtract/add of packed double-precision FP values"
   , insnMnemonic    = "VFMSUBADD231PD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xB7
                           , vexLW              = W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfmsubadd132ps :: X86Insn
i_vfmsubadd132ps = insn
   { insnDesc        = "Fused multiply-alternating subtract/add of packed single-precision FP values"
   , insnMnemonic    = "VFMSUBADD132PS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x97
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfmsubadd213ps :: X86Insn
i_vfmsubadd213ps = insn
   { insnDesc        = "Fused multiply-alternating subtract/add of packed single-precision FP values"
   , insnMnemonic    = "VFMSUBADD213PS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xA7
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfmsubadd231ps :: X86Insn
i_vfmsubadd231ps = insn
   { insnDesc        = "Fused multiply-alternating subtract/add of packed single-precision FP values"
   , insnMnemonic    = "VFMSUBADD231PS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xB7
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfmsub132pd :: X86Insn
i_vfmsub132pd = insn
   { insnDesc        = "Fused multiply-subtract of packed double-precision FP values"
   , insnMnemonic    = "VFMSUB132PD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x9A
                           , vexLW              = W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfmsub213pd :: X86Insn
i_vfmsub213pd = insn
   { insnDesc        = "Fused multiply-subtract of packed double-precision FP values"
   , insnMnemonic    = "VFMSUB213PD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xAA
                           , vexLW              = W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfmsub231pd :: X86Insn
i_vfmsub231pd = insn
   { insnDesc        = "Fused multiply-subtract of packed double-precision FP values"
   , insnMnemonic    = "VFMSUB231PD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xBA
                           , vexLW              = W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfmsub132ps :: X86Insn
i_vfmsub132ps = insn
   { insnDesc        = "Fused multiply-subtract of packed single-precision FP values"
   , insnMnemonic    = "VFMSUB132PS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x9A
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfmsub213ps :: X86Insn
i_vfmsub213ps = insn
   { insnDesc        = "Fused multiply-subtract of packed single-precision FP values"
   , insnMnemonic    = "VFMSUB213PS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xAA
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfmsub231ps :: X86Insn
i_vfmsub231ps = insn
   { insnDesc        = "Fused multiply-subtract of packed single-precision FP values"
   , insnMnemonic    = "VFMSUB231PS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xBA
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfmsub132sd :: X86Insn
i_vfmsub132sd = insn
   { insnDesc        = "Fused multiply-subtract of scalar double-precision FP values"
   , insnMnemonic    = "VFMSUB132SD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x9A
                           , vexLW              = LIG_W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128 RW Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low64 RO
                                                  ]
                           }
                       ]
   }


i_vfmsub213sd :: X86Insn
i_vfmsub213sd = insn
   { insnDesc        = "Fused multiply-subtract of scalar double-precision FP values"
   , insnMnemonic    = "VFMSUB213SD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xAA
                           , vexLW              = LIG_W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128 RW Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low64 RO
                                                  ]
                           }
                       ]
   }


i_vfmsub231sd :: X86Insn
i_vfmsub231sd = insn
   { insnDesc        = "Fused multiply-subtract of scalar double-precision FP values"
   , insnMnemonic    = "VFMSUB231PD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xBA
                           , vexLW              = LIG_W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128 RW Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low64 RO
                                                  ]
                           }
                       ]
   }


i_vfmsub132ss :: X86Insn
i_vfmsub132ss = insn
   { insnDesc        = "Fused multiply-subtract of scalar single-precision FP values"
   , insnMnemonic    = "VFMSUB132SS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x9A
                           , vexLW              = LIG_W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128 RW Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low32 RO
                                                  ]
                           }
                       ]
   }


i_vfmsub213ss :: X86Insn
i_vfmsub213ss = insn
   { insnDesc        = "Fused multiply-subtract of scalar single-precision FP values"
   , insnMnemonic    = "VFMSUB213SS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xAA
                           , vexLW              = LIG_W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128 RW Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low32 RO
                                                  ]
                           }
                       ]
   }


i_vfmsub231ss :: X86Insn
i_vfmsub231ss = insn
   { insnDesc        = "Fused multiply-subtract of scalar single-precision FP values"
   , insnMnemonic    = "VFMSUB231SS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xBA
                           , vexLW              = LIG_W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128 RW Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low32 RO
                                                  ]
                           }
                       ]
   }

i_vfnmadd132pd :: X86Insn
i_vfnmadd132pd = insn
   { insnDesc        = "Fused negative multiply-add of packed double-precision FP values"
   , insnMnemonic    = "VFNMADD132PD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x9C
                           , vexLW              = W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfnmadd213pd :: X86Insn
i_vfnmadd213pd = insn
   { insnDesc        = "Fused negative multiply-add of packed double-precision FP values"
   , insnMnemonic    = "VFNMADD213PD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xAC
                           , vexLW              = W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfnmadd231pd :: X86Insn
i_vfnmadd231pd = insn
   { insnDesc        = "Fused inegative multiply-add of packed double-precision FP values"
   , insnMnemonic    = "VFNMADD231PD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xBC
                           , vexLW              = W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfnmadd132ps :: X86Insn
i_vfnmadd132ps = insn
   { insnDesc        = "Fused negative multiply-add of packed single-precision FP values"
   , insnMnemonic    = "VFNMADD132PS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x9C
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfnmadd213ps :: X86Insn
i_vfnmadd213ps = insn
   { insnDesc        = "Fused negative multiply-add of packed single-precision FP values"
   , insnMnemonic    = "VFNMADD213PS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xAC
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfnmadd231ps :: X86Insn
i_vfnmadd231ps = insn
   { insnDesc        = "Fused negative multiply-add of packed single-precision FP values"
   , insnMnemonic    = "VFNMADD231PS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xBC
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfnmadd132sd :: X86Insn
i_vfnmadd132sd = insn
   { insnDesc        = "Fused negative multiply-add of scalar double-precision FP values"
   , insnMnemonic    = "VFNMADD132SD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x9D
                           , vexLW              = LIG_W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128 RW Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low64 RO
                                                  ]
                           }
                       ]
   }


i_vfnmadd213sd :: X86Insn
i_vfnmadd213sd = insn
   { insnDesc        = "Fused negative multiply-add of scalar double-precision FP values"
   , insnMnemonic    = "VFNMADD213SD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xAD
                           , vexLW              = LIG_W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128 RW Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low64 RO
                                                  ]
                           }
                       ]
   }


i_vfnmadd231sd :: X86Insn
i_vfnmadd231sd = insn
   { insnDesc        = "Fused negative multiply-add of scalar double-precision FP values"
   , insnMnemonic    = "VFNMADD231PD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xBD
                           , vexLW              = LIG_W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128 RW Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low64 RO
                                                  ]
                           }
                       ]
   }


i_vfnmadd132ss :: X86Insn
i_vfnmadd132ss = insn
   { insnDesc        = "Fused negative multiply-add of scalar single-precision FP values"
   , insnMnemonic    = "VFNMADD132SS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x9D
                           , vexLW              = LIG_W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128 RW Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low32 RO
                                                  ]
                           }
                       ]
   }


i_vfnmadd213ss :: X86Insn
i_vfnmadd213ss = insn
   { insnDesc        = "Fused negative multiply-add of scalar single-precision FP values"
   , insnMnemonic    = "VFNMADD213SS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xAD
                           , vexLW              = LIG_W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128 RW Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low32 RO
                                                  ]
                           }
                       ]
   }


i_vfnmadd231ss :: X86Insn
i_vfnmadd231ss = insn
   { insnDesc        = "Fused negative multiply-add of scalar single-precision FP values"
   , insnMnemonic    = "VFNMADD231SS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xBD
                           , vexLW              = LIG_W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128 RW Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low32 RO
                                                  ]
                           }
                       ]
   }

i_vfnmsub132pd :: X86Insn
i_vfnmsub132pd = insn
   { insnDesc        = "Fused negative multiply-subtract of packed double-precision FP values"
   , insnMnemonic    = "VFNMSUB132PD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x9E
                           , vexLW              = W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfnmsub213pd :: X86Insn
i_vfnmsub213pd = insn
   { insnDesc        = "Fused negative multiply-subtract of packed double-precision FP values"
   , insnMnemonic    = "VFNMSUB213PD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xAE
                           , vexLW              = W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfnmsub231pd :: X86Insn
i_vfnmsub231pd = insn
   { insnDesc        = "Fused negative multiply-subtract of packed double-precision FP values"
   , insnMnemonic    = "VFNMSUB231PD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xBE
                           , vexLW              = W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfnmsub132ps :: X86Insn
i_vfnmsub132ps = insn
   { insnDesc        = "Fused negative multiply-subtract of packed single-precision FP values"
   , insnMnemonic    = "VFNMSUB132PS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x9E
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfnmsub213ps :: X86Insn
i_vfnmsub213ps = insn
   { insnDesc        = "Fused negative multiply-subtract of packed single-precision FP values"
   , insnMnemonic    = "VFNMSUB213PS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xAE
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfnmsub231ps :: X86Insn
i_vfnmsub231ps = insn
   { insnDesc        = "Fused negative multiply-subtract of packed single-precision FP values"
   , insnMnemonic    = "VFNMSUB231PS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xBE
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vfnmsub132sd :: X86Insn
i_vfnmsub132sd = insn
   { insnDesc        = "Fused negative multiply-subtract of scalar double-precision FP values"
   , insnMnemonic    = "VFNMSUB132SD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x9F
                           , vexLW              = LIG_W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128 RW Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low64 RO
                                                  ]
                           }
                       ]
   }


i_vfnmsub213sd :: X86Insn
i_vfnmsub213sd = insn
   { insnDesc        = "Fused negative multiply-subtract of scalar double-precision FP values"
   , insnMnemonic    = "VFNMSUB213SD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xAF
                           , vexLW              = LIG_W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128 RW Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low64 RO
                                                  ]
                           }
                       ]
   }


i_vfnmsub231sd :: X86Insn
i_vfnmsub231sd = insn
   { insnDesc        = "Fused negative multiply-subtract of scalar double-precision FP values"
   , insnMnemonic    = "VFNMSUB231PD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xBF
                           , vexLW              = LIG_W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128 RW Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low64 RO
                                                  ]
                           }
                       ]
   }


i_vfnmsub132ss :: X86Insn
i_vfnmsub132ss = insn
   { insnDesc        = "Fused negative multiply-subtract of scalar single-precision FP values"
   , insnMnemonic    = "VFNMSUB132SS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x9F
                           , vexLW              = LIG_W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128 RW Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low32 RO
                                                  ]
                           }
                       ]
   }


i_vfnmsub213ss :: X86Insn
i_vfnmsub213ss = insn
   { insnDesc        = "Fused negative multiply-subtract of scalar single-precision FP values"
   , insnMnemonic    = "VFNMSUB213SS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xAF
                           , vexLW              = LIG_W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128 RW Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low32 RO
                                                  ]
                           }
                       ]
   }


i_vfnmsub231ss :: X86Insn
i_vfnmsub231ss = insn
   { insnDesc        = "Fused negative multiply-subtract of scalar single-precision FP values"
   , insnMnemonic    = "VFNMSUB231SS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0xBF
                           , vexLW              = LIG_W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension FMA
                                                  ]
                           , vexParams          = [ vec128 RW Reg
                                                  , vec128 RO Vvvv
                                                  , mvec128low32 RO
                                                  ]
                           }
                       ]
   }


i_vgatherdpd :: X86Insn
i_vgatherdpd = insn
   { insnDesc        = "Gather packed DP FP values using signed dword indices"
   , insnMnemonic    = "VGATHERDPD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x92
                           , vexLW              = W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX2
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , m64vsib32x RO
                                                  , vec128o256 RW Vvvv
                                                  ]
                           }
                       ]
   }


i_vgatherqpd :: X86Insn
i_vgatherqpd = insn
   { insnDesc        = "Gather packed DP FP values using signed qword indices"
   , insnMnemonic    = "VGATHERQPD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x93
                           , vexLW              = W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX2
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , m64vsib64xy RO
                                                  , vec128o256 RW Vvvv
                                                  ]
                           }
                       ]
   }

i_vgatherdps :: X86Insn
i_vgatherdps = insn
   { insnDesc        = "Gather packed SP FP values using signed dword indices"
   , insnMnemonic    = "VGATHERDPS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x92
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX2
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , m32vsib32xy RO
                                                  , vec128o256 RW Vvvv
                                                  ]
                           }
                       ]
   }

i_vgatherqps :: X86Insn
i_vgatherqps = insn
   { insnDesc        = "Gather packed SP FP values using signed qword indices"
   , insnMnemonic    = "VGATHERQPS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x93
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX2
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , m32vsib64xy RO
                                                  , vec128o256 RW Vvvv
                                                  ]
                           }
                       ]
   }


i_vpgatherdd :: X86Insn
i_vpgatherdd = insn
   { insnDesc        = "Gather packed dword values using signed dword indices"
   , insnMnemonic    = "VPGATHERDD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x90
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX2
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , m32vsib32xy RO
                                                  , vec128o256 RW Vvvv
                                                  ]
                           }
                       ]
   }

i_vpgatherqd :: X86Insn
i_vpgatherqd = insn
   { insnDesc        = "Gather packed dword values using signed qword indices"
   , insnMnemonic    = "VPGATHERQD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x91
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX2
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , m32vsib64xy RO
                                                  , vec128o256 RW Vvvv
                                                  ]
                           }
                       ]
   }


i_vpgatherdq :: X86Insn
i_vpgatherdq = insn
   { insnDesc        = "Gather packed qword values using signed dword indices"
   , insnMnemonic    = "VGATHERDQ"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x90
                           , vexLW              = W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX2
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , m32vsib32x RO
                                                  , vec128o256 RW Vvvv
                                                  ]
                           }
                       ]
   }

i_vpgatherqq :: X86Insn
i_vpgatherqq = insn
   { insnDesc        = "Gather packed qword values using signed qword indices"
   , insnMnemonic    = "VPGATHERQQ"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x91
                           , vexLW              = W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX2
                                                  ]
                           , vexParams          = [ vec128o256 RW Reg
                                                  , m64vsib64xy RO
                                                  , vec128o256 RW Vvvv
                                                  ]
                           }
                       ]
   }


i_vinsertf128 :: X86Insn
i_vinsertf128 = insn
   { insnDesc        = "Insert packed floating-point values"
   , insnMnemonic    = "VINSERTF128"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x03
                           , vexOpcode          = 0x18
                           , vexLW              = L1_W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec256 WO Reg
                                                  , vec256 RO Vvvv
                                                  , mvec128 RO
                                                  , imm8
                                                  ]
                           }
                       ]
   }


i_vinserti128 :: X86Insn
i_vinserti128 = insn
   { insnDesc        = "Insert packed integer values"
   , insnMnemonic    = "VINSERTI128"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x03
                           , vexOpcode          = 0x38
                           , vexLW              = L1_W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec256 WO Reg
                                                  , vec256 RO Vvvv
                                                  , mvec128 RO
                                                  , imm8
                                                  ]
                           }
                       ]
   }


i_vmaskmovps :: X86Insn
i_vmaskmovps = insn
   { insnDesc        = "Conditional SIMD packed SP FP values loads and stores"
   , insnMnemonic    = "VMASKMOVPS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x2C
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , vec128o256 RO Vvvv
                                                  , mem128o256 RO
                                                  ]
                           }
                       , vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x2E
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ mem128o256 WO
                                                  , vec128o256 RO Vvvv
                                                  , vec128o256 WO Reg
                                                  ]
                           }
                       ]
   }


i_vmaskmovpd :: X86Insn
i_vmaskmovpd = insn
   { insnDesc        = "Conditional SIMD packed DP FP values loads and stores"
   , insnMnemonic    = "VMASKMOVPD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x2D
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , vec128o256 RO Vvvv
                                                  , mem128o256 RO
                                                  ]
                           }
                       , vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x2F
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ mem128o256 WO
                                                  , vec128o256 RO Vvvv
                                                  , vec128o256 WO Reg
                                                  ]
                           }
                       ]
   }


i_vblendd :: X86Insn
i_vblendd = insn
   { insnDesc        = "Blend packed dwords"
   , insnMnemonic    = "VBLENDD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x03
                           , vexOpcode          = 0x02
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX2
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  , imm8
                                                  ]
                           }
                       ]
   }


i_vpbroadcastb :: X86Insn
i_vpbroadcastb = insn
   { insnDesc        = "Broadcast a byte"
   , insnMnemonic    = "VPBROADCASTB"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x78
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX2
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , mvec128low8 RO
                                                  ]
                           }
                       ]
   }


i_vpbroadcastw :: X86Insn
i_vpbroadcastw = insn
   { insnDesc        = "Broadcast a word"
   , insnMnemonic    = "VPBROADCASTW"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x79
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX2
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , mvec128low16 RO
                                                  ]
                           }
                       ]
   }


i_vpbroadcastd :: X86Insn
i_vpbroadcastd = insn
   { insnDesc        = "Broadcast a dword"
   , insnMnemonic    = "VPBROADCASTD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x58
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX2
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , mvec128low32 RO
                                                  ]
                           }
                       ]
   }


i_vpbroadcastq :: X86Insn
i_vpbroadcastq = insn
   { insnDesc        = "Broadcast a qword"
   , insnMnemonic    = "VPBROADCASTQ"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x59
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX2
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , mvec128low64 RO
                                                  ]
                           }
                       ]
   }


i_vpbroadcasti128 :: X86Insn
i_vpbroadcasti128 = insn
   { insnDesc        = "Broadcast a 128-bit integer"
   , insnMnemonic    = "VPBROADCASTI128"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x5A
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX2
                                                  ]
                           , vexParams          = [ vec256 WO Reg
                                                  , mem128 RO
                                                  ]
                           }
                       ]
   }


i_vpermd :: X86Insn
i_vpermd = insn
   { insnDesc        = "Full doublewords element permutation"
   , insnMnemonic    = "VPERMD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x36
                           , vexLW              = L1_W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX2
                                                  ]
                           , vexParams          = [ vec256 WO Reg
                                                  , vec256 RO Vvvv
                                                  , mvec256 RO
                                                  ]
                           }
                       ]
   }


i_vpermpd :: X86Insn
i_vpermpd = insn
   { insnDesc        = "Full DP FP element permutation"
   , insnMnemonic    = "VPERMPD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x03
                           , vexOpcode          = 0x01
                           , vexLW              = L1_W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX2
                                                  ]
                           , vexParams          = [ vec256 WO Reg
                                                  , mvec256 RO
                                                  , imm8
                                                  ]
                           }
                       ]
   }


i_vpermps :: X86Insn
i_vpermps = insn
   { insnDesc        = "Full SP FP element permutation"
   , insnMnemonic    = "VPERMPS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x01
                           , vexLW              = L1_W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX2
                                                  ]
                           , vexParams          = [ vec256 WO Reg
                                                  , vec256 RO Vvvv
                                                  , mvec256 RO
                                                  ]
                           }
                       ]
   }

i_vpermq :: X86Insn
i_vpermq = insn
   { insnDesc        = "Full quadwords element permutation"
   , insnMnemonic    = "VPERMQ"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x03
                           , vexOpcode          = 0x00
                           , vexLW              = L1_W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX2
                                                  ]
                           , vexParams          = [ vec256 WO Reg
                                                  , mvec256 RO
                                                  , imm8
                                                  ]
                           }
                       ]
   }


i_vperm2i128 :: X86Insn
i_vperm2i128 = insn
   { insnDesc        = "Full 128-bit integer element permutation"
   , insnMnemonic    = "VPERMI128"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x03
                           , vexOpcode          = 0x46
                           , vexLW              = L1_W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX2
                                                  ]
                           , vexParams          = [ vec256 WO Reg
                                                  , vec256 RO Vvvv
                                                  , mvec256 RO
                                                  , imm8
                                                  ]
                           }
                       ]
   }


i_vpermilpd :: X86Insn
i_vpermilpd = insn
   { insnDesc        = "Permute DP FP values"
   , insnMnemonic    = "VPERMILPD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x0D
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       , vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x03
                           , vexOpcode          = 0x05
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , mvec128o256 RO
                                                  , imm8
                                                  ]
                           }
                       ]
   }


i_vpermilps :: X86Insn
i_vpermilps = insn
   { insnDesc        = "Permute SP FP values"
   , insnMnemonic    = "VPERMILPS"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x0C
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       , vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x03
                           , vexOpcode          = 0x04
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , mvec128o256 RO
                                                  , imm8
                                                  ]
                           }
                       ]
   }

i_vperm2f128 :: X86Insn
i_vperm2f128 = insn
   { insnDesc        = "Permute FP values"
   , insnMnemonic    = "VPERM2F128"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x03
                           , vexOpcode          = 0x06
                           , vexLW              = L1_W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec256 WO Reg
                                                  , vec256 RO Vvvv
                                                  , mvec256 RO
                                                  , imm8
                                                  ]
                           }
                       ]
   }

i_vpmaskmovd :: X86Insn
i_vpmaskmovd = insn
   { insnDesc        = "Conditional SIMD integer packed loads and stores"
   , insnMnemonic    = "VPMASKMOVD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x8C
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX2
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , vec128o256 RO Vvvv
                                                  , mem128o256 RO
                                                  ]
                           }
                       , vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x8E
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX2
                                                  ]
                           , vexParams          = [ mem128o256 WO
                                                  , vec128o256 RO Vvvv
                                                  , vec128o256 WO Reg
                                                  ]
                           }
                       ]
   }


i_vpmaskmovq :: X86Insn
i_vpmaskmovq = insn
   { insnDesc        = "Conditional SIMD integer packed loads and stores"
   , insnMnemonic    = "VPMASKMOVQ"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x8C
                           , vexLW              = W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX2
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , vec128o256 RO Vvvv
                                                  , mem128o256 RO
                                                  ]
                           }
                       , vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x8E
                           , vexLW              = W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX2
                                                  ]
                           , vexParams          = [ mem128o256 WO
                                                  , vec128o256 RO Vvvv
                                                  , vec128o256 WO Reg
                                                  ]
                           }
                       ]
   }


i_vpsllvd :: X86Insn
i_vpsllvd = insn
   { insnDesc        = "Variable bit shift left logical"
   , insnMnemonic    = "VPSLLVD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x47
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX2
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vpsllvq :: X86Insn
i_vpsllvq = insn
   { insnDesc        = "Variable bit shift left logical"
   , insnMnemonic    = "VPSLLVQ"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x47
                           , vexLW              = W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX2
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vpsravd :: X86Insn
i_vpsravd = insn
   { insnDesc        = "Variable bit shift right logical"
   , insnMnemonic    = "VPSRAVD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x46
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX2
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vpsrlvd :: X86Insn
i_vpsrlvd = insn
   { insnDesc        = "Variable bit shift right logical"
   , insnMnemonic    = "VPSRLVD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x45
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX2
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vpsrlvq :: X86Insn
i_vpsrlvq = insn
   { insnDesc        = "Variable bit shift right logical"
   , insnMnemonic    = "VPSRLVQ"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x45
                           , vexLW              = W1
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX2
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vtestpd :: X86Insn
i_vtestpd = insn
   { insnDesc        = "Packed bit test"
   , insnMnemonic    = "VTESTPD"
   , insnFlags       = [ Modified [ZF,CF]
                       , Unset [OF,AF,PF,SF]
                       ]
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x0E
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 RO Reg
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vtestps :: X86Insn
i_vtestps = insn
   { insnDesc        = "Packed bit test"
   , insnMnemonic    = "VTESTPS"
   , insnFlags       = [ Modified [ZF,CF]
                       , Unset [OF,AF,PF,SF]
                       ]
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x02
                           , vexOpcode          = 0x0F
                           , vexLW              = W0
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 RO Reg
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }


i_vzeroall :: X86Insn
i_vzeroall = insn
   { insnDesc        = "Zero all YMM registers"
   , insnMnemonic    = "VZEROALL"
   , insnEncodings   = [ vex
                           { vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x77
                           , vexLW              = L1_WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           }
                       ]
   }


i_vzeroupper :: X86Insn
i_vzeroupper = insn
   { insnDesc        = "Zero upper bits YMM registers"
   , insnMnemonic    = "VZEROUPPER"
   , insnEncodings   = [ vex
                           { vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x77
                           , vexLW              = L0_WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           }
                       ]
   }


i_fwait :: X86Insn
i_fwait = insn
   { insnDesc        = "Check pending unmasked FP exceptions"
   , insnMnemonic    = "FWAIT"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x9B
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           }
                        ]
   }


i_wbinvd :: X86Insn
i_wbinvd = insn
   { insnDesc        = "Write back and invalidate cache"
   , insnMnemonic    = "WBINVD"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x09
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           }
                        ]
   }

i_wrfsbase :: X86Insn
i_wrfsbase = insn
   { insnDesc        = "Write FS segment base"
   , insnMnemonic    = "WRFSBASE"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF3
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xAE
                           , legacyOpcodeExt       = Just 2
                           , legacyProperties      = [ LongModeSupport
                                                     , Extension FSGSBASE
                                                     ]
                           , legacyParams          = [ reg32o64 RO RM
                                                     , reg R_FS WO Implicit
                                                     ]
                           }
                       ]
   }


i_wrgsbase :: X86Insn
i_wrgsbase = insn
   { insnDesc        = "Write GS segment base"
   , insnMnemonic    = "WRGSBASE"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0xF3
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xAE
                           , legacyOpcodeExt       = Just 3
                           , legacyProperties      = [ LongModeSupport
                                                     , Extension FSGSBASE
                                                     ]
                           , legacyParams          = [ reg32o64 RO RM
                                                     , reg R_GS WO Implicit
                                                     ]
                           }
                       ]
   }

i_wrmsr :: X86Insn
i_wrmsr = insn
   { insnDesc        = "Write to Model Specific Register (MSR)"
   , insnMnemonic    = "WRMSR"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x30
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ eDXeAX RO
                                                     , reg R_ECX RO Implicit
                                                     ]
                           }
                       ]
   }

i_wrpkru :: X86Insn
i_wrpkru = insn
   { insnDesc        = "Write data to user page key register"
   , insnMnemonic    = "WRPKRU"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x01
                           , legacyOpcodeFullExt   = Just 0xEF
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension OSPKE
                                                     ]
                           , legacyParams          = [ rAX RO
                                                     , rDX RO
                                                     , reg R_ECX RO Implicit
                                                     ]
                           }
                       ]
   }


i_xabort :: X86Insn
i_xabort = insn
   { insnDesc        = "Transactional abort"
   , insnMnemonic    = "XABORT"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xC6
                           , legacyOpcodeFullExt   = Just 0xF8
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension RTM
                                                     ]
                           , legacyParams          = [ imm8
                                                     , reg R_EAX WO Implicit
                                                     ]
                           }
                       ]
   }


i_xadd :: X86Insn
i_xadd = insn
   { insnDesc        = "Exchange and add"
   , insnMnemonic    = "XADD"
   , insnFlags       = [ Modified [CF,PF,AF,SF,ZF,OF] ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0xC0
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Lockable
                                                     , HLE XBoth
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , gpr WO Reg
                                                     ]
                           }
                       ]
   }

i_xbegin :: X86Insn
i_xbegin = insn
   { insnDesc        = "Transactional begin"
   , insnMnemonic    = "XBEGIN"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xC7
                           , legacyOpcodeFullExt   = Just 0xF8
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension RTM
                                                     ]
                           , legacyParams          = [ rel16o32 ]
                           }
                       ]
   }

i_xchg :: X86Insn
i_xchg = insn
   { insnDesc        = "Exchange"
   , insnMnemonic    = "XCHG"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x90
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , ImplicitLock
                                                     , Commutable
                                                     ]
                           , legacyParams          = [ regAccu RW
                                                     , gpr RW OpcodeLow3
                                                     ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x86
                           , legacyNoForce8bit     = Just 0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , ImplicitLock
                                                     , HLE XBoth
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , gpr RW Reg
                                                     ]
                           }
                       ]
   }

i_xend :: X86Insn
i_xend = insn
   { insnDesc        = "Transactional end"
   , insnMnemonic    = "XEND"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x01
                           , legacyOpcodeFullExt   = Just 0xD5
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension RTM
                                                     ]
                           }
                       ]
   }


i_xgetbv :: X86Insn
i_xgetbv = insn
   { insnDesc        = "Get value of extended control register"
   , insnMnemonic    = "XGETBV"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x01
                           , legacyOpcodeFullExt   = Just 0xD0
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ rDXrAX WO
                                                     , reg R_ECX RO Implicit
                                                     ]
                           }
                       ]
   }


i_xlat :: X86Insn
i_xlat = insn
   { insnDesc        = "Table look-up translation"
   , insnMnemonic    = "XLAT"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0xD7
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ reg R_AL RW Implicit
                                                     , reg R_DS RO Implicit
                                                     , regFam RegFamBX RO Implicit
                                                     -- FIXME: we don't encode
                                                     -- the effective address:
                                                     -- [DS:rBX + zero_extend(AL)]
                                                     ]
                           }
                       ]
   }

i_xor :: X86Insn
i_xor = insn
   { insnDesc        = "Logical exclusive OR"
   , insnMnemonic    = "XOR"
   , insnFlags       = [ Unset     [OF,CF]
                       , Modified  [SF,ZF,PF]
                       , Undefined [AF]
                       ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0x34
                           , legacyNoForce8bit  = Just 0
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ regAccu RW
                                                  , immSE
                                                  ]
                           }
                       , leg
                           { legacyOpcodeMap    = MapPrimary
                           , legacyOpcode       = 0x30
                           , legacyNoForce8bit  = Just 0
                           , legacyReversable   = Just 1
                           , legacyProperties   = [ Lockable
                                                  , LegacyModeSupport
                                                  , LongModeSupport
                                                  , HLE XBoth
                                                  ]
                           , legacyParams       = [ mgpr RW
                                                  , gpr RO Reg
                                                  ]
                           }
                       , leg
                           { legacyOpcodeMap       = MapPrimary
                           , legacyOpcode          = 0x80
                           , legacyOpcodeExt       = Just 6
                           , legacyNoForce8bit     = Just 0
                           , legacySignExtendable  = Just 1
                           , legacyProperties      = [ Lockable
                                                     , LegacyModeSupport
                                                     , LongModeSupport
                                                     , HLE XBoth
                                                     ]
                           , legacyParams          = [ mgpr RW
                                                     , immSE
                                                     ]
                           }
                       ]
   }

i_xorpd :: X86Insn
i_xorpd = insn
   { insnDesc        = "Bitwise logical XOR of packed double-precision floating-point values"
   , insnMnemonic    = "XORPD"
   , insnEncodings   = [ leg
                           { legacyMandatoryPrefix = Just 0x66
                           , legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x57
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension SSE2
                                                     ]
                           , legacyParams          = [ vec128 RW Reg
                                                     , mvec128 RO
                                                     ]
                           }
                       ]
   }

i_vxorpd :: X86Insn
i_vxorpd = insn
   { insnDesc        = "Bitwise logical XOR of packed double-precision floating-point values"
   , insnMnemonic    = "VXORPD"
   , insnEncodings   = [ vex
                           { vexMandatoryPrefix = Just 0x66
                           , vexOpcodeMap       = MapVex 0x01
                           , vexOpcode          = 0x57
                           , vexLW              = WIG
                           , vexProperties      = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension AVX
                                                  ]
                           , vexParams          = [ vec128o256 WO Reg
                                                  , vec128o256 RO Vvvv
                                                  , mvec128o256 RO
                                                  ]
                           }
                       ]
   }

i_xorps :: X86Insn
i_xorps = insn
   { insnDesc        = "Bitwise logical XOR of packed float-precision floating-point values"
   , insnMnemonic    = "XORPS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0x57
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  , Extension SSE
                                                  ]
                           , legacyParams       = [ vec128 RW Reg
                                                  , mvec128 RO
                                                  ]
                           }
                       ]
   }

i_vxorps :: X86Insn
i_vxorps = insn
   { insnDesc        = "Bitwise logical XOR of packed float-precision floating-point values"
   , insnMnemonic    = "VXORPS"
   , insnEncodings   = [ vex
                           { vexOpcodeMap    = MapVex 0x01
                           , vexOpcode       = 0x57
                           , vexLW           = WIG
                           , vexProperties   = [ LegacyModeSupport
                                               , LongModeSupport
                                               , Extension AVX
                                               ]
                           , vexParams       = [ vec128o256 WO Reg
                                               , vec128o256 RO Vvvv
                                               , mvec128o256 RO
                                               ]
                           }
                       ]
   }


i_xrstor :: X86Insn
i_xrstor = insn
   { insnDesc        = "Restore processor extended states"
   , insnMnemonic    = "XRSTOR"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0xAE
                           , legacyOpcodeExt    = Just 5
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ mstate RO
                                                  , rDXrAX RO
                                                  ]
                           }
                       ]
   }


i_xrstors :: X86Insn
i_xrstors = insn
   { insnDesc        = "Restore processor extended states supervisor"
   , insnMnemonic    = "XRSTORS"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0xC7
                           , legacyOpcodeExt    = Just 3
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ mstate RO
                                                  , rDXrAX RO
                                                  ]
                           }
                       ]
   }


i_xsave :: X86Insn
i_xsave = insn
   { insnDesc        = "Save processor extended states"
   , insnMnemonic    = "XSAVE"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0xAE
                           , legacyOpcodeExt    = Just 4
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ mstate WO
                                                  , rDXrAX RO
                                                  ]
                           }
                       ]
   }



i_xsavec :: X86Insn
i_xsavec = insn
   { insnDesc        = "Save processor extended states with compaction"
   , insnMnemonic    = "XSAVEC"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0xC7
                           , legacyOpcodeExt    = Just 4
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ mstate WO
                                                  , rDXrAX RO
                                                  ]
                           }
                       ]
   }


i_xsaveopt :: X86Insn
i_xsaveopt = insn
   { insnDesc        = "Save processor extended states optimized"
   , insnMnemonic    = "XSAVEOPT"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0xAE
                           , legacyOpcodeExt    = Just 6
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ mstate WO
                                                  , rDXrAX RO
                                                  ]
                           }
                       ]
   }


i_xsaves :: X86Insn
i_xsaves = insn
   { insnDesc        = "Save processor extended states supervisor"
   , insnMnemonic    = "XSAVES"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap    = Map0F
                           , legacyOpcode       = 0xC7
                           , legacyOpcodeExt    = Just 5
                           , legacyProperties   = [ LegacyModeSupport
                                                  , LongModeSupport
                                                  ]
                           , legacyParams       = [ mstate WO
                                                  , rDXrAX RO
                                                  ]
                           }
                       ]
   }

i_xsetbv :: X86Insn
i_xsetbv = insn
   { insnDesc        = "Set value of extended control register"
   , insnMnemonic    = "XSETBV"
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x01
                           , legacyOpcodeFullExt   = Just 0xD1
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     ]
                           , legacyParams          = [ rDXrAX RO
                                                     , reg R_ECX RO Implicit
                                                     ]
                           }
                       ]
   }


i_xtest :: X86Insn
i_xtest = insn
   { insnDesc        = "Test if in transactional execution"
   , insnMnemonic    = "XTEST"
   , insnFlags       = [ Modified [ZF]
                       , Unset [CF,OF,SF,PF,AF]
                       ]
   , insnEncodings   = [ leg
                           { legacyOpcodeMap       = Map0F
                           , legacyOpcode          = 0x01
                           , legacyOpcodeFullExt   = Just 0xD6
                           , legacyProperties      = [ LegacyModeSupport
                                                     , LongModeSupport
                                                     , Extension RTM
                                                     ]
                           }
                       ]
   }
