\chapter{Enters OpenCL}

\epigraph{
All different kinds with different ways\\
It would take a lifetime to explain\\
No one's exactly the same}
{No Doubt, \textit{Different People}}

In this chapter we will add support for OpenCL device memories. First we need to
understand a little bit how OpenCL platform model works. OpenCL basically
provides two API: \texttt{clGetPlatformIDs} to list available platforms and
\texttt{clGetDeviceIDs} to list available devices for each platform. In a
perfect world, for each device you could use \texttt{clCreateBuffer} and
\texttt{clReleaseMemObject} to allocate and release buffers (respectively). Well
in fact, it is not that easy: you have to create a \texttt{Context} entity (with
\texttt{clCreateContext} to create a group of devices before you can allocate a
buffer that is associated to the context and not to the device.

The first question that should come to mind is: how does the runtime system know
onto which device of the context it has to allocate the buffer? It is trivial if
there is only one device in the context, but otherwise it is impossible. So
buffers are lazily allocated on appropriate devices when another command (kernel
execution, etc.) requires them. As a consequence, out-of-capacity errors can be
returned by commands that do not perform any allocation. As it is hardly
manageable, we would like to force the allocation in the first place. Before
OpenCL 1.2, you cannot easily do it: you have to execute a command such as a
data transfer or a kernel execution involving the buffer and the device.
Starting with OpenCL 1.2, a new \texttt{clEnqueueMigrateMemObjects} method let
host code control where buffers have to be allocated. As for every OpenCL, this
one has to be submitted into a command queue (associated to a single device)
created with \texttt{clCreateCommandQueue}.

We could use the Foreign Function Interface (FFI) just like we did for
\texttt{malloc} previously. However, the difference is that OpenCL may not be
available on the target architecture. One solution is to add pragmas in our code
to decide at compilation time if OpenCL is enabled and compile the code
appropriately. This solution is not satisfactory because we could not distribute
a binary of our library. Instead we use dynamic linking so that programs using
our library could dynamically chose to use OpenCL or not.

Each hardware vendor can provide its own OpenCL implementation for its
accelerators in the form of a library exporting appropriate symbols. When
several accelerators from different vendors are available, the different
implementations have to be used in conjunction. To avoid mixing up symbols,
implementations of the OpenCL Installable Client Driver (ICD) provide a
multiplexer for OpenCL libraries. However it is quite badly designed, especially
when different implementations implement different versions of the OpenCL
specification.

Haskell provides dynamic linking methods for Posix compliant systems in the
\texttt{System.Posix.DynamicLinker} package. Instead of directly using them, I
have developed a package called \texttt{dynamic-linker-template} that uses
Template Haskell (TH) to remove most of the boilerplate code. TH allows to
perform meta-programming and to generate Haskell code given the code already
parsed in a module. In my package, I use it to get the field names of a data
type and to generate the code that loads symbols with these names from a
library dynamically.

TODO: 
\begin{itemize}
   \item Dynamic Linking
   \item Dynamic Linker Template
   \item Platform Configuration (clEnableCPU, ...)
   \item Hybrid Host/OpenCL\_CPU buffer
   \begin{itemize}
      \item Hybrid = HB HostBuffer | CLB OpenCLBuffer
      \item Method to transform one into the other (CL\_MEM\_USE\_HOST\_PTR)
      \item Should be cost-free...
      \item Intel OpenCL: bad alignment = duplication
   \end{itemize}
   \item Region, Link
   \item Synchronous data transfer / asynchronous?
   \item Method to bench link speed (no NUMA support, nor NUIOA)
\end{itemize}

\summary{
In this chapter we added support for dynamic linking with the OpenCL library and
memory management (\texttt{allocate} and \texttt{release}) into OpenCL devices.
We introduced \texttt{Link} and \texttt{Region} types, we added a method to list
available memories in a platform and we provided a method to perform data
transfers on links.

More specifically, we used:
\begin{itemize}
   \item OpenCL Platform model
   \item Template Haskell
\end{itemize}
}
