\chapter{Architecture Model: Memory}

\epigraph{Memory, all alone in the moonlight}{Barbra Streisand,
\textit{Memory}}

%% Bertrand:
%% voui mais c'est un peu agressif de dire que OpenCL c'est le contre exemple du
%% truc bien fait.
The first thing we need to decide is how the architecture will be represented
inside the environment.  As a counter example, in the OpenCL specification, an
architecture is composed of several platforms, themselves composed of several
devices. Each device contains one memory and can execute kernels. Obviously, it
is flawed: platforms make no sense and are not interoperable, device can contain
several memories and processing units of different kinds, etc. We will try to do
a better job at defining an architecture model.

The first entity we define is \texttt{Memory}. Perhaps a better name would be
\texttt{Storage}. Each memory should be identifiable so we give them a unique
identifier. In addition, as there are many kinds of memory units involved in
architectures (hard disks, RAM, OpenCL device memory, etc.), we introduce the
algebraic data type \texttt{MemoryPeer} to store driver specific details. We
will later add parameters to the constructor for each driver.

\begin{lstlisting}
type ID = Int

data Memory = Memory {
   memoryId :: ID,
   memoryPeer :: MemoryPeer
}

data MemoryPeer =
     HostMemory
   | CUDAMemory
   | OpenCLMemory
   | DiskMemory
\end{lstlisting}

Basically, the only thing a program can do with a memory is to associate a
region of it with an opaque identifier: this is called allocating and the result
is called a buffer. Removing this association is called (buffer) releasing.
Hence we define a \texttt{Buffer} entity. Depending on the kind of memory we
consider, the low-level identifier will be different. For instance, for the host
memory and CUDA we get a pointer, for OpenCL we get an opaque \texttt{clMem}
entity, for a hard disk we get a file name\ldots These different identifiers are
represented with the algebraic data type \texttt{BufferPeer} (constructors will
be extended later too).

\begin{lstlisting}
import Foreign.Ptr

data Buffer = Buffer {
   bufferMemory :: Memory,
   bufferPeer :: BufferPeer
}

data BufferPeer = 
     HostBuffer (Ptr ())
   | CUDABuffer
   | OpenCLBuffer
   | DiskBuffer
\end{lstlisting}

We would like to keep track of buffers that have been allocated in each memory.
A purely functional approach would be to add the following field:
\begin{lstlisting}
data Memory = Memory {
   ...
   memoryBuffers :: [Buffer]
}
\end{lstlisting}

To modify the field, we would have to duplicate the whole structure while
assigning a new value to the field, using one of the \texttt{lens} package
available to avoid most boilerplate code. This is not a satisfactory solution
because we envision that several threads will need to access this field
concurrently.  Instead, we add a mutable field that can be concurrently accessed
through software transactional memory (STM): we use a \texttt{TVar} type. Don't
forget to add the \texttt{stm} package to the list of dependencies.

\begin{lstlisting}
import Control.Concurrent.STM

data Memory = Memory {
   ...
   memoryBuffers :: TVar [Buffer]
}
\end{lstlisting}

Now we can provide our first memory primitives: allocate and release.
Allocations may fail for different reasons (capacity exhaustion, etc.) so the
\texttt{allocate} method may either return a \texttt{Buffer} or an error. In
Haskell we use the \texttt{Either} data type to handle this case. It has two
constructors: \texttt{Left} and \texttt{Right}. The convention is to use the
\texttt{Right} constructor to store the valid ("right") value, in our case the
buffer. In addition we want to store the size of the buffer into the buffer
structure, so we add a new field. We set the type of a buffer size to be
\texttt{Word64} so that it should be large enough on most architectures.


\begin{lstlisting}
import Data.Word

data Buffer = Buffer {
   ...
   bufferSize :: BufferSize
   ...
}

type BufferSize = Word64

data AllocError = 
     ErrAllocOutOfMemory
   | ErrAllocUnknown

allocate :: BufferSize -> Memory -> IO (Either AllocError Buffer)
allocate size mem = ...
\end{lstlisting}

The implementation of \texttt{allocate} is different for each driver. For now we
only provide the one for the host memory. We use the foreign function interface
(FFI) to have access to the native \texttt{malloc} and \texttt{free} functions.

\begin{lstlisting}
{-# LANGUAGE ForeignFunctionInterface #-}

import Foreign.C.Types

foreign import ccall unsafe "stdlib.h malloc"  malloc :: CSize -> IO (Ptr a)
foreign import ccall unsafe "stdlib.h free"    free   :: Ptr a -> IO ()

-- | Allocate a buffer in host memory
allocateHost :: Word64 -> Memory -> IO (Either AllocError BufferPeer)
allocateHost size _ = do
   ptr <- malloc (fromIntegral size)
   return $ if ptr == nullPtr
      then Left ErrAllocOutOfMemory
      else Right (HostBuffer ptr)
\end{lstlisting}

As we only provide the one for the host memory, we use \texttt{undefined} to
fill the blank and have a program that compiles anyway. In addition, when a
buffer is successfully allocated, it has to be added to the memory buffer list
using STM primitives. This is what the following code do:

\begin{lstlisting}
allocate :: BufferSize -> Memory -> IO (Either AllocError Buffer)
allocate size mem = do

   bufPeer <- case memoryPeer mem of
      HostMemory   -> allocateHost size mem
      CUDAMemory   -> undefined
      OpenCLMemory -> undefined
      DiskMemory   -> undefined

   case bufPeer of
      Left err -> return (Left err)
      Right peer -> do
         let buf = Buffer mem size peer
         atomically $ modifyTVar (memoryBuffers mem) ((:) buf)
         return (Right buf)
\end{lstlisting}

To simplify the code a little bit, we can observe\footnote{Hopefully it will be
true by the time you read this...} that \texttt{Either a} has an instance for
the \texttt{Traversable} type class. It means that we can use \texttt{traverse}
to apply a function to the \texttt{Right} value, if applicable. If we have a
\texttt{Left} value (an error in our case), \texttt{traverse} does not do
anything. Basically, we can rewrite our code as follows.

\begin{lstlisting}
import Data.Traversable

allocate :: BufferSize -> Memory -> IO (Either AllocError Buffer)
allocate size mem = allocPeer >>= traverse wrapStore
   where
      allocPeer = case memoryPeer mem of
         HostMemory   -> allocateHost size mem
         CUDAMemory   -> undefined
         OpenCLMemory -> undefined
         DiskMemory   -> undefined

      wrapStore peer = do
         let buf = Buffer mem size peer
         atomically $ modifyTVar (memoryBuffers mem) ((:) buf)
         return buf
\end{lstlisting}

Finally we can add the \texttt{release} primitive. Before we need to remove the
buffer from the list of allocated buffers of the memory it is allocated in.
Hence, we need to be able to find the buffer in the list and to delete it. To do
that, \texttt{Buffer} must be an instance of the \texttt{Eq} type class. We
first create an instance of \texttt{Eq} for \texttt{Memory} as it is easy given
there is a unique identifier field. Then we can automatically derive the
\texttt{Eq} instances for \texttt{BufferPeer} and \texttt{Buffer}.

\begin{lstlisting}
import Data.List

instance Eq Memory where
   (==) a b = memoryId a == memoryId b

data Buffer = Buffer {
   ...
} deriving (Eq)

data BufferPeer = ... deriving (Eq)

release :: Buffer -> IO ()
release buf = do
   atomically $ do
      let bufsVar = memoryBuffers (bufferMemory buf)
      bufs <- readTVar bufsVar
      writeTVar bufsVar (delete buf bufs)

   case bufferPeer buf of
      HostBuffer ptr -> free ptr
      CUDABuffer     -> undefined
      OpenCLBuffer   -> undefined
      DiskBuffer     -> undefined
\end{lstlisting}

We can test that it is quite working with the following GHCI session:
\begin{lstlisting}
> import ViperVM.Platform.Platform
> import Control.Concurrent.STM
> import Control.Applicative
> m <- Memory 1 HostMemory <$> atomically (newTVar [])
> Right b <- allocate 10000 m
> length <$> atomically (readTVar (memoryBuffers m))
1
> Left err <- allocate 100000000000000 m
> length <$> atomically (readTVar (memoryBuffers m))
1
> release b
> length <$> atomically (readTVar (memoryBuffers m))
0
\end{lstlisting}

\summary{
In this chapter we described \texttt{Memory} and \texttt{Buffer} entities. We
provided two actions (\texttt{allocate} and \texttt{release}) that we
implemented for the host driver (main memory).
We showed the use of:
\begin{itemize}
   \item Algebraic data types (with and without field accessors)
   \item Type class instances (explicit and automatically derived)
   \item Pattern matching
   \item IO Monad
   \item Foreign Function Interface (FFI)
   \item Software Transactional Memory (STM)
   \item GHCI
\end{itemize}
}
